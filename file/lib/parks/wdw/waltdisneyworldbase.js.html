<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">lib/parks/wdw/waltdisneyworldbase.js | @themeparks/parksapi</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ThemeParks/parksapi"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/configBase.js~ConfigBase.html">ConfigBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getCache">getCache</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseConfig">parseConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-reusePromise">reusePromise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-reusePromiseForever">reusePromiseForever</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#cache">cache</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheBase.js~CacheBase.html">CacheBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheLevel.js~CacheLevel.html">CacheLevel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheLmdb.js~CacheLmdb.html">CacheLmdb</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheMemory.js~CacheMemory.html">CacheMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/scopedCache.js~ScopedCache.html">ScopedCache</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks">parks</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/database.js~Database.html">Database</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/destination.js~Destination.html">Destination</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/entity.js~Entity.html">Entity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/park.js~Park.html">Park</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-HTTP">HTTP</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-generateRandomAndroidUseragent">generateRandomAndroidUseragent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setOverrideFunction">setOverrideFunction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getLiveDataErrors">getLiveDataErrors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validateEntitySchedule">validateEntitySchedule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Sieve">Sieve</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getValidTagObject">getValidTagObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isSimpleTagType">isSimpleTagType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isValidTag">isValidTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isValidTagType">isValidTagType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-attractionType">attractionType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-boardingGroupState">boardingGroupState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-entityType">entityType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-queueType">queueType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-returnTimeState">returnTimeState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-scheduleType">scheduleType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-statusType">statusType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-tagType">tagType</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-attractionsio">parks/attractionsio</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/attractionsio/attractionsio.js~AltonTowers.html">AltonTowers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/attractionsio/attractionsio.js~AttractionsIO.html">AttractionsIO</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/attractionsio/attractionsio.js~ChessingtonWorldOfAdventures.html">ChessingtonWorldOfAdventures</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/attractionsio/attractionsio.js~Gardaland.html">Gardaland</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/attractionsio/attractionsio.js~HeidePark.html">HeidePark</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/attractionsio/attractionsio.js~LegolandOrlando.html">LegolandOrlando</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/attractionsio/attractionsio.js~LegolandWindsor.html">LegolandWindsor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/attractionsio/attractionsio.js~ThorpePark.html">ThorpePark</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-efteling">parks/efteling</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/efteling/efteling.js~Efteling.html">Efteling</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-europa">parks/europa</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/europa/europapark.js~EuropaPark.html">EuropaPark</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/europa/europaparkdb.js~DatabaseEuropaPark.html">DatabaseEuropaPark</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-herschend">parks/herschend</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/herschend/herschendparks.js~Dollywood.html">Dollywood</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/herschend/herschendparks.js~HerschendDestination.html">HerschendDestination</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/herschend/herschendparks.js~SilverDollarCity.html">SilverDollarCity</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-parcasterix">parks/parcasterix</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/parcasterix/parcasterix.js~ParcAsterix.html">ParcAsterix</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-phantasialand">parks/phantasialand</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/phantasialand/phantasialand.js~Phantasialand.html">Phantasialand</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-plopsaland">parks/plopsaland</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/plopsaland/plopsa.js~HolidayPark.html">HolidayPark</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/plopsaland/plopsa.js~PlopsaBase.html">PlopsaBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/plopsaland/plopsa.js~Plopsaland.html">Plopsaland</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-tdr">parks/tdr</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort.html">TokyoDisneyResort</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-toverland">parks/toverland</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/toverland/toverland.js~Toverland.html">Toverland</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-universal">parks/universal</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/universal/universal.js~UniversalOrlando.html">UniversalOrlando</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/universal/universal.js~UniversalResortBase.html">UniversalResortBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/universal/universal.js~UniversalStudios.html">UniversalStudios</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/universal/universalstudios.js~UniversalIslandsOfAdventure.html">UniversalIslandsOfAdventure</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/universal/universalstudios.js~UniversalParkBase.html">UniversalParkBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/universal/universalstudios.js~UniversalStudios.html">UniversalStudios</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/universal/universalstudios.js~UniversalStudiosFlorida.html">UniversalStudiosFlorida</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/universal/universalstudios.js~UniversalVolcanoBay.html">UniversalVolcanoBay</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-wdw">parks/wdw</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort.html">DisneyLiveResort</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/wdw/waltdisneyworldbase.js~DisneylandResort.html">DisneylandResort</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/wdw/waltdisneyworldbase.js~HongKongDisneyland.html">HongKongDisneyland</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldResort.html">WaltDisneyWorldResort</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/wdw/wdwdatabase.js~DatabaseWDW.html">DatabaseWDW</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/wdw/wdwdb.js~IndexedWDWDB.html">IndexedWDWDB</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getDatabase">getDatabase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEntityID">getEntityID</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/parks/wdw/waltdisneyworldbase.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import moment from &apos;moment-timezone&apos;;
import {attractionType, boardingGroupState, entityType, queueType, scheduleType, statusType, returnTimeState} from &apos;../parkTypes.js&apos;;
import Destination from &apos;../destination.js&apos;;
import {getEntityID, IndexedWDWDB} from &apos;./wdwdb.js&apos;;

let wdwDB = null;
/**
 * Get a reference to the WDW database
 * @return {IndexedWDWDB}
 */
export function getDatabase() {
  if (!wdwDB) {
    wdwDB = new IndexedWDWDB();
  }
  return wdwDB;
}

// entity types that count as &quot;parks&quot;
const parkTypes = [
  &apos;theme-park&apos;,
  &apos;water-park&apos;,
];

// scheduleTypes that are actually not a schedule
const invalidScheduleTypes = [
  &apos;Closed&apos;,
  &apos;No Performance&apos;,
];

/**
 * A Resort class for a Disney live resort (WDW, DLR, HKDR)
 */
export class DisneyLiveResort extends Destination {
  /**
   * @inheritdoc
   */
  constructor(options = {}) {
    options.virtualQueueURL = options.virtualQueueURL || &apos;&apos;;
    options.genieData = options.genieData || &apos;&apos;;

    super(options);

    this.resortId = options.resortId;
    if (!this.resortId) {
      throw new Error(&apos;Missing Resort ID&apos;);
    }
    this.resortShortcode = options.resortShortcode;
    if (!this.resortShortcode) {
      throw new Error(&apos;Missing Resort Shortcode&apos;);
    }
    this.destinationDocumentIDRegex = new RegExp(`^${this.resortId};entityType=destination`);
    this.parkIds = options.parkIds || [];

    this.db = getDatabase();
  }

  /**
   * Initialise our Disney resort class
   */
  async _init() {
    await this.db.init();

    // setup our live status updating
    this.initLiveStatusUpdates();
  }

  /**
   * Get the channel ID for the facility status live update documents
   * @return {string}
   */
  getFacilityStatusChannelID() {
    return `${this.resortShortcode}.facilitystatus.1_0`;
  }

  /**
   * @private
   */
  async fetchVirtualQueueData() {
    // cache for 1 minute
    &apos;@cache|1&apos;;

    if (!this.config.virtualQueueURL) return undefined;

    return (await this.http(&apos;GET&apos;, this.config.virtualQueueURL, undefined, {
      rejectUnauthorized: false,
    })).body.queues;
  }

  async fetchGenieData() {
    // cache for 1 minute
    &apos;@cache|1&apos;;

    if (!this.config.genieData) return undefined;

    return (await this.http(&apos;GET&apos;, this.config.genieData, undefined, {
      rejectUnauthorized: false,
    })).body?.entities;
  }

  /**
   * Given a status doc, build a live data object
   * @param {object} doc
   */
  async _buildLiveDataObject(doc) {
    // get full facility doc
    const entityId = getEntityID(doc.id || doc._id);
    const entityDoc = await this.db.getEntityOne(entityId);
    // if can&apos;t find it, or &quot;soft deleted&quot;, or we get back the same facility update doc, return nothing
    if (!entityDoc || entityDoc.softDeleted || entityDoc._id === doc._id) {
      return undefined;
    }

    // get our entity type
    const docEntityType = entityDoc.type;

    // skip if this doc is not a valid entity type
    /* if (docEntityType === undefined) {
      this.emit(&apos;error&apos;, doc.id || doc._id, &apos;LIVEDATA_MISSING_ENTITYTYPE&apos;, {
        message: `Live data for ${doc.id || doc._id} is missing a type. Expecting &quot;Attraction&quot;, &quot;Entertainment&quot;...`,
        entityDoc,
      });
      return undefined;
    }*/

    // figure out entity status
    let status = statusType.operating;

    // if name contains &quot;Temporarily Unavailable&quot;, mark as closed
    //  will be overriden by better metrics later, if any exist
    if (entityDoc.name &amp;&amp; entityDoc.name.indexOf(&apos;Temporarily Unavailable&apos;) &gt; 0) {
      // not refurb, as this more often than not &quot;unavailable&quot; is marked as just &quot;closed&quot;
      status = statusType.closed;
    }

    // restaurants can have status &quot;Capacity&quot;, &quot;Walk-Up Disabled&quot;
    //  currently these fallback to &quot;Operating&quot;, which matches the resturant state well enough
    if (doc.status === &apos;Down&apos;) {
      status = statusType.down;
    } else if (doc.status === &apos;Closed&apos;) {
      status = statusType.closed;
    } else if (doc.status === &apos;Refurbishment&apos;) {
      status = statusType.refurbishment;
    }

    // create base data object
    const data = {
      _id: entityDoc.id,
      status: status,
    };

    // get our genie data
    const genieData = await this.fetchGenieData();
    if (genieData) {
      const genieEntity = genieData.find((x) =&gt; {
        return x.id === entityId;
      });
      if (genieEntity) {
        const now = this.getTimeNowMoment();

        if (genieEntity.flex) {
          if (!data.queue) data.queue = {};

          if (!genieEntity.flex.available) {
            data.queue[queueType.returnTime] = {
              returnStart: null,
              returnEnd: null,
              state: returnTimeState.finished,
            };
          } else {
            const breakTime = genieEntity.flex.nextAvailableTime.split(&apos;:&apos;);

            data.queue[queueType.returnTime] = {
              returnStart: now.clone().set({
                hours: Number(breakTime[0]),
                minutes: Number(breakTime[1]),
                seconds: 0,
              }).format(),
              returnEnd: null,
              state: returnTimeState.available,
            };
          }
        }

        if (genieEntity.individual) {
          if (!data.queue) data.queue = {};

          if (!genieEntity.individual.available) {
            data.queue[queueType.paidReturnTime] = {
              returnStart: null,
              returnEnd: null,
              state: returnTimeState.finished,
              price: genieEntity.individual?.price ? {
                currency: &apos;USD&apos;,
                amount: genieEntity.individual.price ? genieEntity.individual.price * 100 : null,
              } : null,
            };
          } else {
            const breakTime = genieEntity.individual.nextAvailableTime.split(&apos;:&apos;);

            data.queue[queueType.paidReturnTime] = {
              returnStart: now.clone().set({
                hours: Number(breakTime[0]),
                minutes: Number(breakTime[1]),
                seconds: 0,
              }).format(),
              returnEnd: null,
              state: returnTimeState.available,
              price: {
                currency: &apos;USD&apos;,
                amount: genieEntity.individual.price ? genieEntity.individual.price * 100 : null,
              },
            };
          }
        }
      }
    }

    // get our vqueue data
    const vQueueData = await this.fetchVirtualQueueData();
    if (vQueueData) {
      // find matching queue data for this entity
      const attractionVQueueData = vQueueData.find((x) =&gt; {
        return x.externalDefinitionId === entityDoc.id;
      });
      if (attractionVQueueData) {
        // we have found a virtual queue!
        if (!data.queue) data.queue = {}; // make sure our queue object exists

        // figure out our allocation status
        //  default to available
        let allocationStatus = boardingGroupState.available;

        if (doc.status !== &apos;Virtual Queue&apos; || attractionVQueueData.state === &apos;CLOSED&apos;) {
          allocationStatus = boardingGroupState.closed;
        }

        // PAUSED state
        if (attractionVQueueData.state === &apos;PAUSED&apos;) {
          // if we have an upcoming allocation time, then we are temporarily paused
          if (attractionVQueueData.nextScheduledOpenTime) {
            allocationStatus = boardingGroupState.paused;
          } else {
            // otherwise... no future times? we&apos;re closed for the day
            allocationStatus = boardingGroupState.closed;
          }
        }

        // extract allocation time and present as a full datetime string
        let nextAllocationTime = null;
        if (attractionVQueueData.nextScheduledOpenTime) {
          const nowDate = this.getTimeNowMoment().format(&apos;YYYY-MM-DD&apos;);
          nextAllocationTime = moment.tz(
            `${nowDate}T${attractionVQueueData.nextScheduledOpenTime}`,
            this.config.timezone,
          ).format();
        }

        // pull estimated wait data, if valid/exists
        let estimatedWait = null;
        if (allocationStatus === boardingGroupState.available) {
          estimatedWait = attractionVQueueData.waitTimeMin || null;
        }

        data.queue[queueType.boardingGroup] = {
          allocationStatus: allocationStatus,
          currentGroupStart: attractionVQueueData.currentArrivingGroupStart || null,
          currentGroupEnd: attractionVQueueData.currentArrivingGroupEnd || null,
          nextAllocationTime: nextAllocationTime || null,
          estimatedWait,
        };
      }
    }

    // inject prediction data from Genie
    const forecastDocId = `${this.resortShortcode}.forecastedwaittimes.1_0.en_us.${data._id}`;
    try {
      const forecastDoc = await this.db.get(forecastDocId);
      if (forecastDoc &amp;&amp; forecastDoc.forecasts &amp;&amp; forecastDoc.forecasts.length &gt; 0) {
        // check forecast data is relevant for current time

        // get the largest timestamp from forecast data
        const now = this.getTimeNowMoment();
        const lastTimeslot = forecastDoc.forecasts.reduce((prev, curr) =&gt; {
          if (!curr) return prev;
          if (prev &amp;&amp; prev.timestamp &gt; curr.timestamp) {
            return prev;
          }
          return curr;
        });

        if (lastTimeslot &amp;&amp; lastTimeslot.timestamp) {
          // forecasts are in hour slots, so add an hour to the last timestamp
          const lastHour = moment(lastTimeslot.timestamp).add(1, &apos;hour&apos;);
          if (lastHour.isAfter(now)) {
            // we have a valid forecast for today, return it
            data.forecast = forecastDoc.forecasts.map((x) =&gt; {
              if (!x) return null;
              return {
                time: moment(x.timestamp).tz(this.config.timezone).format(),
                waitTime: isNaN(x.forecastedWaitMinutes) ? null : x.forecastedWaitMinutes,
                percentage: isNaN(x.percentage) ? null : x.percentage,
              };
            }).filter((x) =&gt; !!x);
          }
        }
      }
    } catch (e) { }

    // add any data from daily Entertainment feed
    if (docEntityType === &apos;Entertainment&apos;) {
      // grab entity showtimes
      // TODO - this is expensive to grab this for every single entity!!!
      const entertainmentToday = await this.db.get(`${this.resortShortcode}.today.1_0.Entertainment`);
      if (entertainmentToday &amp;&amp; entertainmentToday.facilities) {
        const showtimes = (entertainmentToday.facilities[doc.id] || []).filter((x) =&gt; {
          // ignore invalid schedule types
          return invalidScheduleTypes.indexOf(x.scheduleType) &lt; 0;
        });

        if (showtimes.length === 0) {
          data.status = statusType.closed;
        }

        // add showtimes to livedata
        data.showtimes = showtimes.map((time) =&gt; {
          return {
            startTime: moment(time.startTime).tz(this.config.timezone).format(),
            endTime: moment(time.endTime).tz(this.config.timezone).format(),
            type: time.scheduleType,
          };
        });
      }
    } else if (docEntityType === &apos;restaurant&apos;) {
      // TODO - restaurant specific live data
    } else if (docEntityType === &apos;Attraction&apos;) {
      // attraction-specific live data

      // check today&apos;s schedule for refurbishments!
      // TODO - this is expensive to grab for every single entity!
      const attractionsToday = await this.db.get(`${this.resortShortcode}.today.1_0.Attraction`);
      if (attractionsToday !== undefined &amp;&amp; attractionsToday.facilities) {
        const attractionSchedule = attractionsToday.facilities[doc.id];
        if (attractionSchedule) {
          // look for schedules with &quot;Closed&quot; or &quot;Refurb&quot;
          if (attractionSchedule.length === 1) {
            if (attractionSchedule[0].scheduleType === &apos;Closed&apos;) {
              data.status = statusType.closed;
            } else if (attractionSchedule[0].scheduleType === &apos;Refurbishment&apos;) {
              data.status = statusType.refurbishment;
            }
          }

          // TODO - store attraction operating hours in live data
        }
      }
    }

    // before we do any queue stuff, check if the lastUpdate is vaguely recent
    const lastUpdateTime = moment(doc.lastUpdate || 0);
    const now = moment();

    // if status was updated in past ~2 months, then push queue data
    //  otherwise, ignore, queues not used
    const daysSinceLastUpdate = now.diff(lastUpdateTime, &apos;days&apos;);
    if (daysSinceLastUpdate &lt; 60) {
      // report wait minutes for standBy line (if present)
      //  pretty much any entity can have waitMinutes
      // ignore if doc status is &quot;Virtual Queue&quot;, which means only Virtual Queue is available for this attraction (right now)
      if (doc.waitMinutes !== undefined &amp;&amp; doc.status !== &apos;Virtual Queue&apos;) {
        if (!data.queue) data.queue = {};
        data.queue[queueType.standBy] = {
          waitTime: doc.waitMinutes || null,
        };
      }

      // populate the single ride queue status if this ride offers single rider
      if (doc.singleRider) {
        if (!data.queue) data.queue = {};
        data.queue[queueType.singleRider] = {
          // TODO - can we get single ride wait time?
          waitTime: null,
        };
      }
    }

    return data;
  }

  /**
   * Return all current live entity data
   */
  async buildEntityLiveData() {
    // fetch the current attraction times
    const allStatusDocs = await this.db.getByChannel(this.getFacilityStatusChannelID());
    const docs = [];

    for (let i = 0; i &lt; allStatusDocs.length; i++) {
      const liveDoc = await this._buildLiveDataObject(allStatusDocs[i]);
      if (liveDoc) {
        docs.push(liveDoc);
      }
    }

    // TEMPORARY - Guardians of the Galaxy is missing from live data
    //  so add it manually to get some data through
    const isGotgAlreadyIn = docs.find((x) =&gt; x._id === &apos;411499845;entityType=Attraction&apos;);
    if (!isGotgAlreadyIn) {
      docs.push(await this._buildLiveDataObject({
        id: &apos;411499845;entityType=Attraction&apos;,
        status: &apos;Closed&apos;,
        lastUpdate: &quot;2022-05-24T13:57:46.153Z&quot;,
      }));
    }

    // loop over entertainment and pretend we have facility update docs for them
    const entertainmentToday = await this.db.get(`${this.resortShortcode}.today.1_0.Entertainment`);
    if (entertainmentToday &amp;&amp; entertainmentToday.facilities) {
      const entertainmentEntities = Object.keys(entertainmentToday.facilities);
      for (let i = 0; i &lt; entertainmentEntities.length; i++) {
        const facId = entertainmentEntities[i];
        // look for existing live data doc that has a facility status entry
        const liveDataIdx = docs.findIndex((x) =&gt; x._id === facId);
        if (liveDataIdx &lt; 0) {
          // if we don&apos;t have a doc already, we create a &quot;fake&quot; one
          // build a pretend facilitystatus doc and push to docs
          const liveData = await this._buildLiveDataObject({
            id: facId,
          });
          if (liveData) {
            docs.push(liveData);
          }
        }
      }
    }
    
    // build pretend live entity objects for any attractions with schedules (but no live data!)
    const attractionsToday = await this.db.get(`${this.resortShortcode}.today.1_0.Attraction`);
    if (attractionsToday !== undefined &amp;&amp; attractionsToday.facilities) {
      const attractionsEntities = Object.keys(attractionsToday.facilities);
      for (let i = 0; i &lt; attractionsEntities.length; i++) {
        const facId = attractionsEntities[i];
        // look for existing live data doc that has a facility status entry
        const liveDataIdx = docs.findIndex((x) =&gt; x._id === facId);
        if (liveDataIdx &lt; 0) {
          const liveData = await this._buildLiveDataObject({
            id: facId,
          });
          if (liveData) {
            docs.push(liveData);
          }
        }
      }
    }

    // TODO - do something with invalid objects (?!)
    // const errors = docs.filter((x) =&gt; x.status !== &apos;fulfilled&apos;);

    return docs;
  }

  /**
   * Setup our live status update subscriptions
   */
  async initLiveStatusUpdates() {
    // subscribe to any live facility status updates
    this.db.subscribeToChannel(this.getFacilityStatusChannelID(), async (doc) =&gt; {
      // create our live data object and submit to resort
      const livedata = await this._buildLiveDataObject(doc);
      if (!livedata) return; // skip any invalid livedata objects

      try {
        this.updateEntityLiveData(doc.id, livedata);
      } catch (e) {
        console.error(e);
      }
    });
  }

  /**
   * Given a name for an entity, clean up any strings we don&apos;t want
   * @param {string} name
   * @return {string}
   */
  sanitizeEntityName(name) {
    let newName = `${name}`;

    // trim any name endings we don&apos;t want to transfer to our entity object
    const cutoffExcessiveNameEndings = [
      &apos; &#x2013; Opens&apos;,
      &apos; - Opens&apos;,
      &apos; &#x2013; Reopening&apos;,
      &apos; - Reopening&apos;,
      &apos; &#x2013; Temporarily Unavailable&apos;,
      &apos; - Temporarily Unavailable&apos;,
      &apos; &#x2013; Temporarily &apos;,
      &apos; - Temporarily &apos;,
      &apos; &#x2013; Coming &apos;,
      &apos; - Coming &apos;,
      &apos; &#x2013; Legacy Passholder Dining&apos;,
      &apos; - Legacy Passholder Dining&apos;,
      &apos; &#x2013; Opening &apos;,
      &apos; - Opening &apos;,
      &apos; - Returning&apos;,
      &apos; &#x2013; Returning&apos;,
      &apos; &#x2013; Now Open!&apos;,
    ];
    cutoffExcessiveNameEndings.forEach((str) =&gt; {
      const substrFound = newName.indexOf(str);
      if (substrFound &gt; 0) {
        newName = newName.slice(0, substrFound);
      }
    });

    return newName;
  }

  /**
   * Given a basic document build a generic entity doc.
   * This should include all fields that are in any entity type.
   * @param {object} doc
   * @return {object}
   */
  buildBaseEntityObject(doc) {
    const entity = {
      // add any resort-agnostic data from the parent first
      ...super.buildBaseEntityObject(doc),
      _id: doc.id,
      _docId: doc._id,
      name: this.sanitizeEntityName(doc.name),
    };

    if (doc.longitude &amp;&amp; doc.latitude) {
      entity.location = {
        longitude: Number(doc.longitude),
        latitude: Number(doc.latitude),
        // TODO - return entrance/exit/shop/etc. interesting points
        //  that aren&apos;t neccessarily the &quot;main location&quot;
        pointsOfInterest: [],
      };
    }

    // search for any related locations that is a theme-park - this tells us this entity is within this park!
    //  set this so we can correctly build our entity heirarchy
    // skip if our type is actuall &quot;theme-park&quot;, as parks aren&apos;t parented to themselves
    if (
      parkTypes.indexOf(doc.type) &lt; 0 &amp;&amp;
      doc.relatedLocations &amp;&amp;
      doc.relatedLocations.length &gt; 0 &amp;&amp;
      doc.relatedLocations[0].ancestors
    ) {
      // try to find parkId (if it exists)
      const park = doc.relatedLocations[0].ancestors.find((x) =&gt; {
        return parkTypes.indexOf(x.type) &gt;= 0;
      });
      if (park) {
        entity._parkId = park.id;
      }
    }

    // tags
    if (doc.facets) {
      if (doc.facets.find((x) =&gt; x.id === &apos;expectant-mothers&apos;)) {
        entity.unsuitableForPregnantPeople = true;
      }
    }

    // TODO - rename so something park-agnostic?
    if (doc.fastPassPlus !== undefined) {
      entity.fastPass = !!doc.fastPassPlus;
    }

    // if we&apos;re not inside a park, parent ourselves to the *something*
    const nonParkParentPriority = [
      &apos;theme-park&apos;,
      &apos;water-park&apos;,
      &apos;Entertainment-Venue&apos;, // eg. Disney Springs
      &apos;destination&apos;,
    ];
    // look through list in order until we find an entity we can attach to
    let parentDoc;
    if (doc.relatedLocations &amp;&amp; doc.relatedLocations.length &gt; 0 &amp;&amp; doc.relatedLocations[0].ancestors) {
      for (let parentTypeIdx = 0; parentTypeIdx &lt; nonParkParentPriority.length; parentTypeIdx++) {
        const parentType = nonParkParentPriority[parentTypeIdx];
        parentDoc = doc.relatedLocations[0].ancestors.find((x) =&gt; {
          return x.type === parentType &amp;&amp; x.id !== doc.relatedLocations[0].id;
        });
        if (parentDoc) break;
      }

      if (parentDoc) {
        entity._parentId = parentDoc.id;
      }
    }

    return entity;
  }

  /**
   * Return entity document for this destination
   */
  async buildDestinationEntity() {
    const resortIndex = await this.db.getEntityIndex(this.resortId, {
      entityType: &apos;destination&apos;,
    });
    if (resortIndex.length === 0) return undefined;

    const doc = await this.db.get(resortIndex[0]._id);

    return {
      ...this.buildBaseEntityObject(doc),
      entityType: entityType.destination,
      slug: doc.name.replace(/[^a-zA-Z0-9]/g, &apos;&apos;).toLowerCase(),
    };
  }

  /**
   * Return all park entities for this resort
   */
  async buildParkEntities() {
    const parkData = (await Promise.all(this.parkIds.map(async (parkID) =&gt; {
      return this.db.getEntityOne(parkID);
    }))).filter((x) =&gt; !!x);

    const resort = await this.getDestinationEntity();

    return parkData.map((park) =&gt; {
      return {
        ...this.buildBaseEntityObject(park),
        entityType: entityType.park,
        // parks are parented to the resort
        _parentId: resort._id,
        slug: park.name.replace(/[^a-zA-Z0-9]/g, &apos;&apos;).toLowerCase(),
      };
    });
  }

  /**
   * @inheritdoc
   */
  async buildAttractionEntities() {
    const attractions = await this.db.find({
      type: &apos;Attraction&apos;,
      relatedLocations: {
        $elemMatch: {
          ancestors: {
            $elemMatch: {
              id: {
                $regex: this.destinationDocumentIDRegex,
              },
            },
          },
        },
      },
      // ignore any attractions with zero facets
      facets: {
        $exists: true,
      },
    });

    // filter out known bad names
    const ignoreAttractions = [
      /^Disney Park Pass$/,
      /Park Pass \- Afternoon$/,
      /Play Disney Parks/,
      /^Temporarily Unavailable Entertainment/,
    ];

    const entities = attractions.filter((attr) =&gt; {
      return !ignoreAttractions.find((x) =&gt; {
        return !!attr.name.match(x);
      });
    }).map((attraction) =&gt; {
      // turn into entity objects

      // TODO - add extra meta data to entity objects
      let type = attractionType.unknown;
      const hasFacet = (facet) =&gt; {
        if (!attraction?.facets) return false;
        return !!attraction.facets.find((x) =&gt; {
          return x.id === facet;
        });
      };

      // figure out ride type from available facets...
      if (
        hasFacet(&apos;slow-rides&apos;) ||
        hasFacet(&apos;small-drops&apos;) ||
        hasFacet(&apos;thrill-rides&apos;) ||
        hasFacet(&apos;spinning&apos;)
      ) {
        type = attractionType.ride;
      }

      return {
        ...this.buildBaseEntityObject(attraction),
        entityType: entityType.attraction,
        attractionType: type,
      };
    });

    return entities;
  }

  /**
   * @inheritdoc
   */
  async buildShowEntities() {
    // filter out known bad names
    const ignoreShows = [
      /^Temporarily Unavailable Entertainment/,
    ];

    return (await this.db.find({
      type: &apos;Entertainment&apos;,
      relatedLocations: {
        $elemMatch: {
          ancestors: {
            $elemMatch: {
              id: {
                $regex: this.destinationDocumentIDRegex,
              },
            },
          },
        },
      },
    })).filter((show) =&gt; {
      return !ignoreShows.find((x) =&gt; {
        return !!show.name.match(x);
      });
    }).map((re) =&gt; {
      return {
        ...this.buildBaseEntityObject(re),
        entityType: entityType.show,
      };
    });
  }

  /**
   * Fetch restaurant menu JSON
   * @param {string} id
   * @private
   */
  async _fetchRestaurantMenu(id) {
    // TODO - implement a separate menu service
    //  this API returns errors *a lot*, so we should fetch on a very gentle cycle and cache heavily
    return null;

    return this.cache.wrap(
      `menu_${id}`,
      async () =&gt; {
        try {
          const data = await this.http(
            &apos;GET&apos;,
            `https://dining-menu-svc.wdprapps.disney.com/diningMenuSvc/orchestration/menus/${id}`,
            null,
            {
              retries: 0,
            },
          );
          if (data &amp;&amp; data.body) {
            return data.body;
          }
        } catch (e) { }
        return null;
      },
      1000 * 60 * 60 * 6, // cache for 6 hours
    );
  }

  /**
   * Get the menu for a given resturant entity ID
   * @param {string} id
   */
  async getRestaurantMenu(id) {
    try {
      const menu = await this._fetchRestaurantMenu(id);
      if (!menu) return undefined;

      const menuData = menu.menus.map((menuGroup) =&gt; {
        if (!menuGroup.menuGroups) {
          return undefined;
        }

        const items = [];

        let groupPrice = null;

        // WDW menus are split into Entree,Desert etc. &quot;menuGroups&quot; - loop through them all and build them into a list
        menuGroup.menuGroups.forEach((group) =&gt; {
          // look for buffet pricings
          // extract characters and digits to find pricing categories
          const findBuffetPrices = /([^\/\(]+\d+\.\d+)/g;
          let match;
          while (match = findBuffetPrices.exec(group.names.PCLong)) {
            // split each buffet price into name and USD
            const nameAndPrice = /(.*)\s+(\d+\.\d+)/;
            const priceData = nameAndPrice.exec(match[1]);
            if (priceData) {
              if (groupPrice === null) {
                groupPrice = [];
              }

              // add each unique price name once
              const priceName = priceData[1].trim();
              if (groupPrice.findIndex((x) =&gt; x.name === priceName) &lt; 0) {
                groupPrice.push({
                  name: priceData[1].trim(),
                  USD: Number(priceData[2]) * 100,
                });
              }
            }
          }

          group.menuItems.forEach((dish) =&gt; {
            const newDish = {
              name: dish.names.PCLong || dish.names.MobileLong || dish.names.PCShort || dish.names.MobileShort || null,
              description: dish?.descriptions?.PCLong?.text ||
                dish?.descriptions?.MobileLong?.text ||
                dish?.descriptions?.MobileShort?.text ||
                null,
              group: group.menuGroupType,
              price: null,
            };

            if (dish?.prices?.PerServing?.withoutTax) {
              // standard per-serving prices
              newDish.price = [{
                USD: dish.prices.PerServing.withoutTax * 100,
              }];
            } else if (dish.prices) {
              // not per serving price
              newDish.price = Object.keys(dish.prices).map((x) =&gt; {
                return {
                  name: dish.prices[x].type,
                  USD: dish.prices[x].withoutTax * 100,
                };
              });
            }

            items.push(newDish);
          });
        });

        return {
          type: menuGroup.menuType,
          description: `${menuGroup.primaryCuisineType} - ${menuGroup.serviceStyle} - ${menuGroup.experienceType}`,
          items,
          price: groupPrice, // a menu can have a price (buffets etc.)
        };
      }).filter((x) =&gt; !!x);

      return menuData;
    } catch (e) {
      console.error(e);
    }
    return undefined;
  }

  /**
   * @inheritdoc
   */
  async buildRestaurantEntities() {
    const restaurants = (await this.db.find({
      type: &apos;restaurant&apos;,
      relatedLocations: {
        $elemMatch: {
          ancestors: {
            $elemMatch: {
              id: {
                $regex: this.destinationDocumentIDRegex,
              },
            },
          },
        },
      },
    })).filter((restaurant) =&gt; {
      // only include &quot;proper&quot; resturants
      //  avoid listing every coffee stand etc.

      // determine resturant type using available facets
      if (!restaurant.facets) return false;
      const tableService = restaurant.facets.find((x) =&gt; x.id === &apos;table-service&apos;);
      // some resturants are missing the &apos;table-service&apos; facet, but have other facets that are similar
      const tableReservations = restaurant.facets.find((x) =&gt; x.id === &apos;reservations-accepted&apos;);
      // TODO - also add quick service
      return !!tableService || !!tableReservations;
    }).map((re) =&gt; {
      // TODO - populate with any other interesting restaurant detail
      return {
        ...this.buildBaseEntityObject(re),
        entityType: entityType.restaurant,
        // list of available cuisines
        cuisines: re.facets.filter((x) =&gt; x.group === &apos;cuisine&apos;).map((x) =&gt; {
          return x.name;
        }),
      };
    });

    // fetch menus
    /* for (let i = 0; i &lt; restaurants.length; i++) {
      restaurants[i].menus = (await this.getRestaurantMenu(restaurants[i]._id)) || null;
    }*/

    return restaurants;
  }

  /**
   *
   * @param {array&lt;string&gt;} ids document IDs to get schedules for
   * @param {moment} date Moment date to get schedule data for
   * @return {array&lt;object&gt;} Array of objects containing _id and schedule
   */
  async _getSchedulesForDate(ids, date) {
    const dateCalendar = await this.db.getByChannel(
      `${this.config.resortShortcode}.calendar.1_0`,
      {
        &apos;id&apos;: date.format(&apos;DD-MM&apos;),
      },
    );

    if (dateCalendar.length === 0) {
      return [];
    }
    const calendar = dateCalendar[0];

    const hours = calendar.parkHours.filter((h) =&gt; {
      // filter for hours for any of our parks
      return ids.indexOf(h.facilityId) &gt;= 0 &amp;&amp;
        // that aren&apos;t closed hours (just ignore these)
        h.scheduleType !== &apos;Closed&apos; &amp;&amp;
        // ignore annual pass blockout data
        h.scheduleType.indexOf(&apos;blockout&apos;) &lt; 0;
    }).reduce((p, x) =&gt; {
      let hoursType = scheduleType.operating;

      switch (x.scheduleType) {
        case &apos;Operating&apos;:
          hoursType = scheduleType.operating;
          break;
        case &apos;Park Hopping&apos;:
          hoursType = scheduleType.informational;
          break;
        case &apos;Refurbishment&apos;:
          // return refurbishment hours as purely informational
          hoursType = scheduleType.informational;
          break;
        default:
          // default to a ticketed event
          hoursType = scheduleType.ticketed;
          break;
      }

      p[ids.indexOf(x.facilityId)].schedule.push({
        date: moment(x.startTime).tz(this.config.timezone).format(&apos;YYYY-MM-DD&apos;),
        openingTime: moment(x.startTime).tz(this.config.timezone).format(),
        closingTime: moment(x.endTime).tz(this.config.timezone).format(),
        type: hoursType,
        description: hoursType != scheduleType.operating ? x.scheduleType : undefined,
      });

      return p;
    }, ids.map((x) =&gt; {
      return {
        _id: x,
        schedule: [],
      };
    }));

    return hours;
  }

  /**
   * @inheritdoc
   */
  async buildEntityScheduleData() {
    // grab park IDs!
    const parks = await this.getParkEntities();
    const parkIds = parks.map((x) =&gt; {
      return x._id;
    });

    // grab schedules for our parks
    const daysToReturn = 150;
    const now = this.getTimeNowMoment();
    const endDate = now.clone().add(daysToReturn, &apos;day&apos;);
    const returnData = parkIds.map((x) =&gt; {
      return {
        _id: x,
        schedule: [],
      };
    });
    for (; now.isSameOrBefore(endDate, &apos;day&apos;); now.add(1, &apos;day&apos;)) {
      const dateData = await this._getSchedulesForDate(parkIds, now);
      dateData.forEach((entity) =&gt; {
        returnData[parkIds.indexOf(entity._id)].schedule.push(...entity.schedule);
      });
    }
    return returnData;
  }
};

/**
 * Walt Disney World Resort
 */
export class WaltDisneyWorldResort extends DisneyLiveResort {
  /**
   * @inheritdoc
   */
  constructor(options = {}) {
    options.name = options.name || &apos;Walt Disney World Resort&apos;;
    options.timezone = options.timezone || &apos;America/New_York&apos;;

    options.resortId = options.resortId || 80007798;
    options.resortShortcode = options.resortShortcode || &apos;wdw&apos;;

    options.parkIds = options.parkIds || [
      80007944, // Magic Kingdom
      80007838, // Epcot
      80007998, // Hollywood Studios
      80007823, // Animal Kingdom
      // water parks
      80007981, // Typhoon Lagoon
      80007834, // Blizzard Beach
    ];

    super(options);
  }
}

/**
 * Disneyland Resort
 */
export class DisneylandResort extends DisneyLiveResort {
  /**
   * @inheritdoc
   */
  constructor(options = {}) {
    options.name = options.name || &apos;Disneyland Resort&apos;;
    // TODO - calculate this from resort entity&apos;s location
    options.timezone = options.timezone || &apos;America/Los_Angeles&apos;;

    options.resortId = options.resortId || 80008297;
    options.resortShortcode = options.resortShortcode || &apos;dlr&apos;;

    options.parkIds = options.parkIds || [
      330339, // Disneyland Park
      336894, // California Adventure
    ];

    super(options);
  }
}

/**
 * Hong Kong Disneyland Resort
 */
export class HongKongDisneyland extends DisneyLiveResort {
  /**
   * @inheritdoc
   */
  constructor(options = {}) {
    options.name = options.name || &apos;HongKong Disneyland&apos;;
    // TODO - calculate this from resort entity&apos;s location
    options.timezone = options.timezone || &apos;Asia/Hong_Kong&apos;;

    options.resortId = options.resortId || &apos;hkdl&apos;;
    options.resortShortcode = options.resortShortcode || &apos;hkdl&apos;;

    options.parkIds = options.parkIds || [
      &apos;desHongKongDisneyland&apos;,
    ];

    super(options);
  }

  /**
   * HK stores menus as PDFs, this function does nothing (yet?)
   * @return {null}
   */
  async _fetchRestaurantMenu() {
    return null;
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
