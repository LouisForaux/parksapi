<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">lib/parks/wdw/wdwdb.js | parksapi</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ThemeParks/parksapi"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/configBase.js~ConfigBase.html">ConfigBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-get">get</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#cache">cache</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheBase.js~CacheBase.html">CacheBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheLevel.js~CacheLevel.html">CacheLevel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheMemory.js~CacheMemory.html">CacheMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheSqlite.js~CacheSqlite.html">CacheSqlite</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks">parks</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/park.js~Park.html">Park</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ParkConstants">ParkConstants</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-wdw">parks/wdw</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/wdw/waltdisneyworldbase.js~DisneyPark.html">DisneyPark</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/wdw/wdwdb.js~DisneyDB.html">DisneyDB</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getDatabase">getDatabase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEntityID">getEntityID</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/parks/wdw/wdwdb.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import PouchDB from &apos;pouchdb&apos;;
import ReplicationStream from &apos;pouchdb-replication-stream&apos;;
import sift from &apos;sift&apos;;

import {promises as fs, constants as fsConstants, createReadStream, createWriteStream} from &apos;fs&apos;;
import path from &apos;path&apos;;

import ConfigBase from &apos;../../configBase.js&apos;;

import expressPouchDB from &apos;express-pouchdb&apos;;

// pouchdb-replication-stream allows us to &quot;seed&quot; the database with an initial database dump
//  incredibly useful for the wdw db, which is pretty huge
PouchDB.plugin(ReplicationStream.plugin);
PouchDB.adapter(&apos;writableStream&apos;, ReplicationStream.adapters.writableStream);

/**
 * Return the entity ID of an object
 * @param {object} doc Entity Document
 * @return {string} Entity ID, or undefined if unavailable
 */
export function getEntityID(doc) {
  const docId = doc?.id || doc;

  const stack = docId.split(&apos;:&apos;);
  const lowestLevelEntity = stack[stack.length - 1];

  const parts = lowestLevelEntity.split(&apos;;&apos;);
  if (parts &lt;= 1) return undefined;

  return parts.find((p) =&gt; {
    // edge-case for some documents with no attraction attached (guessing test documents)
    if (p === &apos;Unassigned&apos;) return false;

    const keyval = p.split(&apos;=&apos;);
    return (keyval.length === 1);
  });
}

/**
 * Custom implementation of PouchDB for our WDW database sync
 */
class WDWPouchDB extends PouchDB {
  /**
   * Build our WDWPouchDB object (passes straight through to PouchDB())
   * @param  {...any} args
   */
  constructor(...args) {
    super(...args);

    // create our WDW indexes
    this._wdwIndex = {}; // general entityID -&gt; docs index
    this._wdwFacilityStatusIndex = []; // facility status docs (ride times etc.)
    this._wdwChannelIndex = {}; // documents grouped by channel
  }
}

const delay = (time) =&gt; {
  return new Promise((resolve) =&gt; {
    setTimeout(resolve, time);
  });
};

const ancestorIndexes = [
  {
    key: &apos;ancestorLandId&apos;,
    index: &apos;land_id&apos;,
  },
  {
    key: &apos;ancestorResortId&apos;,
    index: &apos;resort_id&apos;,
  },
  {
    key: &apos;ancestorResortAreaId&apos;,
    index: &apos;resort_area_id&apos;,
  },
  {
    key: &apos;ancestorThemeParkId&apos;,
    index: &apos;park_id&apos;,
  },
];

// helper function that extracts the entity ID, type, and any other meta-data from a document using it&apos;s .id
const extractEntityKeys = (doc) =&gt; {
  if (!doc || !doc.id) return undefined;

  // some IDs are stacked using :
  const stack = doc.id.split(&apos;:&apos;);
  const lowestLevelEntity = stack[stack.length - 1];

  const parts = lowestLevelEntity.split(&apos;;&apos;);
  if (parts &lt;= 1) return undefined;

  // some documents can have different parents, they&apos;re the same, but different path to get there
  const parentStackEl = stack.length &gt; 1 ? stack[stack.length - 2] : undefined;
  const parent = parentStackEl ? extractEntityKeys({id: parentStackEl}).id : undefined;

  const ret = {
    parent,
  };

  parts.forEach((p) =&gt; {
    const keyval = p.split(&apos;=&apos;);
    if (keyval.length === 1) {
      ret.id = keyval[0];
    } else {
      ret[keyval[0]] = keyval[1];
    }
  });

  // if this document is in a &quot;facilitystatus&quot; channel, add an extra tag
  //  this is so we don&apos;t collide with the actaul document for this attraction
  //  but also so we can filter it easier later
  const channel = doc.channels?.length ? doc.channels[0] : undefined;
  if (channel &amp;&amp; channel.indexOf(&apos;facilitystatus&apos;) &gt;= 0) {
    ret.facilityStatus = true;
  }

  // include channel in our index
  ret.channel = channel;

  // add any ancestor data to our index (that we a) care about and b) can find) - see ancestorIndexes
  ancestorIndexes.forEach((ancestorIndex) =&gt; {
    if (doc[ancestorIndex.key]) {
      const ancestorID = getEntityID(doc[ancestorIndex.key]);
      if (ancestorID) {
        ret[ancestorIndex.index] = ancestorID;
      }
    }
  });

  return ret;
};

// figure out a document&apos;s intended language
const extractChannelLanguage = (doc) =&gt; {
  // pull channel from doc
  const channel = doc.channels?.length ? doc.channels[0] : undefined;
  if (!channel) return undefined;

  // extract language from the end of the channel name
  let lang = channel.slice(channel.lastIndexOf(&apos;.&apos;) + 1);

  // channels missing any locale are assumed English International (they are using &quot;1_0&quot; or similar)
  if (lang.indexOf(&apos;1&apos;) === 0) {
    lang = &apos;en_intl&apos;;
  }

  return lang;
};

/**
 * @private
 * @param {*} doc
 */
function IndexDocument(doc) {
  const entity = extractEntityKeys(doc);
  if (entity &amp;&amp; entity.id &amp;&amp; entity.entityType) {
    const id = entity.id;
    if (!this._wdwIndex[id]) {
      this._wdwIndex[id] = [];
    }

    const newIndexEntry = {
      ...entity,
      language: extractChannelLanguage(doc),
      _id: doc._id,
    };

    // special-case, index all facility status documents in another index
    if (newIndexEntry.facilityStatus) {
      const docExists = this._wdwFacilityStatusIndex.findIndex((x) =&gt; {
        return x.id === newIndexEntry.id;
      });
      if (docExists &gt;= 0) {
        this._wdwFacilityStatusIndex[docExists] = newIndexEntry;
      } else {
        this._wdwFacilityStatusIndex.push(newIndexEntry);
      }
    }

    // index all documnets based on channel
    const channel = doc.channels?.length ? doc.channels[0] : undefined;
    if (channel) {
      if (!this._wdwChannelIndex[channel]) {
        this._wdwChannelIndex[channel] = [];
      }

      this._wdwChannelIndex[channel].push(newIndexEntry);
    }

    const newIndexKeys = Object.keys(newIndexEntry);

    const findExisting = this._wdwIndex[id].findIndex((x) =&gt; {
      // if # keys are different, not a match
      if (Object.keys(x).length !== newIndexKeys.length) return false;

      // look for any mismatches between the keys
      const findMismatch = newIndexKeys.find((key) =&gt; {
        // _id is supposed to be different, so ignore it regardless of if it matches or not
        if (key === &apos;_id&apos;) return false;
        return (newIndexEntry[key] !== x[key]);
      });
      return !findMismatch;
    });

    if (findExisting &lt; 0) {
      // entry doesn&apos;t exist, add to our list
      this._wdwIndex[id].push(newIndexEntry);
    } else {
      // replace existing entry that matches all the same properties
      this._wdwIndex[id][findExisting] = newIndexEntry;
    }
  }
};

const pouchBulkDocs = PouchDB.prototype.bulkDocs;

/**
 * @private
 * @param  {...any} args
 * @return {*}
 */
function WDWIndexPluginBulkDocs(...args) {
  const body = args[0];
  const docs = Array.isArray(body) ? body : body.docs;

  docs.forEach((doc) =&gt; {
    if (!doc._deleted) {
      // doc not deleted, index it!
      IndexDocument.call(this, doc);
    } else {
      // remove from any existing index we have for this document
      Object.keys(this._wdwIndex).forEach((id) =&gt; {
        const entry = this._wdwIndex[id];
        const containsID = entry.findIndex((x) =&gt; x._id === doc._id);
        if (containsID &gt;= 0) {
          entry.splice(containsID, 1);
        }
      });

      // clear out the channel index on document deletion
      const channel = doc.channels?.length ? doc.channels[0] : undefined;
      if (channel) {
        const channelIndex = this._wdwChannelIndex;
        if (channelIndex) {
          const docIndex = channelIndex.findIndex((x) =&gt; x._id === doc._id);
          if (docIndex &gt;= 0) {
            channelIndex.splice(docIndex, 1);
          }
        }
      }
    }
  });

  // All documents check out. Pass them to PouchDB.
  return pouchBulkDocs.call(this, ...args);
}

const WDWIndexPlugin = {
  bulkDocs: WDWIndexPluginBulkDocs,
};

// plugin to our localdb so we can index entity IDs to the correct document
WDWPouchDB.plugin(WDWIndexPlugin);

/**
 * Live Database object for Disney parks using couchbase databases
 * Will syncronise databae locally before accessing, allowing fast queries
 * @class
 */
export class DisneyDB extends ConfigBase {
  /**
     * Create a new DisneyDB object
     * @param {*} options
     */
  constructor(options = {}) {
    if (!options.dbName) {
      options.dbName = &apos;wdw&apos;;
    }

    // env variables can override with
    //  env.WDWDB_HOST, env.WDWDB_USERNAME, env.WDWDB_PASSWORD etc.
    if (!options.configPrefixes) {
      options.configPrefixes = [&apos;wdwdb&apos;];
    }

    options.host = options.host || &apos;&apos;;
    options.username = options.username || &apos;&apos;;
    options.password = options.password || &apos;&apos;;
    // TODO - get latest useragent for app
    options.useragent = options.useragent || &apos;CouchbaseLite/1.3 (1.4.1/8a21c5927a273a038fb3b66ec29c86425e871b11)&apos;;

    // skip replication altogether (assumes skip sync, skip dump etc.)
    //  use this to connect directly to a live database (ideally a fully autonomous proxy of the real database)
    options.directConnection = options.directConnection || false;

    options.skipSync = options.directConnection || (options.skipSync || false);
    options.skipDump = options.directConnection || (options.skipDump || false);

    // how often to take database checkpoints (default 15 minutes)
    options.checkpointTime = options.checkpointTime || 1000 * 60 * 15;

    super(options);

    // if we&apos;re using a direct connection, skip setting up the local/remote setup
    if (this.config.directConnection) {
      this.localDB = new WDWPouchDB(this.config.host);

      // asume our remote database is fully synced
      this.synced = true;
    } else {
      // create our database objects
      this.localDB = new WDWPouchDB(`localdb/${this.config.dbName}`, {
        auto_compaction: true,
      });
      this.remoteDB = new PouchDB(this.config.host, {
        auth: {
          username: this.config.username,
          password: this.config.password,
        },
        skip_setup: true,
        // override user-agent header when syncing remote database
        fetch: (url, opts) =&gt; {
          opts.headers.set(&apos;User-Agent&apos;, this.config.useragent);
          return PouchDB.fetch(url, opts);
        },
      });
      this.synced = false;

      this.initPromiseSync = null;

      // start the database disk scheduler
      this._scheduleDBDump();

      // optionally hook into an Express server for a GUI
      if (this.config.http) {
        this.config.http.use(&apos;/db&apos;, expressPouchDB(PouchDB));
      }
    }
  }

  /**
   * Initialise the live database, returns once finished an initial sync
   */
  async init() {
    if (this.synced) {
      return;
    }

    if (this.initPromiseSync) return this.initPromiseSync;

    // first, syncronise our database before we start rolling updates
    this.initPromiseSync = this._loadAndInit();
    // keep the Promise as a variable so we can keep returning it for any additional init() calls
    await this.initPromiseSync;
    this.initPromiseSync = null;

    console.log(`Database ${this.config.dbName} finished setup!`);

    this.synced = true;

    if (!this.config.skipSync &amp;&amp; this.remoteDB) {
      // start rolling replicate to keep our local database in-sync
      PouchDB.replicate(this.remoteDB, this.localDB, {
        live: true,
        retry: true,
      });
    }
  }

  /**
   * Internal function
   * Loads and performs an initial sync on the database
   * @private
   */
  async _loadAndInit() {
    // first, try and restore from disk
    await this.load();

    // optionally skip replicating with remote (for local fast testing)
    if (this.config.skipSync || !this.remoteDB) {
      return;
    }

    // then perform an initial replication from remote to local
    console.log(&apos;Performing initial replication...&apos;);
    return await PouchDB.replicate(this.remoteDB, this.localDB, {
      batch_size: 500,
    });
  }

  /**
   * Get the filename we use for saving backups of the database to disk
   * Used for creating simple &quot;snapshots&quot; to reduce initial sync times
   * @param {string} [postfix] Optional postfix for the filename
   * @return{string}
   */
  getDumpFilename(postfix = &apos;&apos;) {
    return path.join(&apos;localdb&apos;, `${this.config.dbName}${postfix}.db`);
  }

  /**
   * Restore a database backup from disk
   * Perform this after running &quot;dump()&quot; on a previous synced database
   * This will help to reduce the initial sync time for large databases
   */
  async load() {
    const dumpPath = this.getDumpFilename();

    // if our database dump doesn&apos;t exist, then early out and we&apos;ll do a normal sync
    try {
      await fs.access(dumpPath, fsConstants.F_OK);
    } catch (error) {
      return;
    }

    console.log(&apos;Restoring database from disk...&apos;);

    // otherwise, load up our database from disk
    const ws = createReadStream(dumpPath);
    return this.localDB.load(ws, {
      batch_size: 500,
    });
  }

  /**
   * Dump this live database to disk
   * This will be used to &quot;seed&quot; the database to speed up syncs for future runs
   */
  async dump() {
    if (this.databaseDumpPendingPromise) {
      return this.databaseDumpPendingPromise;
    }

    // can optionally skip ever storing database to disk
    if (this.config.skipDump) {
      return;
    }

    console.log(&apos;Dumping database to disk...&apos;);

    const dumpPath = this.getDumpFilename();
    const dumpPathNew = this.getDumpFilename(&apos;_new&apos;);

    // dump database to our new location
    const ws = createWriteStream(dumpPathNew);
    this.databaseDumpPendingPromise = this.localDB.dump(ws, {
      batch_size: 500,
    });
    // save Promise so multiple &quot;dump()&quot; calls can stack cleanly
    await this.databaseDumpPendingPromise;
    this.databaseDumpPendingPromise = null;

    // rename new database dump to our final intended location
    return fs.rename(dumpPathNew, dumpPath);
  }

  /**
   * Begin a database dump loop
   * This will dump the database to disk every 15 minutes (override with options.checkpointTime)
   *  to speed up initial syncs
   * @private
   */
  async _scheduleDBDump() {
    // make sure database is initialised before writing anything to disk
    await this.init();
    await this.dump();

    // schedule another database disk write
    await delay(this.config.checkpointTime);
    process.nextTick(this._scheduleDBDump.bind(this));
  }

  /**
   * Get a document from this live database
   * Will wait until database is syncronised before returning
   * See PouchDB.get(...) for options
   */
  async get(...args) {
    await this.init();
    return await this.localDB.get.apply(this, args);
  }

  /**
   * Get an array of documents from an array of _id
   * @param {array&lt;string&gt;} ids
   */
  async getDocsById(ids) {
    await this.init();

    return (await Promise.all(ids.map((id) =&gt; {
      // fetch each document using our local DB
      return this.localDB.get(id);
    }))).filter((doc) =&gt; {
      // filter our any docs that failed to be fetched (they have been deleted etc.)
      return doc !== undefined;
    });
  }

  /**
   * Find search index entries by ID
   * @param {string} id
   * @param {object} [filter]
   * @return {array&lt;object&gt;}
   */
  async findIndexEntity(id, filter = {}) {
    await this.init();

    const indexEntry = this.localDB._wdwIndex[id];
    if (!indexEntry) return [];

    // filter entries by supplied filter options before resolving
    return indexEntry.filter(sift(filter));
  }

  /**
   * Search for an entity in the WDW database
   * @param {string} id Entity ID
   * @param {object} [filter] Filter index by field
   */
  async findEntity(id, filter = {}) {
    const entities = await this.findIndexEntity(id, filter);

    // resolve each index entry to our full documents
    return this.getDocsById(entities.map((entry) =&gt; {
      return entry._id;
    }));
  }

  /**
   * Search for an entity in the WDW database
   * Attempts to return the &quot;best candidate&quot; single document that matches the incoming ID
   * @param {string} id Entity ID
   * @param {object} [filter] Optional index filter
   */
  async findOne(id, filter = {}) {
    const entities = await this.findIndexEntity(id, filter);
    if (entities.length === 0) return undefined;

    // filter to find the best document of the ones available
    //  prioritise language en_intl
    const enIntl = entities.find((doc) =&gt; {
      return doc.language === &apos;en_intl&apos; &amp;&amp; !doc.facilityStatus; // don&apos;t include facilityStatus docs by-default
    });
    if (enIntl) {
      return await this.get(enIntl._id);
    }

    //  2nd priority: en_US
    const enUS = entities.find((doc) =&gt; {
      return doc.language === &apos;en_us&apos; &amp;&amp; !doc.facilityStatus; // don&apos;t include facilityStatus docs by-default
    });
    if (enUS) {
      return await this.get(enUS._id);
    }

    // otherwise just return the first entry in out list
    return await this.get(entities[0]._id);
  }

  /**
   * Get the live facility status for a given entity ID
   * @param {string} id Entity ID
   */
  async findFacilityStatus(id) {
    await this.init();

    // look up entity ID in our facility status index
    const indexEntity = this.localDB._wdwFacilityStatusIndex.find((x) =&gt; {
      return x.id === id;
    });
    if (!indexEntity) return undefined;

    return await this.get(indexEntity._id);
  }

  /**
   * Find all documents by channel
   * eg. &apos;wdw.facilitystatus.1_0&apos; to get all WDW facility status documents
   * @param {string} channel Channel ID
   * @param {object} [filter] Optional document index filter
   */
  async findByChannel(channel, filter = {}) {
    await this.init();

    const channelIndex = this.localDB._wdwChannelIndex[channel];
    if (!channelIndex) {
      return [];
    }

    // return resolved documents for the channel
    return this.getDocsById(channelIndex.filter(sift(filter)).map((entry) =&gt; {
      return entry._id;
    }));
  }

  /**
   * Return all documents in the database that match the given filter
   * @param {object} [filter]
   */
  async find(filter = {}) {
    await this.init();

    const docs = await this.localDB.allDocs({
      include_docs: true,
    });

    return docs.rows.map((row) =&gt; row.doc).filter(sift(filter));
  }

  /**
   * Subscribe to all database changes with an optional mongo-style filter
   * @param {object} [filter]
   * @param {function} callback
   */
  subscribeToChanges(filter, callback) {
    if (typeof filter === &apos;function&apos;) {
      // if no filter passed in, call ourselves with an empty set
      this.subscribeToChanges({}, callback);
    } else {
      // listen to changes from now onwards, passing in our filter function
      this.localDB.changes({
        since: &apos;now&apos;,
        live: true,
        include_docs: true,
        filter: sift(filter),
      }).on(&apos;change&apos;, (change) =&gt; {
        callback(change.doc);
      });
    }
  }

  /**
   * Subscribe to all changes to a channel
   * @param {string} channel
   * @param {function} callback
   */
  subscribeToChannel(channel, callback) {
    // only return documents that contain the supplied channel
    this.subscribeToChanges({
      channels: {
        $elemMatch: channel,
      },
    }, callback);
  }
}

export default DisneyDB;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
