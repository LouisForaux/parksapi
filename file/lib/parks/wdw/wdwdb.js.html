<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">lib/parks/wdw/wdwdb.js | parksapi</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ThemeParks/parksapi"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/configBase.js~ConfigBase.html">ConfigBase</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#cache">cache</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheBase.js~CacheBase.html">CacheBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheMemory.js~CacheMemory.html">CacheMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/cache/cacheSqlite.js~CacheSqlite.html">CacheSqlite</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks">parks</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/park.js~Park.html">Park</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-constants">constants</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parks-wdw">parks/wdw</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/parks/wdw/wdwdb.js~DisneyLiveDB.html">DisneyLiveDB</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/parks/wdw/wdwdb.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import PouchDB from &apos;pouchdb&apos;;
import ReplicationStream from &apos;pouchdb-replication-stream&apos;;

import {promises as fs, constants as fsConstants, createReadStream, createWriteStream} from &apos;fs&apos;;
import path from &apos;path&apos;;

import ConfigBase from &apos;../../configBase.js&apos;;

// pouchdb-replication-stream allows us to &quot;seed&quot; the database with an initial database dump
//  incredibly useful for the wdw db, which is pretty huge
PouchDB.plugin(ReplicationStream.plugin);
PouchDB.adapter(&apos;writableStream&apos;, ReplicationStream.adapters.writableStream);

const delay = (time) =&gt; {
  return new Promise((resolve) =&gt; {
    setTimeout(resolve, time);
  });
};

/**
 * Live Database object for Disney parks using couchbase databases
 * Will syncronise databae locally before accessing, allowing fast queries
 * @class
 */
export default class DisneyLiveDB extends ConfigBase {
  /**
     * Create a new DisneyLiveDB object
     * @param {*} options
     */
  constructor(options = {}) {
    if (!options.dbName) {
      options.dbName = &apos;wdw&apos;;
    }

    // env variables can override with
    //  env.WDWDB_HOST, env.WDWDB_USERNAME, env.WDWDB_PASSWORD etc.
    if (!options.configPrefixes) {
      options.configPrefixes = [&apos;wdwdb&apos;];
    }

    options.host = options.host || &apos;&apos;;
    options.username = options.username || &apos;&apos;;
    options.password = options.password || &apos;&apos;;
    // TODO - get latest useragent for app
    options.useragent = options.useragent || &apos;CouchbaseLite/1.3 (1.4.1/8a21c5927a273a038fb3b66ec29c86425e871b11)&apos;;

    // how often to take database checkpoints (default 15 minutes)
    options.checkpointTime = options.checkpointTime || 1000 * 60 * 15;

    super(options);

    // create our database objects
    this.localDB = new PouchDB(`localdb/${this.config.dbName}`);
    this.remoteDB = new PouchDB(this.config.host, {
      auth: {
        username: this.config.username,
        password: this.config.password,
      },
      // override user-agent header when syncing remote database
      fetch: (url, opts) =&gt; {
        opts.headers.set(&apos;User-Agent&apos;, this.config.useragent);
        return PouchDB.fetch(url, opts);
      },
    });

    this.synced = false;

    this.initPromiseSync = null;

    // start the database disk scheduler
    this._scheduleDBDump();
  }

  /**
   * Initialise the live database, returns once finished an initial sync
   */
  async init() {
    if (this.synced) {
      return;
    }

    if (this.initPromiseSync) return this.initPromiseSync;

    // first, syncronise our database before we start rolling updates
    this.initPromiseSync = this._loadAndInit();
    // keep the Promise as a variable so we can keep returning it for any additional init() calls
    await this.initPromiseSync;
    this.initPromiseSync = null;

    console.log(`Database ${this.config.dbName} finished setup!`);

    this.synced = true;

    // start rolling replicate to keep our local database in-sync
    PouchDB.replicate(this.remoteDB, this.localDB, {
      live: true,
      retry: true,
    });
  }

  /**
   * Internal function
   * Loads and performs an initial sync on the database
   * @private
   */
  async _loadAndInit() {
    // first, try and restore from disk
    await this.load();

    // then perform an initial replication from remote to local
    console.log(&apos;Performing initial replication...&apos;);
    await PouchDB.replicate(this.remoteDB, this.localDB, {
      batch_size: 500,
    });

    // then dump our initial state to disk
    return await this.dump();
  }

  /**
   * Get the filename we use for saving backups of the database to disk
   * Used for creating simple &quot;snapshots&quot; to reduce initial sync times
   * @param {string} [postfix] Optional postfix for the filename
   * @return{string}
   */
  getDumpFilename(postfix=&apos;&apos;) {
    return path.join(&apos;localdb&apos;, `${this.config.dbName}${postfix}.db`);
  }

  /**
   * Restore a database backup from disk
   * Perform this after running &quot;dump()&quot; on a previous synced database
   * This will help to reduce the initial sync time for large databases
   */
  async load() {
    const dumpPath = this.getDumpFilename();

    // if our database dump doesn&apos;t exist, then early out and we&apos;ll do a normal sync
    try {
      await fs.access(dumpPath, fsConstants.F_OK);
    } catch (error) {
      return;
    }

    console.log(&apos;Restoring database from disk...&apos;);

    // otherwise, load up our database from disk
    const ws = createReadStream(dumpPath);
    return this.localDB.load(ws, {
      batch_size: 500,
    });
  }

  /**
   * Dump this live database to disk
   * This will be used to &quot;seed&quot; the database to speed up syncs for future runs
   */
  async dump() {
    if (this.databaseDumpPendingPromise) {
      return this.databaseDumpPendingPromise;
    }

    console.log(&apos;Dumping database to disk...&apos;);

    const dumpPath = this.getDumpFilename();
    const dumpPathNew = this.getDumpFilename(&apos;_new&apos;);

    // dump database to our new location
    const ws = createWriteStream(dumpPathNew);
    this.databaseDumpPendingPromise = this.localDB.dump(ws, {
      batch_size: 500,
    });
    // save Promise so multiple &quot;dump()&quot; calls can stack cleanly
    await this.databaseDumpPendingPromise;
    this.databaseDumpPendingPromise = null;

    // rename new database dump to our final intended location
    return fs.rename(dumpPathNew, dumpPath);
  }

  /**
   * Begin a database dump loop
   * This will dump the database to disk every 15 minutes (override with options.checkpointTime)
   *  to speed up initial syncs
   * @private
   */
  async _scheduleDBDump() {
    await delay(this.config.checkpointTime);

    // make sure database is initialised before writing anything to disk
    await this.init();
    await this.dump();

    process.nextTick(this._scheduleDBDump.bind(this));
  }

  /**
   * Get a document from this live database
   * Will wait until database is syncronised before returning
   * See PouchDB.get(...) for options
   */
  async get(...args) {
    await this.init();
    return await this.localDB.get.apply(this, args);
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
