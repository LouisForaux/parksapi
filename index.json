[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "lib/cache/cacheBase.js",
    "content": "/**\n * Our base Cache implementation\n * Extend this class with new implementations to create different cache types (in-memory, database, file system etc.)\n * @class\n */\nexport default class CacheBase {\n  /**\n     * @param {Object} options\n     * @param {boolean} [options.useMemoryCache=true] Use an in-memory layer on top of this cache\n     *  Avoid hitting databases too often\n     *  Not useful if using any distributed setup where memory will be out-of-sync between processes\n     * @param {(number|null)} [options.memoryCacheTimeout=null] Timeout for in-memory cache values\n     *  Default is null, which will use the incoming ttl values for each key\n     */\n  constructor(options = {\n    useMemoryCache: true,\n    memoryCacheTimeout: null,\n  }) {\n    this.memoryLayerEnabled = options.useMemoryCache;\n    this.memCache = {};\n\n    // stack up multiple cache wraps so they wait for a single request to finish\n    this.pendingCacheWraps = {};\n\n    this.failedCacheWraps = {};\n  }\n\n  /**\n     * Internal implementation of Get()\n     * @param {string} key Unique key name for this cache entry\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     * @abstract\n     * @private\n     */\n  async _get(key) {\n    throw new Error('Missing Implementation CacheBase::_get(key)');\n  }\n\n  /**\n     * Internal implementation of Set()\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} object Data to be set\n     * @abstract\n     * @private\n     */\n  async _set(key, object) {\n    throw new Error('Missing Implementation CacheBase::_set(key, object)');\n  }\n\n  /**\n     * Internal operation to delete a key\n     * @param {string} key Key name to delete\n     * @abstract\n     * @private\n     */\n  async _del(key) {\n    throw new Error('Missing Implementation CacheBase::_del(key)');\n  }\n\n  /**\n     * Internal implementation of getKeys()\n     * @param {string} prefix\n     * @abstract\n     * @private\n     */\n  async _getKeys(prefix) {\n    throw new Error('Missing Implementation CacheBase::_getKeys(prefix)');\n  }\n\n  /**\n     * Get a cached object\n     * @param {string} key Unique key name for this cache entry\n     * @param {boolean} [getFullObject] Get the full cache entry, including expiry time, even if expired\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     */\n  async get(key, getFullObject = false) {\n    const now = +new Date();\n\n    // our optional in-memory cache goes first\n    if (this.memoryLayerEnabled) {\n      const cacheEntry = this.memCache[key];\n      if (cacheEntry !== undefined) {\n        if (getFullObject) {\n          return cacheEntry;\n        }\n\n        if (cacheEntry.expires >= now) {\n          return cacheEntry.value;\n        }\n      }\n    }\n\n    // then use our internal cache if we haven't got the value stored locally\n    const cacheValue = await this._get(key);\n    if (cacheValue !== undefined) {\n      if (getFullObject) {\n        return cacheValue;\n      }\n\n      if (cacheValue.expires >= now) {\n        return cacheValue.value;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Set a key in our cache\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} value\n     * @param {(Function|number)} [ttl=3600000] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     *  Default 1 hour\n     */\n  async set(key, value, ttl = 3600000) {\n    // resolve our cache time\n    let cacheTime = ttl;\n    // if our cache time input is a function, resolve it and store the result (in milliseconds)\n    if (typeof cacheTime === 'function') {\n      cacheTime = await cacheTime();\n    }\n\n    // optionally keep an in-memory cache layer\n    if (this.memoryLayerEnabled) {\n      const memoryCacheTime = this.memoryCacheTimeout === null ?\n          cacheTime :\n          (Math.min(this.memoryCacheTimeout, cacheTime)\n          );\n      if (memoryCacheTime < 0) {\n        if (this.memCache[key]) {\n          delete this.memCache[key];\n        }\n      } else {\n        this.memCache[key] = {\n          value,\n          expires: (+new Date()) + memoryCacheTime,\n        };\n      }\n    }\n\n    if (cacheTime < 0) {\n      // delete key if ttl is negative\n      await this._del(key);\n    } else {\n      // call the private _Set implementation to actually set the key\n      this._set(key, {\n        value,\n        expires: (+new Date()) + cacheTime,\n      });\n    }\n  }\n\n  /**\n     * A helper \"wrap\" function that will return a cached value if present\n     *  This will call the supplied function to fetch it if the value isn't present in the cache\n     * @param {string} key Unique key name for this cache entry\n     * @param {function} fn Fetch function that will be called if the cache entry is not present\n     * @param {(function|number)} [ttl] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     */\n  async wrap(key, fn, ttl) {\n    // if another system is already wrapping this key, return it's pending Promise\n    if (this.pendingCacheWraps[key] !== undefined) {\n      return this.pendingCacheWraps[key];\n    }\n\n    // wrap all await calls in another Promise that we store\n    //  this allows multiple calls to Wrap to stack up, and they all get the same result\n    this.pendingCacheWraps[key] = new Promise(async (resolve) => {\n      // try and fetch the cached value\n      const cachedValue = await this.get(key, true);\n\n      // if not in our cache, call the supplied fetcher function\n      if (cachedValue !== undefined) {\n        // check timestamp to see if value is still valid\n        const now = +new Date();\n        if (cachedValue.expires > now) {\n          // it is! return it!\n          return resolve(cachedValue.value);\n        }\n        // it isn't! fall through and run our wrap function to get new data\n      }\n\n      let error = null;\n      try {\n        const newValue = await fn();\n\n        // set the new value in our cache\n        this.failedCacheWraps[key] = 0;\n        await this.set(key, newValue, ttl);\n        return resolve(newValue);\n      } catch (e) {\n        // store in case we want to throw this later\n        error = e;\n        console.error(`Error caching value ${key}`, e);\n      }\n\n      if (this.failedCacheWraps[key] === undefined) {\n        this.failedCacheWraps[key] = 0;\n      }\n      this.failedCacheWraps[key]++;\n\n      // failed! store old data briefly, then return old data back\n      await this.set(key, cachedValue?.value, 1000 * 30); // try again in 30 seconds\n      if (this.failedCacheWraps[key] > 5) {\n        // report after multiple failures\n        if (error !== null) {\n          // throw the actual error if we had one\n          throw error;\n        }\n        throw new Error(`Failed to resolve wrap function for cache key ${key}`);\n      }\n      return resolve(cachedValue?.value);\n    });\n    const cachedValue = await this.pendingCacheWraps[key];\n    this.pendingCacheWraps[key] = undefined;\n\n    // return the fetched or calculated value\n    return cachedValue;\n  }\n\n  /**\n   * Get an array of all the cached keys matching the supplied prefix\n   * @param {string} [prefix='']\n   * @return {array<string>}\n   */\n  async getKeys(prefix = '') {\n    return this._getKeys(prefix);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheBase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "CacheBase",
    "memberof": "lib/cache/cacheBase.js",
    "static": true,
    "longname": "lib/cache/cacheBase.js~CacheBase",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache/cacheBase.js",
    "importStyle": "CacheBase",
    "description": "Our base Cache implementation<br />Extend this class with new implementations to create different cache types (in-memory, database, file system etc.)",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.useMemoryCache",
        "description": "Use an in-memory layer on top of this cache\n Avoid hitting databases too often\n Not useful if using any distributed setup where memory will be out-of-sync between processes"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "null"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options.memoryCacheTimeout",
        "description": "Timeout for in-memory cache values\n Default is null, which will use the incoming ttl values for each key"
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "memoryLayerEnabled",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#memoryLayerEnabled",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "memCache",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#memCache",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "pendingCacheWraps",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#pendingCacheWraps",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "failedCacheWraps",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#failedCacheWraps",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_get",
    "access": "private",
    "description": "Internal implementation of Get()",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    },
    "abstract": true
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_set",
    "access": "private",
    "description": "Internal implementation of Set()",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": "Data to be set"
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "_del",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_del",
    "access": "private",
    "description": "Internal operation to delete a key",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Key name to delete"
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_getKeys",
    "access": "private",
    "description": "Internal implementation of getKeys()",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "prefix",
        "description": ""
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "get",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#get",
    "access": "public",
    "description": "Get a cached object",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "getFullObject",
        "description": "Get the full cache entry, including expiry time, even if expired"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "set",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#set",
    "access": "public",
    "description": "Set a key in our cache",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3600000",
        "defaultRaw": 3600000,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number\n Default 1 hour"
      }
    ],
    "return": null
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "wrap",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#wrap",
    "access": "public",
    "description": "A helper \"wrap\" function that will return a cached value if present<br /> This will call the supplied function to fetch it if the value isn't present in the cache",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "Fetch function that will be called if the cache entry is not present"
      },
      {
        "nullable": null,
        "types": [
          "function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "getKeys",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#getKeys",
    "access": "public",
    "description": "Get an array of all the cached keys matching the supplied prefix",
    "lineNumber": 228,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "prefix",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 63,
    "kind": "file",
    "name": "lib/cache/cacheLevel.js",
    "content": "import CacheBase from './cacheBase.js';\nimport level from 'level';\nimport path from 'path';\n\n/**\n * A cache implementation using LevelDown\n * @extends CacheBase\n * @class\n */\nexport default class CacheLevel extends CacheBase {\n  /**\n   * Create new Memory cache object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.useMemoryCache = false;\n\n    super(options);\n\n    // setup our Level database\n    this.db = level(path.join(process.cwd(), 'db.cache'));\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _get(key) {\n    try {\n      const cacheEntry = await this.db.get(key);\n      if (cacheEntry !== undefined) {\n        return JSON.parse(cacheEntry);\n      }\n    } catch (err) {\n      // ignore NotFoundError, throw any other errors back up the chain\n      if (err.name !== 'NotFoundError') {\n        throw err;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _set(key, object) {\n    await this.db.put(key, JSON.stringify(object));\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _del(key) {\n    await this.db.del(key);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getKeys(prefix) {\n    return new Promise((resolve) => {\n      const keys = [];\n      const keyStream = this.db.createKeyStream();\n      keyStream.on('data', (data) => {\n        if (data.indexOf(prefix) === 0) {\n          keys.push(data);\n        }\n      });\n      keyStream.on('end', () => {\n        return resolve(keys);\n      });\n    });\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheLevel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 64,
    "kind": "class",
    "name": "CacheLevel",
    "memberof": "lib/cache/cacheLevel.js",
    "static": true,
    "longname": "lib/cache/cacheLevel.js~CacheLevel",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache/cacheLevel.js",
    "importStyle": "CacheLevel",
    "description": "A cache implementation using LevelDown",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 65,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#constructor",
    "access": "public",
    "description": "Create new Memory cache object",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 66,
    "kind": "member",
    "name": "db",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#db",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_get",
    "access": "private",
    "description": "",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_set",
    "access": "private",
    "description": "",
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "object",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "_del",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_del",
    "access": "private",
    "description": "",
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_getKeys",
    "access": "private",
    "description": "",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "file",
    "name": "lib/cache/cacheMemory.js",
    "content": "import CacheBase from './cacheBase.js';\n\n/**\n * A basic in-memory cache implementation\n * @extends CacheBase\n * @class\n */\nexport default class CacheMemory extends CacheBase {\n  /**\n   * Create new Memory cache object\n   * @param {object} options\n   */\n  constructor(options) {\n    // disable our internal memory cache, since this is exactly what this implementation is already doing\n    options.useMemoryCache = false;\n\n    super(options);\n\n    this.cache = {};\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _get(key) {\n    const cacheEntry = this.cache[key];\n    if (cacheEntry !== undefined) {\n      return cacheEntry;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _set(key, object) {\n    this.cache[key] = object;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _del(key) {\n    if (this.cache[key]) {\n      delete this.cache[key];\n    }\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getKeys(prefix) {\n    return Object.keys(this.cache).filter((key) => {\n      return key.indexOf(prefix) === 0;\n    });\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheMemory.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 72,
    "kind": "class",
    "name": "CacheMemory",
    "memberof": "lib/cache/cacheMemory.js",
    "static": true,
    "longname": "lib/cache/cacheMemory.js~CacheMemory",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache/cacheMemory.js",
    "importStyle": "CacheMemory",
    "description": "A basic in-memory cache implementation",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 73,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#constructor",
    "access": "public",
    "description": "Create new Memory cache object",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#cache",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_get",
    "access": "private",
    "description": "",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_set",
    "access": "private",
    "description": "",
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "object",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "_del",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_del",
    "access": "private",
    "description": "",
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_getKeys",
    "access": "private",
    "description": "",
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "file",
    "name": "lib/cache/scopedCache.js",
    "content": "import {getCache} from '../cache.js';\nimport {reusePromiseForever} from '../reusePromises.js';\n\n/**\n * A wrapper class for accessing the cache.\n * Prefixes a string before each key to avoid conflicts.\n */\nexport class ScopedCache {\n  /**\n   * Create a new ScopedCache object by passing in the key prefix descired\n   * @param {string} keyPrefix\n   * @param {number} [version] Cache version, bump this to invalidate existing cache entries for a scope\n   */\n  constructor(keyPrefix, version = 0) {\n    this.prefix = keyPrefix;\n    this.version = version;\n\n    this.cache = null;\n  }\n\n  /**\n   * Initialise the cache for this scope\n   */\n  async initCache() {\n    return await reusePromiseForever(this, this._initCache);\n  }\n\n  /**\n   * Internal cache initialisation\n   */\n  async _initCache() {\n    if (this.cache) {\n      return this.cache;\n    }\n\n    this.cache = await getCache();\n\n    // check and flush cache if version mismatch\n    const cacheVersion = await this.cache.get(this.generateScopedKey('%%version%%'));\n    if (cacheVersion !== undefined && cacheVersion != this.version) {\n      // find all cache entries with this scope, and remove them\n      const keys = await this.cache.getKeys(`${this.prefix}_`);\n\n      await Promise.allSettled(keys.map((key) => {\n        // set expire date to 1 millisecond ago (this basically deletes it)\n        return this.cache.setGlobal(key, {}, -1);\n      }));\n    }\n\n    // set our new cache version with a very very long ttl\n    await this.cache.set('%%version%%', this.generateScopedKey(this.version), Number.MAX_SAFE_INTEGER);\n    this._initCachePromise = null;\n\n    return this.cache;\n  }\n\n  /**\n   * Generate a scoped key by adding our prefix to the incoming key\n   * @param {string} inKey\n   * @return {string} Scoped key\n   */\n  generateScopedKey(inKey) {\n    return `${this.prefix}_${inKey}`;\n  }\n\n  /**\n     * Get a cached object\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     */\n  async get(key) {\n    return this.getGlobal(this.generateScopedKey(key));\n  }\n\n  /**\n     * Get a cached object from the global cache (skipping the scope prefix)\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     */\n  async getGlobal(key) {\n    const cache = await this.initCache();\n    return cache.get(key);\n  }\n\n  /**\n     * Set a key in our cache\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} value\n     * @param {(Function|number)} [ttl=3600000] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     *  Default 1 hour\n     */\n  async set(key, value, ttl = 3600000) {\n    return this.setGlobal(this.generateScopedKey(key), value, ttl);\n  }\n\n  /**\n     * Set a key in our global cache, skipping the scoped prefix\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} value\n     * @param {(Function|number)} [ttl=3600000] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     *  Default 1 hour\n     */\n  async setGlobal(key, value, ttl = 3600000) {\n    const cache = await this.initCache();\n    return cache.set(key, value, ttl);\n  }\n\n  /**\n     * A helper \"wrap\" function that will return a cached value if present\n     *  This will call the supplied function to fetch it if the value isn't present in the cache\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {function} fn Fetch function that will be called if the cache entry is not present\n     * @param {(function|number)} [ttl] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     */\n  async wrap(key, fn, ttl) {\n    return this.wrapGlobal(this.generateScopedKey(key), fn, ttl);\n  }\n\n  /**\n     * A helper \"wrap\" function that will return a cached value if present (in the global scope)\n     *  This will call the supplied function to fetch it if the value isn't present in the cache\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {function} fn Fetch function that will be called if the cache entry is not present\n     * @param {(function|number)} [ttl] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     */\n  async wrapGlobal(key, fn, ttl) {\n    const cache = await this.initCache();\n    return cache.wrap(key, fn, ttl);\n  }\n}\n\nexport default ScopedCache;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/scopedCache.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 80,
    "kind": "class",
    "name": "ScopedCache",
    "memberof": "lib/cache/scopedCache.js",
    "static": true,
    "longname": "lib/cache/scopedCache.js~ScopedCache",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache/scopedCache.js",
    "importStyle": "{ScopedCache}",
    "description": "A wrapper class for accessing the cache.<br />Prefixes a string before each key to avoid conflicts.",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 81,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#constructor",
    "access": "public",
    "description": "Create a new ScopedCache object by passing in the key prefix descired",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "keyPrefix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "version",
        "description": "Cache version, bump this to invalidate existing cache entries for a scope"
      }
    ]
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "prefix",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#prefix",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "version",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#version",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#cache",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "initCache",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#initCache",
    "access": "public",
    "description": "Initialise the cache for this scope",
    "lineNumber": 24,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "_initCache",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#_initCache",
    "access": "private",
    "description": "Internal cache initialisation",
    "lineNumber": 31,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "_initCachePromise",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#_initCachePromise",
    "access": "private",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "generateScopedKey",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#generateScopedKey",
    "access": "public",
    "description": "Generate a scoped key by adding our prefix to the incoming key",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inKey",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Scoped key"
    }
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "get",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#get",
    "access": "public",
    "description": "Get a cached object",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    }
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "getGlobal",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#getGlobal",
    "access": "public",
    "description": "Get a cached object from the global cache (skipping the scope prefix)",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    }
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "set",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#set",
    "access": "public",
    "description": "Set a key in our cache",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3600000",
        "defaultRaw": 3600000,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number\n Default 1 hour"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "setGlobal",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#setGlobal",
    "access": "public",
    "description": "Set a key in our global cache, skipping the scoped prefix",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3600000",
        "defaultRaw": 3600000,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number\n Default 1 hour"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "wrap",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#wrap",
    "access": "public",
    "description": "A helper \"wrap\" function that will return a cached value if present<br /> This will call the supplied function to fetch it if the value isn't present in the cache",
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "Fetch function that will be called if the cache entry is not present"
      },
      {
        "nullable": null,
        "types": [
          "function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "wrapGlobal",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#wrapGlobal",
    "access": "public",
    "description": "A helper \"wrap\" function that will return a cached value if present (in the global scope)<br /> This will call the supplied function to fetch it if the value isn't present in the cache",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "Fetch function that will be called if the cache entry is not present"
      },
      {
        "nullable": null,
        "types": [
          "function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "file",
    "name": "lib/cache.js",
    "content": "/**\n * Cache provider for this module.\n * Various cache types are available, we default to using \"leveldown\" via the Level library.\n */\n\nimport CacheLevel from './cache/cacheLevel.js';\n\n// our global cache instance\nlet CacheInstance = null;\n\n/**\n * Create a new Cache Instance.\n * This function should only be called once for the lifetime of the module.\n */\nasync function createCacheInstance() {\n  // TODO - accept configured caches through environment variables (or other?)\n  return new CacheLevel();\n}\n\n/**\n  * Get the configured Cache implementation\n  */\nexport async function getCache() {\n  if (CacheInstance === null) {\n    CacheInstance = await createCacheInstance();\n  }\n\n  return CacheInstance;\n}\n\nexport default {\n  getCache,\n};\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "name": "CacheInstance",
    "memberof": "lib/cache.js",
    "static": true,
    "longname": "lib/cache.js~CacheInstance",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/cache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 98,
    "kind": "function",
    "name": "createCacheInstance",
    "memberof": "lib/cache.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/cache.js~createCacheInstance",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/cache.js",
    "importStyle": null,
    "description": "Create a new Cache Instance.<br />This function should only be called once for the lifetime of the module.",
    "lineNumber": 15,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 99,
    "kind": "function",
    "name": "getCache",
    "memberof": "lib/cache.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/cache.js~getCache",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache.js",
    "importStyle": "{getCache}",
    "description": "Get the configured Cache implementation",
    "lineNumber": 23,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "file",
    "name": "lib/configBase.js",
    "content": "// load any environment variables from .env (if it exists)\nimport DotEnv from 'dotenv';\nDotEnv.config();\n\nimport EventEmitter from 'events';\n\n/**\n * Combine given options with environment variables\n * @param {object} options Incoming options\n * @return {object} Processed configuration options\n */\nexport function parseConfig(options = {}) {\n  const configKeys = Object.keys(options);\n\n  const config = {};\n\n  options.configPrefixes = ['THEMEPARKS'].concat(\n      options.configPrefixes || [],\n  );\n\n  // build this.config object with our settings\n  configKeys.forEach((key) => {\n    // default prefixes are either \"classname_\" or \"THEMEPARKS_\"\n    //  classes can add more with configPrefixes\n    options.configPrefixes.forEach((prefix) => {\n      const configEnvName = `${prefix}_${key}`.toUpperCase();\n\n      if (process.env[configEnvName]) {\n        // console.log(`Using env variable ${configEnvName}`);\n        config[key] = process.env[configEnvName];\n        // console.log(` ${key}(env.${configEnvName})=${config[key]}`);\n      }\n    });\n\n    if (config[key] === undefined) {\n      config[key] = options[key];\n    } else {\n      // convert env variable to number if the base default is a number\n      if (typeof config[key] === 'number') {\n        config[key] = Number(config[key]);\n      } else if (typeof config[key] === 'boolean') {\n        // convert any boolean configs too\n        config[key] = (config[key] === 'true');\n      }\n    }\n  });\n\n  return config;\n}\n\n/**\n * Base Config Object\n * Supports classes with a single argument \"options\"\n * These will be sorted into a member called \"this.config\" containing all the same keys\n *\n * Crucially, these can also be overriden through environment variables\n * For example, for a config option \"timeout\" for class Database, this could be overriden through either:\n *   env.THEMEPARKS_TIMEOUT (using a \"global module name\")\n *   env.DATABASE_TIMEOUT (using the class name)\n *\n * Classes can also add additional prefixes to the supported environment variables through:\n *   new ClassInstance({configPrefixes: ['myCustomPrefix']});\n * Which would also allow env.MYCUSTOMPREFIX_TIMEOUT to be used\n *\n * Note that a default value must be supplied for the environment variable to be processed\n * If the default value is a number, the environment variable will be cast to a number as well\n * @class\n */\nexport class ConfigBase extends EventEmitter {\n  /**\n   * A base class that can be configured through environment variables\n   * @param {object} options Config for instantiating this object\n   */\n  constructor(options = {}) {\n    super();\n\n    options.configPrefixes = [this.constructor.name].concat(\n        options.configPrefixes || [],\n    );\n\n    this.config = parseConfig(options || {});\n  }\n}\n\nexport default ConfigBase;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/configBase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 101,
    "kind": "function",
    "name": "parseConfig",
    "memberof": "lib/configBase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/configBase.js~parseConfig",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/configBase.js",
    "importStyle": "{parseConfig}",
    "description": "Combine given options with environment variables",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Incoming options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Processed configuration options"
    }
  },
  {
    "__docId__": 102,
    "kind": "class",
    "name": "ConfigBase",
    "memberof": "lib/configBase.js",
    "static": true,
    "longname": "lib/configBase.js~ConfigBase",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/configBase.js",
    "importStyle": "{ConfigBase}",
    "description": "Base Config Object<br />Supports classes with a single argument \"options\"<br />These will be sorted into a member called \"this.config\" containing all the same keys<br /><br />Crucially, these can also be overriden through environment variables<br />For example, for a config option \"timeout\" for class Database, this could be overriden through either:<br />  env.THEMEPARKS_TIMEOUT (using a \"global module name\")<br />  env.DATABASE_TIMEOUT (using the class name)<br /><br />Classes can also add additional prefixes to the supported environment variables through:<br />  new ClassInstance({configPrefixes: ['myCustomPrefix']});<br />Which would also allow env.MYCUSTOMPREFIX_TIMEOUT to be used<br /><br />Note that a default value must be supplied for the environment variable to be processed<br />If the default value is a number, the environment variable will be cast to a number as well",
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 103,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/configBase.js~ConfigBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/configBase.js~ConfigBase#constructor",
    "access": "public",
    "description": "A base class that can be configured through environment variables",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Config for instantiating this object"
      }
    ]
  },
  {
    "__docId__": 104,
    "kind": "member",
    "name": "config",
    "memberof": "lib/configBase.js~ConfigBase",
    "static": false,
    "longname": "lib/configBase.js~ConfigBase#config",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "file",
    "name": "lib/index.js",
    "content": "import Efteling from './parks/efteling/efteling.js';\nimport {\n  WaltDisneyWorldMagicKingdom,\n  WaltDisneyWorldEpcot,\n  WaltDisneyWorldHollywoodStudios,\n  WaltDisneyWorldAnimalKingdom,\n  DisneylandResortMagicKingdom,\n  DisneylandResortCaliforniaAdventure,\n  HongKongDisneylandPark,\n} from './parks/wdw/waltdisneyworldbase.js';\nimport {\n  DisneylandParisMagicKingdom,\n  DisneylandParisWaltDisneyStudios,\n} from './parks/dlp/disneylandparis.js';\nimport {\n  ShanghaiDisneylandPark,\n} from './parks/shdr/shanghaidisneyresort.js';\nimport {\n  TokyoDisneyland,\n  TokyoDisneySea,\n} from './parks/tdr/tokyodisneyresort.js';\nimport {\n  UniversalStudiosFlorida,\n  UniversalIslandsOfAdventure,\n  UniversalVolcanoBay,\n  UniversalStudios,\n} from './parks/universal/universalstudios.js';\nimport {\n  EuropaPark,\n} from './parks/europa/europapark.js';\n\nexport default {\n  parks: {\n    WaltDisneyWorldMagicKingdom,\n    WaltDisneyWorldEpcot,\n    WaltDisneyWorldHollywoodStudios,\n    WaltDisneyWorldAnimalKingdom,\n    DisneylandResortMagicKingdom,\n    DisneylandResortCaliforniaAdventure,\n    DisneylandParisMagicKingdom,\n    DisneylandParisWaltDisneyStudios,\n    HongKongDisneylandPark,\n    ShanghaiDisneylandPark,\n    TokyoDisneyland,\n    TokyoDisneySea,\n    UniversalStudiosFlorida,\n    UniversalIslandsOfAdventure,\n    UniversalVolcanoBay,\n    UniversalStudios,\n    Efteling,\n    EuropaPark,\n  },\n  allParks: [\n    WaltDisneyWorldMagicKingdom,\n    WaltDisneyWorldEpcot,\n    WaltDisneyWorldHollywoodStudios,\n    WaltDisneyWorldAnimalKingdom,\n    DisneylandResortMagicKingdom,\n    DisneylandResortCaliforniaAdventure,\n    DisneylandParisMagicKingdom,\n    DisneylandParisWaltDisneyStudios,\n    HongKongDisneylandPark,\n    ShanghaiDisneylandPark,\n    TokyoDisneyland,\n    TokyoDisneySea,\n    UniversalStudiosFlorida,\n    UniversalIslandsOfAdventure,\n    UniversalVolcanoBay,\n    UniversalStudios,\n    Efteling,\n    EuropaPark,\n  ],\n};\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 106,
    "kind": "file",
    "name": "lib/parks/database.js",
    "content": "import ConfigBase from '../configBase.js';\nimport sieve from './sieve.js';\nimport {reusePromise, reusePromiseForever} from '../reusePromises.js';\nimport HTTP from './http.js';\nimport Cache from '../cache/scopedCache.js';\n\nconst Databases = {};\n\n/**\n * A class that handles fetching and storing data for a resort/park\n */\nexport class Database extends ConfigBase {\n  /**\n   * Construct a new Database object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    super(options);\n\n    this.cache = new Cache(this.constructor.name, this.config.cacheVersion || 0);\n\n    this.http = new HTTP();\n  }\n\n  /**\n   * Get singleton of this class type\n   * @param {object} [options] Options to pass to new instance.\n   * Will only be used if the instance doesn't already exist\n   * @return {Database}\n   */\n  static get(options = {}) {\n    const className = this.name;\n    if (Databases[className] === undefined) {\n      Databases[className] = new this(options);\n    }\n    return Databases[className];\n  }\n\n  /**\n   * Initialise this database object\n   */\n  async init() {\n    // only ever call _init once\n    await reusePromiseForever(this, this._init);\n  }\n\n  /**\n   * Internal init function, override this in child classes for functionality\n   * @abstract\n   */\n  async _init() {}\n\n  /**\n   * Get entities from this database. Optionally filtering by some conditions\n   * @param {object} [filter]\n   */\n  async getEntities(filter = {}) {\n    await this.init();\n\n    const entities = await this.cache.wrap('entities', () => {\n      return reusePromise(this, this._getEntities);\n    }, 1000 * 60); // cache for a minute for faster access\n\n    const filterFn = sieve(filter);\n    return entities.filter(filterFn);\n  }\n\n  /**\n   * Find a single entity from this database\n   * @param {object} [filter]\n   */\n  async findEntity(filter = {}) {\n    const ents = await this.getEntities();\n    const filterFn = sieve(filter);\n    return ents.find(filterFn);\n  }\n\n  /**\n   * Return all entities for this resort/park\n   * @abstract\n   * @return {array<object>}\n   */\n  async _getEntities() {\n    throw new Error(`Database class ${this.constructor.name} missing _getEntities() function`);\n  }\n\n  /**\n   * Get an entity object from it's ID\n   * @param {string} entityId Entity ID\n   */\n  async getEntitiyById(entityId) {\n    return await this.findEntity({\n      id: `${entityId}`,\n    });\n  }\n}\n\nexport default Database;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/database.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 107,
    "kind": "variable",
    "name": "Databases",
    "memberof": "lib/parks/database.js",
    "static": true,
    "longname": "lib/parks/database.js~Databases",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/database.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 108,
    "kind": "class",
    "name": "Database",
    "memberof": "lib/parks/database.js",
    "static": true,
    "longname": "lib/parks/database.js~Database",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/database.js",
    "importStyle": "{Database}",
    "description": "A class that handles fetching and storing data for a resort/park",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "lib/configBase.js~ConfigBase"
    ]
  },
  {
    "__docId__": 109,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/database.js~Database#constructor",
    "access": "public",
    "description": "Construct a new Database object",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/parks/database.js~Database",
    "static": false,
    "longname": "lib/parks/database.js~Database#cache",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "http",
    "memberof": "lib/parks/database.js~Database",
    "static": false,
    "longname": "lib/parks/database.js~Database#http",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "get",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/database.js~Database.get",
    "access": "public",
    "description": "Get singleton of this class type",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options to pass to new instance.\nWill only be used if the instance doesn't already exist"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Database"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "init",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#init",
    "access": "public",
    "description": "Initialise this database object",
    "lineNumber": 42,
    "params": [],
    "return": null
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#_init",
    "access": "private",
    "description": "Internal init function, override this in child classes for functionality",
    "lineNumber": 51,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "getEntities",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#getEntities",
    "access": "public",
    "description": "Get entities from this database. Optionally filtering by some conditions",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "findEntity",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#findEntity",
    "access": "public",
    "description": "Find a single entity from this database",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "_getEntities",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#_getEntities",
    "access": "private",
    "description": "Return all entities for this resort/park",
    "lineNumber": 83,
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "abstract": true,
    "params": []
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "getEntitiyById",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#getEntitiyById",
    "access": "public",
    "description": "Get an entity object from it's ID",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "entityId",
        "description": "Entity ID"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "file",
    "name": "lib/parks/efteling/efteling.js",
    "content": "import {Park} from '../park.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType} from '../parkTypes.js';\nimport moment from 'moment-timezone';\n\n/**\n * Efteling Park Object\n */\nexport class Efteling extends Park {\n  /**\n   * Create a new Efteling Park object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Efteling';\n    options.timezone = options.timezone || 'Europe/Amsterdam';\n\n    options.apiKey = options.apiKey || '';\n    options.apiVersion = options.apiVersion || '';\n    options.appVersion = options.appVersion || '';\n\n    options.searchUrl = options.searchUrl || 'https://prd-search-acs.efteling.com/2013-01-01/search';\n    options.waitTimesUrl = options.waitTimesUrl || 'https://api.efteling.com/app/wis/';\n\n    // bump cache to invalidate the POI data that has been updated\n    options.cacheVersion = 1;\n\n    super(options);\n\n    if (!this.config.apiKey) throw new Error('Missing Efteling apiKey');\n    if (!this.config.apiVersion) throw new Error('Missing Efteling apiVersion');\n    if (!this.config.appVersion) throw new Error('Missing Efteling appVersion');\n\n    this.injectForDomain({\n      // match either of the API domains\n      $or: [\n        {\n          hostname: 'api.efteling.com',\n        },\n        {\n          hostname: 'prd-search-acs.efteling.com',\n        },\n      ],\n    }, (method, url, data, options) => {\n      // all requests from the app to any efteling subdomain should send these headers\n      options.headers['x-app-version'] = this.config.appVersion;\n      options.headers['x-app-name'] = 'Efteling';\n      options.headers['x-app-id'] = 'nl.efteling.android';\n      options.headers['x-app-platform'] = 'Android';\n      options.headers['x-app-language'] = 'en';\n      options.headers['x-app-timezone'] = this.config.timezone;\n      // override user-agent here, rather than class-wide\n      //  any other non-Efteling API requests can use the default user-agent\n      options.headers['user-agent'] = 'okhttp/4.4.0';\n      options.compressed = true;\n    });\n\n    this.injectForDomain({\n      // only use these headers for the main API domain\n      hostname: 'api.efteling.com',\n    }, (method, url, data, options) => {\n      // api.efteling.com requries an API key as well as the above headers\n      options.headers['x-api-key'] = this.config.apiKey;\n      options.headers['x-api-version'] = this.config.apiVersion;\n    });\n  }\n\n  /**\n   * Get Efteling POI data\n   * This data contains general ride names, descriptions etc.\n   * Wait time data references this to get ride names\n   */\n  async getPOIData() {\n    return await this.cache.wrap('poidata', async () => {\n      // curl -H 'Host: prd-search-acs.efteling.com' -H 'user-agent: okhttp/4.4.0' -H 'x-app-version: v3.7.1' -H 'x-app-name: Efteling' -H 'x-app-id: nl.efteling.android' -H 'x-app-platform: Android' -H 'x-app-language: en' -H 'x-app-timezone: Europe/London' --compressed 'https://prd-search-acs.efteling.com/2013-01-01/search?q.parser=structured&size=1000&q=%28and%20%28phrase%20field%3Dlanguage%20%27en%27%29%29'\n      const fetchedPOIData = await this.http('GET', this.config.searchUrl, {\n        'size': 1000,\n        'q.parser': 'structured',\n        'q': '(and (phrase field=language \\'en\\'))',\n      });\n\n      const data = fetchedPOIData?.body?.hits?.hit;\n      if (!data) {\n        throw new Error('Failed to fetch Efteling POI data');\n      }\n\n      const poiData = {};\n      data.forEach((hit) => {\n        // skip any entries that aren't shown in the app\n        if (hit.hide_in_app) return;\n\n        if (hit.fields) {\n          poiData[hit.fields.id] = {\n            name: hit.fields.name,\n            type: hit.fields.category,\n            props: hit.fields.properties,\n          };\n\n          // try to parse lat/long\n          //  edge-case: some rides have dud \"0.0,0.0\" location, ignore these\n          if (hit.fields.latlon && hit.fields.latlon !== '0.0,0.0') {\n            const match = /([0-9.]+),([0-9.]+)/.exec(hit.fields.latlon);\n            if (match) {\n              poiData[hit.fields.id].location = {\n                latitude: Number(match[1]),\n                longitude: Number(match[2]),\n              };\n            }\n          }\n\n          // check for any alternative versions of the ride\n          //  this is usually the single rider line, though one is a \"boatride\"\n          if (hit.fields.alternateid && hit.fields.alternatetype === 'singlerider') {\n            poiData[hit.fields.id].singleRiderId = hit.fields.alternateid;\n          }\n        }\n      });\n\n      return poiData;\n    }, 1000 * 60 * 60 * 12 /* cache for 12 hours */);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _init() {\n    // make sure POI data is up-to-date\n    const poi = await this.getPOIData();\n\n    // auto-populate our attractions list with all rides and shows\n    //  this makes them appear in our API output even if they have no wait time data\n    // other valid attraction types from the Efteling API:\n    //  'merchandise', 'restaurant', 'fairytale', 'facilities-toilets', 'facilities-generic', 'eventlocation', 'game'\n    const wantedAttractionTypes = ['attraction', 'show'];\n    await Promise.allSettled(Object.keys(poi).map(async (id) => {\n      const p = poi[id];\n      if (wantedAttractionTypes.indexOf(p.type) >= 0) {\n        // request the attraction by ID so it is built, then we'll tag it with some metadata\n        const attraction = await this.findAttractionByID(id);\n        if (attraction !== undefined && p.location !== undefined) {\n          // tag with attraction's location\n          await this.setAttractionTag(id, 'location', tagType.location, {\n            longitude: p.location.longitude,\n            latitude: p.location.latitude,\n          });\n\n          // look for any other useful tags\n          // may get wet\n          await this.toggleAttractionTag(id, tagType.mayGetWet, p.props.indexOf('wet') >= 0);\n          // tag \"pregnant people should not ride\" attractions\n          await this.toggleAttractionTag(\n              id,\n              tagType.unsuitableForPregnantPeople,\n              p.props.indexOf('pregnantwomen') >= 0,\n          );\n\n          // single rider queue available?\n          await this.setAttractionTag(\n              id,\n              null,\n              tagType.singleRider,\n              !!p.singleRiderId,\n          );\n\n          // look for attraction minimum height\n          const minHeightProp = p.props.find((prop) => prop.indexOf('minimum') === 0);\n          if (minHeightProp !== undefined) {\n            const minHeightNumber = Number(minHeightProp.slice(7));\n            if (!isNaN(minHeightNumber)) {\n              await this.setAttractionTag(id, 'minimumHeight', tagType.minimumHeight, {\n                height: minHeightNumber,\n                unit: 'cm',\n              });\n            }\n          }\n        }\n      }\n    }));\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _buildAttractionObject(attractionID) {\n    const poiData = await this.getPOIData();\n\n    const data = poiData[attractionID];\n    if (!data) return undefined;\n\n    // assign the attraction type\n    let type = attractionType.other; // default to \"other\" for attractions that don't match our types\n    if (data.type === 'attraction') {\n      // all attractions default to \"ride\"\n      type = attractionType.ride;\n    } else if (data.type === 'show') {\n      type = attractionType.show;\n    }\n\n    return {\n      name: data.name,\n      type: type,\n    };\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _update() {\n    const poiData = await this.getPOIData();\n\n    const waitTimes = await this.http('GET', this.config.waitTimesUrl, {\n      language: 'en',\n    });\n\n    const attractions = waitTimes?.body?.AttractionInfo;\n    if (!attractions) throw new Error('Efteling wait times response missing AttractionInfo');\n\n    await Promise.allSettled(attractions.map(async (entry) => {\n      if (entry.Type !== 'Attraction') return;\n\n      if (poiData[entry.Id] !== undefined) {\n        let rideStatus = null;\n        const rideWaitTime = parseInt(entry.WaitingTime, 10);\n        const rideState = entry.State.toLowerCase();\n        // update ride with wait time data\n        if (rideState === 'storing' || rideState === 'tijdelijkbuitenbedrijf' || rideState === 'buitenbedrijf') {\n          // Ride down because of an interruption\n          rideStatus = statusType.down;\n        } else if (rideState === 'inonderhoud') {\n          // Ride down because of maintenance/refurbishment\n          rideStatus = statusType.refurbishment;\n        } else if (rideState === 'gesloten' || rideState === '' || rideState === 'wachtrijgesloten') {\n          // ride is \"closed\"\n          rideStatus = statusType.closed;\n        } else if (rideState === 'open') {\n          // Ride operating\n          rideStatus = statusType.operating;\n        }\n\n        if (rideStatus === null) {\n          this.emit('error', new Error(`Unknown Efteling rideStatus ${JSON.stringify(rideState)}`));\n          console.log('Unknown Efteling rideStatus', JSON.stringify(rideState));\n        }\n\n        // update attraction status\n        await this.updateAttractionState(\n            entry.Id,\n            rideStatus,\n        );\n\n        // update queue status\n        await this.updateAttractionQueue(\n            entry.Id,\n          rideStatus == statusType.operating ? rideWaitTime : null,\n          queueType.standBy,\n        );\n      } else {\n        // if we don't have POI data for this attraction, check for single rider IDs and update the main attraction\n        const singleRiderPOI = Object.keys(poiData).find((k) => {\n          return poiData[k].singleRiderId && poiData[k].singleRiderId === entry.Id;\n        });\n\n        if (singleRiderPOI !== undefined) {\n          // we have found a matching single-rider entry!\n          //  update the singleRider queue time\n          const rideWaitTime = parseInt(entry.WaitingTime, 10);\n          await this.updateAttractionQueue(singleRiderPOI, rideWaitTime, queueType.singleRider);\n        }\n      }\n    }));\n  }\n\n  /**\n   * Get calendar data for the given month and year\n   * @param {string} month\n   * @param {string} year\n   * @return {array<object>}\n   */\n  async getCalendarMonth(month, year) {\n    return await this.cache.wrap(`calendar_${year}_${month}`, async () => {\n      const data = await this.http(\n          'GET',\n          `https://www.efteling.com/service/cached/getpoiinfo/en/${year}/${month}`,\n          null,\n          {\n            headers: {\n              'X-Requested-With': 'XMLHttpRequest',\n              'referer': 'https://www.efteling.com/en/park/opening-hours?app=true',\n              'cookie': 'website#lang=en',\n            },\n            json: true,\n          },\n      );\n\n      // Efteling returns 400 once the month is in the past\n      if (data.statusCode === 400) {\n        return undefined;\n      }\n\n      if (!data?.body?.OpeningHours) throw new Error(`Unable to find opening hours for Efteling ${data.body}`);\n\n      return data.body;\n    }, 1000 * 60 * 60 * 12); // 12 hours\n  }\n\n  /**\n   * Return the operating hours for the supplied date\n   * @param {moment} date\n   */\n  async _getOperatingHoursForDate(date) {\n    const cal = await this.getCalendarMonth(date.format('M'), date.format('YYYY'));\n    if (cal === undefined) return undefined;\n\n    const dateFormatted = date.format('YYYY-MM-DD');\n    const data = cal.OpeningHours.find((x) => x.Date === dateFormatted);\n    if (data) {\n      return data.OpeningHours.map((d) => {\n        const open = d.Open.split(':').map(Number);\n        const close = d.Close.split(':').map(Number);\n        return {\n          openingTime: date.clone().set('hour', open[0]).set('minute', open[1]).format(),\n          closingTime: date.clone().set('hour', close[0]).set('minute', close[1]).format(),\n          type: scheduleType.operating,\n        };\n      });\n    }\n    return undefined;\n  }\n\n  /**\n * Get restaurant operating hours from API\n * @param {string} day\n * @param {string} month\n * @param {string} year\n */\n  async getRestaurantOperatingHours(day, month, year) {\n    return await this.cache.wrap(`restaurant_${year}_${month}_${day}`, async () => {\n      const waitTimes = await this.http('GET', this.config.waitTimesUrl, {\n        language: 'en',\n      });\n\n      if (!waitTimes?.body?.AttractionInfo) {\n        throw new Error(`Unable to find restaurant operating hours for Efteling ${data.body}`);\n      }\n\n      return waitTimes.body;\n    }, 1000 * 60 * 60 * 12); // 12 hours\n  }\n\n  /**\n   * Return restaurant operating hours for the supplied date\n   * @param {moment} date\n   */\n  async _getRestaurantOperatingHoursForDate(date) {\n    const cal = await this.getRestaurantOperatingHours(date.format('D'), date.format('M'), date.format('YYYY'));\n\n    if (cal === undefined) return undefined;\n\n    const data = cal.AttractionInfo;\n\n    return data.map((entry) => {\n      if (entry.Type !== 'Horeca') return;\n\n      if (!entry.OpeningTimes || entry.OpeningTimes.length == 0) {\n        return {\n          restaurantID: entry.Id,\n          openingTime: 0,\n          closingTime: 0,\n          status: statusType.closed,\n        };\n      }\n\n      const openingTimes = entry.OpeningTimes;\n\n      return {\n        restaurantID: entry.Id,\n        openingTime: moment(openingTimes[0].HourFrom).format(),\n        closingTime: moment(openingTimes[0].HourTo).format(),\n        type: scheduleType.operating,\n      };\n    }).filter((x) => x !== undefined);\n  }\n}\n\nexport default Efteling;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/efteling/efteling.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 120,
    "kind": "class",
    "name": "Efteling",
    "memberof": "lib/parks/efteling/efteling.js",
    "static": true,
    "longname": "lib/parks/efteling/efteling.js~Efteling",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/efteling/efteling.js",
    "importStyle": "{Efteling}",
    "description": "Efteling Park Object",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "lib/parks/park.js~Park"
    ]
  },
  {
    "__docId__": 121,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#constructor",
    "access": "public",
    "description": "Create a new Efteling Park object",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "getPOIData",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#getPOIData",
    "access": "public",
    "description": "Get Efteling POI data<br />This data contains general ride names, descriptions etc.<br />Wait time data references this to get ride names",
    "lineNumber": 72,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_init",
    "access": "private",
    "description": "",
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_buildAttractionObject",
    "access": "private",
    "description": "",
    "lineNumber": 183,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "attractionID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"name\": *, \"type\": *}"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_update",
    "access": "private",
    "description": "",
    "lineNumber": 207,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "getCalendarMonth",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#getCalendarMonth",
    "access": "public",
    "description": "Get calendar data for the given month and year",
    "lineNumber": 278,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "_getOperatingHoursForDate",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_getOperatingHoursForDate",
    "access": "private",
    "description": "Return the operating hours for the supplied date",
    "lineNumber": 309,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "getRestaurantOperatingHours",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#getRestaurantOperatingHours",
    "access": "public",
    "description": "Get restaurant operating hours from API",
    "lineNumber": 335,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "day",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "_getRestaurantOperatingHoursForDate",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_getRestaurantOperatingHoursForDate",
    "access": "private",
    "description": "Return restaurant operating hours for the supplied date",
    "lineNumber": 353,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "file",
    "name": "lib/parks/entity.js",
    "content": "import ConfigBase from '../configBase.js';\nimport moment from 'moment-timezone';\nimport zlib from 'zlib';\nimport util from 'util';\nimport HTTP from './http.js';\n\nconst zDecompress = util.promisify(zlib.unzip);\nconst zCompress = util.promisify(zlib.deflate);\n\n/**\n * A super-class that Parks/Resorts/etc. inherit from.\n * Handles general logic for objects that are a place/entity.\n */\nexport class Entity extends ConfigBase {\n  /**\n   * Construct a new Entity\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    // offline mode, never request any data, rely on manually serialised data to run\n    options.offline = options.offline || false;\n\n    // generate a random Android user-agent if we aren't supplied one\n    options.useragent = options.useragent || null;\n\n    super(options);\n\n    if (!this.config.name) {\n      throw new Error(`Missing name for constructed Entity object ${this.constructor.name}`);\n    }\n\n    if (!this.config.timezone) {\n      throw new Error(`Missing timezone for constructed Entity object ${this.constructor.name}`);\n    }\n    if (moment.tz.names().indexOf(this.config.timezone) < 0) {\n      throw new Error(`Entity object ${this.constructor.name} gives an invalid timezone: ${this.config.timezone}`);\n    }\n\n    this.http = new HTTP();\n    if (this.config.useragent) {\n      this.http.useragent = this.config.useragent;\n    }\n\n    // debug log all HTTP requests\n    this.http.injectForDomain({hostname: {$exists: true}}, (method, url) => {\n      this.log(method, url);\n    });\n\n    // offline function data\n    this._offlineFunctions = [];\n    this._offlineData = {};\n    this._hasOfflineData = false;\n    this._offlinePromise = null;\n    this._offlinePromiseResolve = null;\n  }\n\n  /**\n   * Debug log\n   * @param  {...any} args Message to debug log\n   */\n  log(...args) {\n    console.log(`[\\x1b[32m${this.getUniqueID()}\\x1b[0m]`, ...args);\n  }\n\n  /**\n   * Get a globally unique ID for this entity\n   * @return {string}\n   */\n  getUniqueID() {\n    // by default, return the class name\n    return this.constructor.name;\n  }\n\n  /**\n   * Return the current time for this entity in its local timezone\n   * @return {moment}\n   */\n  getTimeNowMoment() {\n    return moment().tz(this.config.timezone);\n  }\n\n  /**\n   * Return the current time for this entity in its local timezone\n   * @return {string}\n   */\n  getTimeNow() {\n    return this.getTimeNowMoment().format();\n  }\n\n  /**\n   * Get entity's human-friendly name string\n   * @return {string}\n   */\n  get name() {\n    return this.config.name;\n  }\n\n  /**\n   * Is this object operating offline?\n   */\n  get offline() {\n    return !!this.config.offline;\n  }\n\n  /**\n   * Register a function on this entity for offline access\n   * @param {string} functionName\n   */\n  registerOfflineFunction(functionName) {\n    if (this[functionName] && typeof this[functionName] === 'function') {\n      if (this._offlineFunctions.indexOf(functionName) < 0) {\n        this._offlineFunctions.push(functionName);\n\n        // if we're in offline mode...\n        if (this.offline) {\n          // override function and restore from our data cache instead\n          this[functionName] = async () => {\n            await this.ensureHasOfflineData();\n\n            if (this._offlineData[functionName] !== undefined) {\n              return this._offlineData[functionName];\n            }\n            return undefined;\n          };\n        }\n      }\n    }\n  }\n\n  /**\n   * Called after loading serialised offline data\n   */\n  async _postOfflineLoad() {}\n\n  /**\n   * Serialise this entity\n   * @param {object} bundle Bundle to read/write from/to\n   * @param {boolean} saving Whether we are saving or loading during this serialise operation\n   * @param {object} [options]\n   * @param {number} [options.version=1] Version of the seialised data\n   * @param {boolean} [options.recursive=true] Recurse through attached entities?\n   */\n  async serialise(bundle = {}, saving = true, options = {\n    version: 1,\n    recursive: true,\n  }) {\n    if (saving) {\n      // === Saving ===\n      // default options\n      bundle.version = options.version;\n      bundle.ar = {\n        functions: {},\n        children: [],\n      };\n\n      // loop over all offline functions and store their data\n      for (let i=0; i<this._offlineFunctions.length; i++) {\n        const functionName = this._offlineFunctions[i];\n        bundle.ar.functions[functionName] = await this[functionName]();\n      }\n\n      // TODO - loop over child entities, call serialise on them, then store their bundle.ar in ours\n    } else {\n      // === Loading ===\n      // decompress/load the data\n      const bundleBuffer = await zDecompress(bundle);\n      bundle = JSON.parse(bundleBuffer.toString('utf8'));\n\n      const version = bundle.version || 0;\n      // check we understand this bundle version\n      if (version !== 1) {\n        throw new Error('Unable to load serialised bundle version', version);\n      }\n\n      // restore function data\n      this._offlineData = bundle.ar.functions;\n\n      // TODO - restore child entities\n    }\n\n    if (saving) {\n      // pack and gz to buffer\n      const bundleData = JSON.stringify(bundle);\n      return await zCompress(bundleData);\n    }\n\n    // after loading, run any postUpdate functions\n    this._postOfflineLoad();\n\n    this._hasOfflineData = true;\n\n    // check if any process if waiting for offline data to be ready\n    if (this._offlinePromiseResolve !== null) {\n      this._offlinePromiseResolve();\n      this._offlinePromiseResolve = null;\n      this._offlinePromise = null;\n    }\n  }\n\n  /**\n   * Await until offline data is present\n   */\n  async ensureHasOfflineData() {\n    if (this.offline && !this._hasOfflineData) {\n      if (this._offlinePromise === null) {\n        this._offlinePromise = new Promise((resolve) => {\n          this._offlinePromiseResolve = resolve;\n        });\n      }\n      return this._offlinePromise;\n    }\n  }\n\n  /**\n   * Register a new injection for a specific domain\n   * @param {object} filter Mongo-type query to use to match a URL\n   * @param {function} func Function to call with needle request to inject extra data into.\n   * Function will take arguments: (method, URL, data, options)\n   */\n  async injectForDomain(filter, func) {\n    this.http.injectForDomain(filter, func);\n  }\n}\n\nexport default Entity;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/entity.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 131,
    "kind": "variable",
    "name": "zDecompress",
    "memberof": "lib/parks/entity.js",
    "static": true,
    "longname": "lib/parks/entity.js~zDecompress",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/entity.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 132,
    "kind": "variable",
    "name": "zCompress",
    "memberof": "lib/parks/entity.js",
    "static": true,
    "longname": "lib/parks/entity.js~zCompress",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/entity.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 133,
    "kind": "class",
    "name": "Entity",
    "memberof": "lib/parks/entity.js",
    "static": true,
    "longname": "lib/parks/entity.js~Entity",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/entity.js",
    "importStyle": "{Entity}",
    "description": "A super-class that Parks/Resorts/etc. inherit from.<br />Handles general logic for objects that are a place/entity.",
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "lib/configBase.js~ConfigBase"
    ]
  },
  {
    "__docId__": 134,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#constructor",
    "access": "public",
    "description": "Construct a new Entity",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "http",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#http",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "member",
    "name": "_offlineFunctions",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_offlineFunctions",
    "access": "private",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "member",
    "name": "_offlineData",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_offlineData",
    "access": "private",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "_hasOfflineData",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_hasOfflineData",
    "access": "private",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "_offlinePromise",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_offlinePromise",
    "access": "private",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "_offlinePromiseResolve",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_offlinePromiseResolve",
    "access": "private",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "log",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#log",
    "access": "public",
    "description": "Debug log",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Message to debug log"
      }
    ],
    "return": null
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "getUniqueID",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#getUniqueID",
    "access": "public",
    "description": "Get a globally unique ID for this entity",
    "lineNumber": 69,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "getTimeNowMoment",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#getTimeNowMoment",
    "access": "public",
    "description": "Return the current time for this entity in its local timezone",
    "lineNumber": 78,
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "getTimeNow",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#getTimeNow",
    "access": "public",
    "description": "Return the current time for this entity in its local timezone",
    "lineNumber": 86,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 145,
    "kind": "get",
    "name": "name",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#name",
    "access": "public",
    "description": "Get entity's human-friendly name string",
    "lineNumber": 94,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "get",
    "name": "offline",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#offline",
    "access": "public",
    "description": "Is this object operating offline?",
    "lineNumber": 101,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "registerOfflineFunction",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#registerOfflineFunction",
    "access": "public",
    "description": "Register a function on this entity for offline access",
    "lineNumber": 109,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "functionName",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 148,
    "kind": "member",
    "name": "[functionName]",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#[functionName]",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "_postOfflineLoad",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_postOfflineLoad",
    "access": "private",
    "description": "Called after loading serialised offline data",
    "lineNumber": 133,
    "params": [],
    "return": null
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "serialise",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#serialise",
    "access": "public",
    "description": "Serialise this entity",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "bundle",
        "description": "Bundle to read/write from/to"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "saving",
        "description": "Whether we are saving or loading during this serialise operation"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "options.version",
        "description": "Version of the seialised data"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.recursive",
        "description": "Recurse through attached entities?"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "ensureHasOfflineData",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#ensureHasOfflineData",
    "access": "public",
    "description": "Await until offline data is present",
    "lineNumber": 203,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "injectForDomain",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#injectForDomain",
    "access": "public",
    "description": "Register a new injection for a specific domain",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "filter",
        "description": "Mongo-type query to use to match a URL"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "Function to call with needle request to inject extra data into.\nFunction will take arguments: (method, URL, data, options)"
      }
    ],
    "return": null
  },
  {
    "__docId__": 159,
    "kind": "file",
    "name": "lib/parks/europa/europapark.js",
    "content": "import EuropaParkDB from './europaparkdb.js';\nimport Park from '../park.js';\nimport {statusType, queueType, scheduleType, returnTimeState} from '../parkTypes.js';\nimport moment from 'moment-timezone';\n\n/**\n * Europa Park Base Class\n */\nexport class EuropaParkBase extends Park {\n  /**\n   * @inheritdoc\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.timezone = 'Europe/Berlin';\n\n    options.parkId = options.parkId || '';\n\n    super(options);\n\n    if (!this.config.parkId) throw new Error('Missing Europa Park Id');\n  }\n\n  /**\n   * Get our resort database\n   */\n  get db() {\n    return EuropaParkDB.get();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _init() {\n    // add all park attractions\n    const attractions = await this.db.getEntities({\n      // filter entities by our park ID\n      '_src.scopes': {\n        $elemMatch: {\n          $eq: this.config.parkId,\n        },\n      },\n    });\n\n    // force inject each attraction so it appears in the attraction list, even if it has no wait times\n    await Promise.allSettled(attractions.map(async (a) => {\n      await this.findAttractionByID(a.id);\n    }));\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _buildAttractionObject(attractionID) {\n    return await this.db.findEntity({\n      'id': `${attractionID}`,\n      // filter entities by our park ID\n      '_src.scopes': {\n        $elemMatch: {\n          $eq: this.config.parkId,\n        },\n      },\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _update() {\n    const waits = await this.db.getWaitingTimes();\n\n    // just push all wait times, let our _buildAttractionObject filter out ones for other parks\n    await Promise.allSettled(waits.waitingtimes.map(async (wait) => {\n      let status = statusType.operating;\n      let queue = queueType.standBy;\n\n      // check to see if we're a virtual queue for another ride\n      const realRide = await this.db.findEntity({\n        '_src.vQueue.code': {\n          $eq: wait.code,\n        },\n      });\n      if (realRide !== undefined) {\n        // we have a virtual queue!\n        queue = queueType.returnTime;\n\n        let state = returnTimeState.available;\n        switch (wait.time) {\n          case 666:\n            state = returnTimeState.temporarilyFull;\n            break;\n          case 777:\n            state = returnTimeState.finished;\n            break;\n          case (wait.time <= 91):\n            state = returnTimeState.available;\n            break;\n        }\n\n        // update return time queue\n        await this.updateAttractionQueue(realRide._src.code, {\n          returnStart: wait.startAt,\n          returnEnd: wait.endAt,\n          state,\n        }, queueType.returnTime);\n\n        // skip regular updating if we're a \"return time\" queue entry\n        //  the standby version of the right will handle normal states\n        return;\n      }\n\n      // if time == 90, wait time is reported as 90+ in-app\n      // time == 91, virtual queue is open\n      // time == 999, down\n      // time == 222, closed refurb\n      // time == 333, closed\n      // time == 444, closed becaue weather\n      // time == 555, closed because ice\n      // time == 666, virtual queue is \"temporarily full\"\n      // time == 777, virtual queue is completely full\n      switch (wait.time) {\n        case 999:\n        case 444: // weather\n        case 555: // ice\n          status = statusType.down;\n          break;\n        case 222:\n          status = statusType.refurbishment;\n          break;\n        case 333:\n          status = statusType.closed;\n          break;\n      }\n\n      await this.updateAttractionState(wait.code, status);\n\n      if (queue == queueType.standBy) {\n        await this.updateAttractionQueue(wait.code, wait.time <= 90 ? wait.time : null, queue);\n      }\n    }));\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getOperatingHoursForDate(date) {\n    const cal = await this.db.getCalendar();\n    const parkTimes = cal.seasons.filter(\n        // filter opening hours for actual opening times (ignore closed times)\n        // filter by scopes including our park Id\n        (x) => !x.closed && x.scopes.indexOf(this.config.parkId) >= 0,\n    ).find(\n        // find valid season for the supplied date\n        (x) => date.isBetween(x.startAt, x.endAt, 'day'),\n    );\n\n    if (parkTimes !== undefined) {\n      const times = [];\n\n      const buildDateString = (inDate) => {\n        return moment.tz(inDate, this.config.timezone).set({\n          year: date.year(),\n          month: date.month(),\n          date: date.date(),\n        }).format();\n      };\n\n      times.push({\n        openingTime: buildDateString(parkTimes.startAt),\n        closingTime: buildDateString(parkTimes.endAt),\n        type: scheduleType.operating,\n      });\n\n      // hotel extra hours\n      if (parkTimes.hotelStartAt && parkTimes.hotelEndAt) {\n        times.push({\n          openingTime: buildDateString(parkTimes.hotelStartAt),\n          closingTime: buildDateString(parkTimes.hotelEndAt),\n          type: scheduleType.extraHours,\n          description: 'Open To Hotel Guests',\n        });\n      }\n\n      return times;\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * Europa Park\n */\nexport class EuropaPark extends EuropaParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Europa-Park';\n    options.parkId = 'europapark';\n    super(options);\n  }\n}\n\n/**\n * Rulantica\n */\nexport class Rulantica extends EuropaParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Rulantica';\n    options.parkId = 'rulantica';\n    super(options);\n  }\n}\n\n/**\n * Yullbe\n */\nexport class Yullbe extends EuropaParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Yullbe';\n    options.parkId = 'yullbe';\n    super(options);\n  }\n}\n\nexport default EuropaParkBase;\n\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/europa/europapark.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 160,
    "kind": "class",
    "name": "EuropaParkBase",
    "memberof": "lib/parks/europa/europapark.js",
    "static": true,
    "longname": "lib/parks/europa/europapark.js~EuropaParkBase",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/europa/europapark.js",
    "importStyle": "{EuropaParkBase}",
    "description": "Europa Park Base Class",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "lib/parks/park.js~Park"
    ]
  },
  {
    "__docId__": 161,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/europa/europapark.js~EuropaParkBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaParkBase#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 14,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 162,
    "kind": "get",
    "name": "db",
    "memberof": "lib/parks/europa/europapark.js~EuropaParkBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaParkBase#db",
    "access": "public",
    "description": "Get our resort database",
    "lineNumber": 27,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/europa/europapark.js~EuropaParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaParkBase#_init",
    "access": "private",
    "description": "",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/europa/europapark.js~EuropaParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaParkBase#_buildAttractionObject",
    "access": "private",
    "description": "",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "attractionID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/europa/europapark.js~EuropaParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaParkBase#_update",
    "access": "private",
    "description": "",
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "_getOperatingHoursForDate",
    "memberof": "lib/parks/europa/europapark.js~EuropaParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaParkBase#_getOperatingHoursForDate",
    "access": "private",
    "description": "",
    "lineNumber": 146,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "class",
    "name": "EuropaPark",
    "memberof": "lib/parks/europa/europapark.js",
    "static": true,
    "longname": "lib/parks/europa/europapark.js~EuropaPark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/europa/europapark.js",
    "importStyle": "{EuropaPark}",
    "description": "Europa Park",
    "lineNumber": 194,
    "interface": false,
    "extends": [
      "EuropaParkBase"
    ]
  },
  {
    "__docId__": 168,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 198,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 169,
    "kind": "class",
    "name": "Rulantica",
    "memberof": "lib/parks/europa/europapark.js",
    "static": true,
    "longname": "lib/parks/europa/europapark.js~Rulantica",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/europa/europapark.js",
    "importStyle": "{Rulantica}",
    "description": "Rulantica",
    "lineNumber": 208,
    "interface": false,
    "extends": [
      "EuropaParkBase"
    ]
  },
  {
    "__docId__": 170,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/europa/europapark.js~Rulantica",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~Rulantica#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 212,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 171,
    "kind": "class",
    "name": "Yullbe",
    "memberof": "lib/parks/europa/europapark.js",
    "static": true,
    "longname": "lib/parks/europa/europapark.js~Yullbe",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/europa/europapark.js",
    "importStyle": "{Yullbe}",
    "description": "Yullbe",
    "lineNumber": 222,
    "interface": false,
    "extends": [
      "EuropaParkBase"
    ]
  },
  {
    "__docId__": 172,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/europa/europapark.js~Yullbe",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~Yullbe#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 226,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 173,
    "kind": "file",
    "name": "lib/parks/europa/europaparkdb.js",
    "content": "import Database from '../database.js';\nimport crypto from 'crypto';\nimport {URL} from 'url';\nimport {tagType, attractionType, entityType} from '../parkTypes.js';\nimport Blowfish from 'egoroof-blowfish';\n\n/**\n * Europa Park Database Class\n */\nexport class DatabaseEuropaPark extends Database {\n  /**\n   * @inheritdoc\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.fbAppId = '';\n    options.fbApiKey = '';\n    options.fbProjectId = '';\n    options.apiBase = '';\n    options.encKey = '';\n    options.encIV = '';\n    options.authURL = '';\n\n    options.configPrefixes = ['EUROPAPARK'].concat(options.configPrefixes || []);\n\n    super(options);\n\n    if (!this.config.fbApiKey) throw new Error('Missing Europa Park Firebase API Key');\n    if (!this.config.fbAppId) throw new Error('Missing Europa Park Firebase App ID');\n    if (!this.config.fbProjectId) throw new Error('Missing Europa Park Firebase Project ID');\n    if (!this.config.apiBase) throw new Error('Missing Europa Park API Base');\n    if (!this.config.encKey) throw new Error('Missing Europa Park Encryption Key');\n    if (!this.config.encIV) throw new Error('Missing Europa Park Encryption IV');\n    if (!this.config.authURL) throw new Error('Missing Europa Park Auth URL');\n\n    this.http.injectForDomain({\n      hostname: new URL(this.config.apiBase).hostname,\n    }, async (method, url, data, options) => {\n      // skip this if we're making the request to get the token\n      //  otherwise we'll have an infinite loop!\n      if (!options.login) {\n        const jwtToken = await this.getToken();\n        if (jwtToken === undefined) {\n          // refetch Firebase settings and try again\n          await this.cache.set('auth', undefined, -1);\n          const jwtTokenRetry = await this.getToken();\n          options.headers['jwtauthorization'] = `Bearer ${jwtTokenRetry}`;\n        } else {\n          options.headers['jwtauthorization'] = `Bearer ${jwtToken}`;\n        }\n      }\n    });\n\n    this.http.injectForDomainResponse({\n      hostname: new URL(this.config.apiBase).hostname,\n    }, async (response) => {\n      // if error code is unauthorised, clear out our JWT token\n      if (response.statusCode === 401) {\n        // wipe any existing token\n        await this.cache.set('token', undefined, -1);\n        // this will be regenerated next time injectForDomain is run\n        return undefined;\n      }\n\n      return response;\n    });\n\n    this.bf = new Blowfish(this.config.encKey, Blowfish.MODE.CBC, Blowfish.PADDING.PKCS5 );\n    this.bf.setIv(this.config.encIV);\n  }\n\n  /**\n   * Get or generate a Firebase device ID\n   */\n  async getFirebaseID() {\n    return await this.cache.wrap('fid', async () => {\n      try {\n        const fidByteArray = crypto.randomBytes(17).toJSON().data;\n        fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\n        const b64String = Buffer.from(String.fromCharCode(...fidByteArray))\n            .toString('base64')\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_');\n        const fid = b64String.substr(0, 22);\n        return /^[cdef][\\w-]{21}$/.test(fid) ? fid : '';\n      } catch (e) {\n        this.emit('error', e);\n        console.log(e);\n        return '';\n      }\n    }, 1000 * 60 * 60 * 24 * 8); // 8days\n  }\n\n  /**\n   * Get Europa Park config keys\n   */\n  async getConfig() {\n    return await this.cache.wrap('oauth', async () => {\n      const fid = await this.getFirebaseID();\n\n      const resp = await this.http(\n          'POST',\n          `https://firebaseremoteconfig.googleapis.com/v1/projects/${this.config.fbProjectId}/namespaces/firebase:fetch`,\n          {\n            'appInstanceId': fid,\n            'appId': this.config.fbAppId,\n            'packageName': 'com.EuropaParkMackKG.EPGuide',\n            'languageCode': 'en_GB',\n          }, {\n            headers: {\n              'X-Goog-Api-Key': this.config.fbApiKey,\n            },\n          },\n      );\n\n      const decrypt = (str) => {\n        return this.bf.decode(Buffer.from(str, 'base64'), Blowfish.TYPE.STRING);\n      };\n      return {\n        client_id: decrypt(resp.body.entries.v3_live_android_exozet_api_username),\n        client_secret: decrypt(resp.body.entries.v3_live_android_exozet_api_password),\n        grant_type: 'client_credentials',\n      };\n    }, 1000 * 60 * 60 * 6); // 6 hours\n  }\n\n  /**\n   * Get our JWT Token\n   */\n  async getToken() {\n    let expiresIn = 1000 * 60 * 60 * 24; // default: 1 day\n\n    return await this.cache.wrap('token', async () => {\n      const auth = await this.getConfig();\n      const resp = await this.http(\n          'POST',\n          `${this.config.authURL}`,\n          auth,\n          {\n            json: true,\n            login: true,\n          },\n      );\n\n      const token = resp?.body?.access_token;\n      expiresIn = (resp?.body?.expires_in || 60 * 60 * 24) * 1000;\n\n      return token;\n    }, () => {\n      return expiresIn;\n    });\n  }\n\n  /**\n   * Get static data for all park entities\n   */\n  async getParkData() {\n    return await this.cache.wrap('poi', async () => {\n      // get the last checksum we received\n      const checksum = (await this.cache.get('poi_checksum')) || 0;\n      const data = await this.http(\n          'GET',\n          `${this.config.apiBase}/api/v1/latest/en/live/${checksum}`,\n          undefined,\n          {\n            json: true,\n            ignoreErrors: true, // we want 404 errors\n          },\n      );\n\n      if (data.body?.error?.code === 404 && checksum > 0) {\n        // return old data, hasn't changed\n        return await this.cache.get('poi_store');\n      }\n\n      if (!data.body.package) return undefined;\n\n      // collapse sub fields into one array\n      const entities = [];\n      Object.keys(data.body.package.data).forEach((key) => {\n        data.body.package.data[key].forEach((x) => {\n          entities.push({\n            ...x,\n            entityType: key,\n          });\n        });\n      });\n\n      // store this data indefinitely, we'll only override it if the checksum changes\n      await this.cache.set('poi_store', entities, Number.MAX_SAFE_INTEGER);\n      await this.cache.set('poi_checksum', data.body.package.checksum);\n\n      return entities;\n    }, 1000 * 60 * 60 * 2); // check every 2 hours for updates\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _init() {\n\n  }\n\n  /**\n   * Get waiting time data from API\n   */\n  async getWaitingTimes() {\n    return this.cache.wrap('waittingtimes', async () => {\n      return (await this.http('GET', `${this.config.apiBase}/api/v1/waitingtimes`)).body;\n    }, 1000 * 60);\n  }\n\n  /**\n   * Get Europa Park calendar data\n   */\n  async getCalendar() {\n    return this.cache.wrap('seasons', async () => {\n      return (await this.http('GET', `${this.config.apiBase}/api/v1/seasons/en`)).body;\n    }, 1000 * 60 * 60 * 6);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getEntities() {\n    const poiData = await this.getParkData();\n\n    const ret = poiData.map((poi) => {\n      if (poi.code === undefined || poi.code === null) return undefined;\n\n      if (poi.type !== 'attraction') return undefined;\n\n      // \"queueing\" entries are pretend entities for virtual queues\n      if (poi.queueing) return undefined;\n\n      // ignore queue map pointers\n      if (poi.name.indexOf('Queue - ') === 0) return undefined;\n\n      delete poi.versions;\n\n      // check for virtual queue\n      const vQueueData = poiData.find((x) => {\n        return x.queueing && x.name.indexOf(poi.name) > 0;\n      });\n      // virtual queue waitingtimes data\n      // code === vQueueData.code\n      // time can only ever be between 0-90, anything >90 is a special code\n      // if time == 90, wait time is reported as 90+ in-app\n      // time == 91, virtual queue is open\n      // time == 999, down\n      // time == 222, closed refurb\n      // time == 333, closed\n      // time == 444, closed becaue weather\n      // time == 555, closed because ice\n      // time == 666, virtual queue is \"temporarily full\"\n      // time == 777, virtual queue is completely full\n      // startAt/endAt - current virtual queue window\n\n      const tags = [];\n\n      tags.push({\n        key: 'location',\n        type: tagType.location,\n        value: {\n          longitude: poi.longitude,\n          latitude: poi.latitude,\n        },\n      });\n\n      if (poi.minHeight) {\n        tags.push({\n          key: 'minimumHeight',\n          type: tagType.minimumHeight,\n          value: {\n            unit: 'cm',\n            height: poi.minHeight,\n          },\n        });\n      }\n\n      if (poi.maxHeight) {\n        tags.push({\n          key: 'maximumHeight',\n          type: tagType.maximumHeight,\n          value: {\n            unit: 'cm',\n            height: poi.maxHeight,\n          },\n        });\n      }\n\n      return {\n        id: `${poi.code}`,\n        name: poi.name,\n        type: attractionType.ride,\n        entityType: entityType.attraction,\n        tags,\n        _src: {\n          ...poi,\n          vQueue: vQueueData,\n        },\n      };\n    }).filter((x) => x !== undefined);\n\n    return ret;\n  }\n}\n\nexport default DatabaseEuropaPark;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/europa/europaparkdb.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 174,
    "kind": "class",
    "name": "DatabaseEuropaPark",
    "memberof": "lib/parks/europa/europaparkdb.js",
    "static": true,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/europa/europaparkdb.js",
    "importStyle": "{DatabaseEuropaPark}",
    "description": "Europa Park Database Class",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "lib/parks/database.js~Database"
    ]
  },
  {
    "__docId__": 175,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 15,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 176,
    "kind": "member",
    "name": "bf",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#bf",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "getFirebaseID",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getFirebaseID",
    "access": "public",
    "description": "Get or generate a Firebase device ID",
    "lineNumber": 75,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "getConfig",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getConfig",
    "access": "public",
    "description": "Get Europa Park config keys",
    "lineNumber": 97,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "getToken",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getToken",
    "access": "public",
    "description": "Get our JWT Token",
    "lineNumber": 130,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "getParkData",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getParkData",
    "access": "public",
    "description": "Get static data for all park entities",
    "lineNumber": 157,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#_init",
    "access": "private",
    "description": "",
    "lineNumber": 200,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "getWaitingTimes",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getWaitingTimes",
    "access": "public",
    "description": "Get waiting time data from API",
    "lineNumber": 207,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "getCalendar",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getCalendar",
    "access": "public",
    "description": "Get Europa Park calendar data",
    "lineNumber": 216,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "_getEntities",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#_getEntities",
    "access": "private",
    "description": "",
    "lineNumber": 225,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "file",
    "name": "lib/parks/http.js",
    "content": "import HarWriter from '../har.js';\nimport randomUseragent from 'random-useragent';\nimport moment from 'moment-timezone';\nimport sift from 'sift';\nimport needle from 'needle';\nimport promiseRetry from 'promise-retry';\n\n/**\n * Generate a random Android user agent for making network requests\n * @return {string}\n */\nexport function generateRandomAndroidUseragent() {\n  return randomUseragent.getRandom((ua) => {\n    return (ua.osName === 'Android');\n  });\n}\n\n// start our har writer (if debugging)\nconst harWriter = process.env['THEMEPARKS_HAR'] ?\n  new HarWriter({filename: `${process.env['THEMEPARKS_HAR']}.har`}):\n  null;\n\n/**\n   * Write a HTTP response to HAR file for debugging\n   * @param {*} method\n   * @param {*} url\n   * @param {*} data\n   * @param {*} options\n   * @param {*} resp\n   * @param {*} startTime\n   * @param {*} timeTaken\n   * @private\n   */\nasync function writeToHAR(method, url, data, options, resp, startTime, timeTaken) {\n  const objToArr = (obj) => {\n    return Object.keys(obj).map((header) => {\n      return {name: header, value: obj[header].toString()};\n    });\n  };\n\n  const entry = {\n    startedDateTime: startTime,\n    time: timeTaken,\n    request: {\n      method: method,\n      url: url,\n      httpVersion: `HTTP/${resp.httpVersion}`, // this is actually the response, TODO\n      cookies: [],\n      headers: objToArr(options.headers), // not the actual headers needle sends - TODO, how to get these?\n      queryString: method === 'GET' ? objToArr(data) : [], // TODO - parse from needle's .path\n      postData: {\n        mimeType: options.json ? 'application/json' : (options.headers['content-type'] || ''),\n        params: method !== 'GET' ? [] : [],\n        text: '',\n      },\n      headersSize: -1,\n      bodySize: -1,\n    },\n    response: {\n      status: resp.statusCode,\n      statusText: resp.statusMessage,\n      httpVersion: `HTTP/${resp.httpVersion}`,\n      cookies: [],\n      headers: objToArr(resp.headers),\n      content: {\n        size: resp.raw.length || -1,\n        mimeType: resp.headers['content-type'],\n        text: resp.raw.toString('base64'),\n        encoding: 'base64',\n      },\n      redirectURL: '',\n      headersSize: -1,\n      bodySize: -1,\n    },\n    cache: {},\n    timings: {\n      send: -1,\n      wait: -1,\n      receive: -1,\n    },\n  };\n  await harWriter.recordEntry(entry);\n}\n\n/**\n * HTTP helper with injection\n * @return {*}\n */\nexport const HTTP = (function() {\n  this._httpInjections = [];\n  this._httpResponseInjections = [];\n  this.useragent = generateRandomAndroidUseragent();\n\n  /**\n   * Helper function to make an HTTP request for this park\n   * Parks can automatically add in authentication headers etc. to requests sent to this function\n   * @param {string} method HTTP method to use (GET,POST,DELETE, etc)\n   * @param {string} url URL to request\n   * @param {object} [data] data to send. Will become querystring for GET, body for POST\n   * @param {object} [options = {}] Object containing needle-compatible HTTP options\n   */\n  const mainFunction = async (method, url, data, options = {}) => {\n    // always have a headers array\n    if (!options.headers) {\n      options.headers = {};\n    }\n\n    // default to accepting compressed data\n    options.compressed = options.compressed === undefined ? true : options.compressed;\n\n    // 10 seconds default timeout opening response\n    options.response_timeout = options.response_timeout || 10000;\n    // 30 seconds default timeout for reading data (for large data streams)\n    options.read_timeout = options.read_timeout || 30000;\n\n    // inject custom standard user agent (if we have one)\n    //  do this before any custom injections so parks can optionally override this for each domain\n    if (this.useragent) {\n      options.headers['user-agent'] = this.useragent;\n    }\n\n    // check any hostname injections we have setup\n    const urlObj = new URL(url);\n    const urlFilter = {\n      protocol: urlObj.protocol,\n      host: urlObj.host,\n      hostname: urlObj.hostname,\n      pathname: urlObj.pathname,\n      search: urlObj.search,\n      hash: urlObj.hash,\n    };\n\n    // wrap our needle call in a retry\n    return await promiseRetry({\n      retries: 3,\n    }, async (retryFn) => {\n      // make sure we run initial injections on each retry\n      for (let injectionIDX=0; injectionIDX<this._httpInjections.length; injectionIDX++) {\n        const injection = this._httpInjections[injectionIDX];\n\n        // check if the domain matches\n        if (injection.filter(urlFilter)) {\n          await injection.func(method, url, data, options);\n        }\n      }\n\n      // record some stats for the optional HAR Writer\n      const startMs = +new Date();\n      const startTime = moment(startMs).toISOString();\n\n      return needle(method, url, data, options).then(async (resp) => {\n        // intercept response to write to our .har file\n        if (harWriter) {\n          await writeToHAR(method, url, data, options, resp, startTime, (+new Date()) - startMs);\n        }\n\n        // call any response injections\n        for (let injectionIDX=0; injectionIDX<this._httpResponseInjections.length; injectionIDX++) {\n          const injection = this._httpResponseInjections[injectionIDX];\n\n          // check if the domain matches\n          // (reuse urlFilter from the incoming injections)\n          if (injection.filter(urlFilter)) {\n            resp = await injection.func(resp);\n          }\n        }\n\n        // if our response if now undefined, retry our request\n        if (resp === undefined) {\n          return retryFn();\n        }\n\n        // if we got an error code, retry our request\n        if (!options.ignoreErrors && resp.statusCode >= 400) {\n          return retryFn();\n        }\n\n        return resp;\n      });\n    });\n  };\n\n  /**\n   * Register a new injection for a specific domain\n   * @param {object} filter Mongo-type query to use to match a URL\n   * @param {function} func Function to call with needle request to inject extra data into.\n   * Function will take arguments: (method, URL, data, options)\n   */\n  mainFunction.injectForDomain = (filter, func) => {\n    // add to our array of injections, this is processing by HTTP()\n    this._httpInjections.push({\n      filter: sift(filter),\n      func,\n    });\n  };\n\n  /**\n   * Register a new response injection for a specific domain\n   * @param {object} filter Mongo-type query to use to match a URL\n   * @param {function} func Function to call with needle response object to make changes\n   * Function will take arguments: (response)\n   * Function *must* return the response object back, or undefined if you want to force a retry\n   */\n  mainFunction.injectForDomainResponse = (filter, func) => {\n    this._httpResponseInjections.push({\n      filter: sift(filter),\n      func,\n    });\n  };\n\n  return mainFunction;\n});\n\n\nexport default HTTP;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/http.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 186,
    "kind": "function",
    "name": "generateRandomAndroidUseragent",
    "memberof": "lib/parks/http.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/http.js~generateRandomAndroidUseragent",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/http.js",
    "importStyle": "{generateRandomAndroidUseragent}",
    "description": "Generate a random Android user agent for making network requests",
    "lineNumber": 12,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 187,
    "kind": "variable",
    "name": "harWriter",
    "memberof": "lib/parks/http.js",
    "static": true,
    "longname": "lib/parks/http.js~harWriter",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/http.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 188,
    "kind": "function",
    "name": "writeToHAR",
    "memberof": "lib/parks/http.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/parks/http.js~writeToHAR",
    "access": "private",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/http.js",
    "importStyle": null,
    "description": "Write a HTTP response to HAR file for debugging",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "resp",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "startTime",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "timeTaken",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 189,
    "kind": "function",
    "name": "HTTP",
    "memberof": "lib/parks/http.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/http.js~HTTP",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/http.js",
    "importStyle": "{HTTP}",
    "description": "HTTP helper with injection",
    "lineNumber": 89,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 190,
    "kind": "file",
    "name": "lib/parks/park.js",
    "content": "import promiseRetry from 'promise-retry';\nimport Entity from './entity.js';\nimport moment from 'moment-timezone';\nimport Cache from '../cache/scopedCache.js';\nimport * as tags from './tags.js';\nimport {reusePromise, reusePromiseForever} from '../reusePromises.js';\nimport {queueType, returnTimeState} from './parkTypes.js';\n\n// quick helper function to wait x milliseconds as a Promise\nconst delay = (milliseconds) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n};\n\n/**\n * Base Park Object\n * @class\n */\nexport class Park extends Entity {\n  /**\n   * Create a new park object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    // how often to wait between updates to run another update\n    options.updateInterval = 1000 * 60 * 5; // 5 minutes\n    // disable auto-update for this object\n    //  set this if the update is being handled by an external system\n    options.disableParkUpdate = false;\n\n    super(options);\n\n    // create a new cache object for this park\n    this.cache = new Cache(this.constructor.name, this.config.cacheVersion || 0);\n\n    this.initialised = false;\n    this.hasRunPostInit = false;\n    this.hasRunUpdate = false;\n    this._pendingTags = {};\n\n    this._attractions = [];\n\n    // track the park's current date\n    //  we'll fire an event whenever this changes\n    this._currentDate = null;\n\n    // make attractions and calendar functions work offline\n    this.registerOfflineFunction('getAttractions');\n    this.registerOfflineFunction('getCalendar');\n  }\n\n  /**\n   * Call this to shutdown the park object.\n   * This is an async call, so wait until it has resolved to continue.\n   */\n  async shutdown() {\n    // disable any park updates\n    this.config.disableParkUpdate = true;\n  }\n\n  /**\n   * Get a globally unique ID for this park\n   * @return {string}\n   */\n  getParkUniqueID() {\n    return this.getUniqueID();\n  }\n\n  /**\n   * Get Park Attractions\n   */\n  async getAttractions() {\n    await this.ensureReady();\n\n    return this._attractions;\n  }\n\n  /**\n   * Setup the park for use\n   * Call to ensure the object has been initialised before accessing data\n   */\n  async init() {\n    // skip init if we're offline\n    if (this.offline) {\n      this.initialised = true;\n      this.hasRunUpdate = true;\n      return;\n    }\n\n    await reusePromiseForever(this, this._runInit);\n    if (!this.hasRunPostInit) {\n      this.hasRunPostInit = true;\n      await this._postInit();\n    }\n  }\n\n  /**\n   * @inheritdocs\n   */\n  async _postOfflineLoad() {\n    await this.postUpdate();\n  }\n\n  /**\n   * Run all the internal stages of the init process\n   * @private\n   */\n  async _runInit() {\n    try {\n      await this._init();\n      this.initialised = true;\n\n      if (!this.config.disableParkUpdate && !this.offline) {\n        // start an update loop\n\n        // use a separate function so we can quickly loop back around\n        const scheduleUpdate = async () => {\n          // pause for our updateInterval time\n          await delay(this.config.updateInterval);\n\n          // if our udpates get disabled during our timer, then skip and exit our\n          if (this.config.disableParkUpdate) return;\n\n          // wait for Promise to resolve, grab any catches, then continue anyway\n          this.update().then().catch().then(() => {\n            if (this.config.disableParkUpdate) return;\n\n            // schedule another update\n            setImmediate(scheduleUpdate.bind(this));\n          });\n        };\n\n        // start the first loop timer\n        scheduleUpdate();\n      }\n    } catch (e) {\n      console.error('Error initialising park', e);\n    }\n  }\n\n  /**\n   * Awaits until park is initalised and has run at least one update.\n   * @return {Promise}\n   */\n  async ensureReady() {\n    await this.init();\n\n    if (!this.hasRunUpdate) {\n      await this.update();\n    }\n\n    await this.ensureHasOfflineData();\n  }\n\n  /**\n   * Cache an attraction\n   * @param {string} attractionID ID of the attraction to be cached\n   */\n  async cacheAttractionObject(attractionID) {\n    // find our attraction\n    //  don't call the standard \"find\" function, as this will also create the object\n    //  we don't want to actually create ths attraction if it doesn't exist, just ignore it\n    const uniqueAttractionID = `${this.getParkUniqueID()}_${attractionID}`;\n    const attraction = this._attractions.find((attr) => attr.id == uniqueAttractionID);\n    if (attraction !== undefined) {\n      await this.cache.set(uniqueAttractionID, attraction, Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  /**\n   * Build an object representing an attraction from sourced data\n   * This object should not contain any \"state\" data, just static information about the attraction\n   * @param {string} attractionID Unique Attraction ID\n   * @return {object} Object containing at least 'name'.\n   * Also accepts 'type', which is an {@link attractionType}\n   */\n  async _buildAttractionObject(attractionID) {\n    throw new Error('Missing _buildAttractionObject Implementation', this.constructor.name);\n  }\n\n  /**\n   * Get the attraction object for a given ID (skips all generation/safety checks etc,)\n   * @param {string} attractionID\n   * @return {object}\n   * @private\n   */\n  _getAttractionByIDInternal(attractionID) {\n    // search our existing store for this attraction\n    const attraction = this._attractions.find((attr) => attr.rideId == attractionID);\n    if (attraction) {\n      return attraction;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get data about a attraction from its ID\n   * @param {string} attractionID Unique Attraction ID\n   * @return {object} The attraction object for the given ID, or undefined\n   */\n  async findAttractionByID(attractionID) {\n    // wrap our actual function so multiple calls will return the same object\n    return await reusePromise(this, this._findAttractionByID, `${attractionID}`);\n  }\n\n  /**\n   * Get data about a attraction from its ID\n   * @param {string} attractionID Unique Attraction ID\n   * @return {object} The attraction object for the given ID, or undefined\n   * @private\n   */\n  async _findAttractionByID(attractionID) {\n    // search our existing store for this attraction\n    const attraction = this._getAttractionByIDInternal(attractionID);\n    if (attraction) {\n      return attraction;\n    }\n\n    // build a unique attraction ID by prefixing the park's unique ID\n    const uniqueAttractionID = `${this.getParkUniqueID()}_${attractionID}`;\n\n    // attraction wasn't found, try and add one to our store\n    const newAttraction = {\n      id: uniqueAttractionID,\n      // TODO - rename to attractionID\n      rideId: attractionID, // unique attraction ID without the park prefix\n      name: undefined,\n      type: null,\n      status: {\n        status: null,\n        lastUpdated: null,\n        lastChanged: null,\n      },\n      queue: {},\n      tags: [],\n    };\n\n    // list of fields we want to accept from the park class\n    //  we don't want the park to add random fields to our attraction object\n    //  park-specific data should be added using \"tags\" instead, so our object structure is the same for all parks\n    const fieldsToCopyFromParkClass = [\n      'name',\n      'type', // TODO - rename this to attractionType, or some other morphing type based on entityType\n      'entityType', // TODO - validate incoming types\n    ];\n\n    // restore stored live attraction data from a cache\n    //  restore from cache *before* we build the actual attraction data\n    //  this will allow the park API to fill in any out-of-date fields with live data\n    const cachedAttraction = await this.cache.get(uniqueAttractionID);\n    if (cachedAttraction !== undefined) {\n      Object.keys(cachedAttraction).forEach((key) => {\n        // TODO - do we need to do anyhting special here for sub-fields?\n        if (key === 'tags') {\n          // TODO - re-validate tags\n        }\n        newAttraction[key] = cachedAttraction[key];\n      });\n    }\n\n    // ask the park implementation to supply us with some basic attraction information (name, type, etc.)\n    //  we'll then inject this into our attraction object, assuming it returns successfully\n    try {\n      const builtAttractionObject = {\n        // clone the object, to ensure we don't mess with the original\n        ...(await this._buildAttractionObject(attractionID)),\n      };\n      if (builtAttractionObject !== undefined && !!builtAttractionObject.name) {\n        // clear out any _src data (if present)\n        delete builtAttractionObject._src;\n\n        // add to our attractions array once we've got a valid attraction (not undefined) from child class\n        this._attractions.push(newAttraction);\n\n        // copy fields we're interested in into our new attraction object\n        fieldsToCopyFromParkClass.forEach((key) => {\n          if (builtAttractionObject[key] !== undefined) {\n            newAttraction[key] = builtAttractionObject[key];\n          }\n        });\n\n        const tags = (this._pendingTags[attractionID] || []).concat(builtAttractionObject.tags || []);\n        delete this._pendingTags[attractionID];\n\n        // we also manually accept the \"tags\" field\n        //  add each tag to the attraction after it's added to our object above\n        await Promise.allSettled(tags.map((tag) => {\n          return this.setAttractionTag(attractionID, tag.key, tag.type, tag.value);\n        }));\n\n        // cache attraction object so it can be restored quickly on future app intialisations\n        await this.cacheAttractionObject(attractionID);\n\n        return newAttraction;\n      }\n    } catch (e) {\n      this.emit('error', e);\n      console.error('Error building attraction object:', e);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Remove a tag from a given attraction ID\n   * @param {string} attractionID\n   * @param {string} key\n   * @param {tagType} type\n   */\n  async removeAttractionTag(attractionID, key, type) {\n    const attraction = await this._getAttractionByIDInternal(attractionID);\n    if (!attraction) return;\n\n    const existingTag = attraction.tags.findIndex((t) => t.key === key && t.type === type);\n    if (existingTag >= 0) {\n      attraction.tags.splice(existingTag, 1);\n      await this.cacheAttractionObject(attractionID);\n    }\n  }\n\n  /**\n   * Set a toggle tag for an attraction.\n   * This is different from more complex tags that expect a data structure.\n   * Use this for tags that don't have any actual value, but are just present. Eg. FastPass as a feature.\n   * @param {string} attractionID\n   * @param {tagType} type\n   * @param {boolean} value\n   */\n  async toggleAttractionTag(attractionID, type, value) {\n    return await this.setAttractionTag(attractionID, null, type, value);\n  }\n\n  /**\n   * Set an attraction tag\n   * Used for metadata on rides, such as location, thrill level, fastpass availability etc.\n   * @param {string|object} attractionID Attraction ID to update (or the actual object)\n   * @param {string} key Tag key to set\n   * @param {tagType} type Tag type to use\n   * @param {*} value Tag value to set\n   * @return {boolean} True if tag was stored successfully\n   */\n  async setAttractionTag(attractionID, key, type, value) {\n    // validate tag value\n    const newTag = tags.getValidTagObject(key, type, value);\n    if (newTag === undefined) {\n      return false;\n    }\n\n    // different path for simple tags that are being removed\n    if (tags.isSimpleTagType(type) && !value) {\n      // if value is false, remove the key\n      return await this.removeAttractionTag(attractionID, newTag.key, type);\n    }\n\n    // find attraction and apply tag to it\n    const attraction = await this._getAttractionByIDInternal(attractionID);\n    if (attraction) {\n      const existingTag = attraction.tags.findIndex((t) => t.key === newTag.key && t.type === newTag.type);\n      if (existingTag < 0) {\n        // push our new tag onto our attraction\n        attraction.tags.push(newTag);\n      } else {\n        // update existing tag entry\n        attraction.tags[existingTag] = newTag;\n      }\n      await this.cacheAttractionObject(attractionID);\n      return true;\n    } else {\n      // attraction isn't valid. Push to our pending array to process when/if it does become valid\n      this._pendingTags[attractionID] = [{key, type, value}].concat(\n          this._pendingTags[attractionID] || [],\n      );\n    }\n\n    return false;\n  }\n\n  /**\n   * Update an attraction state\n   * @param {string} attractionID Unique Attraction ID\n   * @param {statusType} status New Attraction state\n   */\n  async updateAttractionState(attractionID, status) {\n    if (attractionID === undefined) return;\n\n    const existingRide = await this.findAttractionByID(attractionID);\n    if (existingRide) {\n      // if we found a matching attraction, update its \"state\" property with our new data\n      const now = this.getTimeNow();\n\n      // last updated is always kept up-to-date, regardless of whether the data changed\n      existingRide.status.lastUpdated = now;\n\n      // only update \"lastChanged\" if the status has changed\n      const previousStatus = existingRide.status.status;\n      if (previousStatus !== status || existingRide.status.lastChanged === null) {\n        existingRide.status.status = status;\n        existingRide.status.lastChanged = now;\n\n        // broadcast updated ride event\n        //  try to make sure we have updated everything before we fire this event\n        this.emit('attractionStatus', existingRide, previousStatus);\n      }\n\n      // write updated attraction data to cache\n      await this.cacheAttractionObject(attractionID);\n    }\n  }\n\n  /**\n   * Update the queue status for an attraction\n   * @param {string} attractionID Attraction ID to update\n   * @param {number|object} queueValue Updated Wait Time in minutes, or null if wait time doesn't exist or isn't valid.\n   * Set waitTime to undefined to remove this queue type from the attraction.\n   * BoardingGroup and ReturnTime types expect an object containing queue details instead of a number\n   * @param {queueType} type Type of queue to update (standup, virtual, fastpass etc.)\n   */\n  async updateAttractionQueue(attractionID, queueValue = undefined, type = type.standBy) {\n    if (attractionID === undefined) return;\n\n    const existingRide = await this.findAttractionByID(attractionID);\n    if (existingRide) {\n      if (!existingRide.queue) {\n        existingRide.queue = {};\n      }\n\n      // edge-case, if we supply undefined, the queue has been removed\n      //  (or never existed and we're just double-checking it's not present)\n      if (queueValue === undefined) {\n        if (existingRide.queue[type] !== undefined) {\n          const previousWaitTime = existingRide.queue[type].waitTime;\n          delete existingRide.queue[type];\n\n          // fire event anyway, the queue has technically been updated (it's just not present at all now)\n          this.emit('attractionQueue', existingRide, type, previousWaitTime);\n\n          await this.cacheAttractionObject(attractionID);\n        }\n\n        // don't continue operations, early exit here\n        return;\n      }\n\n      if (!existingRide.queue[type]) {\n        existingRide.queue[type] = {\n          lastUpdated: null,\n          lastChanged: null,\n        };\n\n        if (type === queueType.standBy) {\n          // default standby state\n          existingRide.queue[type].waitTime = null;\n        } else if (type === queueType.returnTime) {\n          // default return time state\n          existingRide.queue[type].returnStart = null;\n          existingRide.queue[type].returnEnd = null;\n          existingRide.queue[type].state = null;\n        }\n      }\n\n      const queueData = existingRide.queue[type];\n\n      const now = this.getTimeNow();\n\n      if (type == queueType.standBy || type == queueType.singleRider) {\n        // wait times must be a positive number (in minutes)\n        //  if wait time is unknown (because it is not tracker or there is some issue), waitTime should be null\n        const newWaitTime = (isNaN(queueValue) || queueValue < 0) ? null : queueValue;\n        const previousWaitTime = queueData.waitTime;\n\n        // store last updated time\n        queueData.lastUpdated = now;\n\n        if (newWaitTime !== previousWaitTime || queueData.lastChanged === null) {\n          queueData.waitTime = newWaitTime;\n          queueData.lastChanged = now;\n\n          // broadcast updated ride event\n          //  try to make sure we have updated everything before we fire this event\n          this.emit('attractionQueue', existingRide, type, previousWaitTime);\n        }\n      } else if (type == queueType.returnTime) {\n        // handle \"return time\" style queue updates\n        // validate incoming data\n        if (\n          queueValue?.returnStart === undefined ||\n          queueValue?.returnEnd === undefined ||\n          // state can be null for \"unknown\" states\n          (queueValue?.state !== null && Object.values(returnTimeState).indexOf(queueValue?.state) < 0)\n        ) {\n          this.emit(\n              'error',\n              new Error(`Invalid return time object used ${JSON.stringify(queueValue)} (${attractionID})`),\n          );\n          return;\n        }\n\n        // make sure we're moment formatted strings\n        queueValue.returnStart = queueValue.returnStart === null ? null :\n          moment.tz(queueValue.returnStart, this.config.timezone).format();\n        queueValue.returnEnd = queueValue.returnEnd === null ? null :\n          moment.tz(queueValue.returnEnd, this.config.timezone).format();\n\n        const originalReturnTime = {\n          returnStart: queueData?.returnStart,\n          returnEnd: queueData?.returnEnd,\n          state: queueData?.state,\n        };\n\n        // mark data as \"updated\", even if it hasn't changed\n        queueData.lastUpdated = now;\n\n        if (\n          queueValue.returnStart != originalReturnTime.returnStart ||\n          queueValue.returnEnd != originalReturnTime.returnEnd ||\n          queueValue.state != originalReturnTime.state\n        ) {\n          // return time has changed!\n          queueData.returnStart = queueValue.returnStart;\n          queueData.returnEnd = queueValue.returnEnd;\n          queueData.state = queueValue.state;\n          queueData.lastChanged = now;\n\n          // broadcast updated ride event\n          this.emit('attractionQueue', existingRide, type, originalReturnTime);\n        }\n      } else if (type == queueType.boardingGroup) {\n        // TODO - handle baording group style queues\n        return;\n      }\n\n      // write updated attraction data to cache\n      await this.cacheAttractionObject(attractionID);\n    }\n  }\n\n  /**\n   * Called after each successful update, handle any clean-up or extra work here\n   * @private\n   */\n  async postUpdate() {\n    // check if our date has changed\n    await this._checkDate();\n  }\n\n  /**\n   * Update this park\n   * This is automatically called for you unless disableParkUpdate is set to false\n   */\n  async update() {\n    return reusePromise(this, this._runUpdate);\n  }\n\n  /**\n   * Internal method to actually run our update\n   * @private\n   */\n  async _runUpdate() {\n    // wait and catch the update Promise\n    try {\n    // start the _update call in a retry loop\n      await promiseRetry({\n        retries: 5,\n      }, (retryFn) => {\n        return this._update().catch(retryFn);\n      });\n    } catch (e) {\n      // emit error and print to screen\n      console.error('Error running _update()', e);\n      this.emit('error', e);\n      return;\n    }\n\n    this.hasRunUpdate = true;\n\n    try {\n      await this.postUpdate();\n    } catch (e) {\n      console.error('Error running postUpdate()', e);\n      this.emit('error', e);\n    }\n  }\n\n  /**\n   * Called when the park's date changes\n   * Eg. when passing midnight in the park's local timezone\n   *  or if late opening hours finish the morning after (eg. open until 2am, will be called just after 2am)\n   * @param {string} newDate Current Park Date\n   * @param {string} oldDate The previous date for this park before the update (can be null if park just initialised)\n   * @abstract\n   */\n  async _dateRefresh(newDate, oldDate) {}\n\n  /**\n   * Check if the park's \"active date\" has changed\n   */\n  async _checkDate() {\n    const todaysDate = await this.getActiveParkDate();\n    if (this._currentDate !== todaysDate) {\n      // store the previous date and update the current date immediately\n      //  this makes sure the park object is in the correct state before firing the newDate events\n      const originalDate = this._currentDate;\n      this._currentDate = todaysDate;\n\n      // broadcast event when the park's day changes\n      //  we can use this to update ride schedules etc.\n      await this._dateRefresh(todaysDate, originalDate);\n      this.emit('newDate', todaysDate, originalDate);\n    }\n  }\n\n  /**\n   * Internal function\n   * Called by init() to initialise the object\n   * @private\n   * @abstract\n   */\n  async _init() {\n    // implementation should be setup in child classes\n    throw new Error('_init() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Internal function\n   * Called by init() to initialise the object\n   * @private\n   * @abstract\n   */\n  async _postInit() {\n    // implementation should be setup in child classes\n  }\n\n  /**\n   * Update function the park object calls on interval to update internal state\n   * @private\n   * @abstract\n   */\n  async _update() {\n    // implementation should be setup in child classes\n    throw new Error('_update() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Given a moment date, return an array of opening hours for this park, or undefined\n   * Each entry should contain openingTime, closingTime, and type (of scheduleType)\n   * @param {moment} date\n   * @private\n   * @abstract\n   */\n  async _getOperatingHoursForDate(date) {\n    // implementation should be setup in child classes\n    throw new Error('_getOperatingHoursForDate() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Get the operating hours for the supplied date\n   * Will return undefined if the park API cannot return data for this date\n   *  (park is closed, too far in future, too far in past, etc.)\n   * @param {moment} date A momentjs object\n   * @return {object}\n   */\n  async getOperatingHoursForDate(date) {\n    // cache each calendar date to avoid recalculating it all the time\n    return this.cache.wrap(`calendar_${date.format('YYYY-MM-DD')}`, async () => {\n      return await this._getOperatingHoursForDate(date);\n    }, 1000 * 60 * 60 * 6); // cache for 6 hours\n  }\n\n  /**\n   * Given a moment date, return an array of opening hours for the restaurants in this park, or undefined\n   * Ech entry should contain openingTime closingTime\n   * @param {moment} date\n   */\n  async _getRestaurantOperatingHoursForDate(date) {\n    // implementation should be setup in child classes\n    throw new Error('_getRestaurantOperatingHoursForDate() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Get the restaurant operating hours for the supplied date\n   * @param {moment} date\n   */\n  async getRestaurantOperatingHoursForDate(date) {\n    return this.cache.wrap(`restaurant_${date.format('YYYY-MM-DD')}`, async () => {\n      return await this._getRestaurantOperatingHoursForDate(date);\n    }, 1000 * 60 * 60 * 6); // cache for 6 hours\n  }\n\n  /**\n   * Get Operating Calendar for this park\n   * @return{object} Object keyed to dates in YYYY-MM-DD format.\n   * Each date entry will contain an array of operating hours.\n   */\n  async getCalendar() {\n    try {\n      // make sure the park is initialised before continuing\n      await this.init();\n\n      // populate from yesterday onwards (if the API even gives us yesterday)\n      //  try to catch weird edge-cases where we're just past midnight but the park is still open\n      const yesterday = this.getTimeNowMoment().subtract(1, 'days');\n      // populate forward up to 60 days\n      const endFillDate = yesterday.clone().add(60 + 1, 'days');\n\n      const now = this.getTimeNowMoment();\n\n      const dates = {};\n      // get calendar by looping over each date\n      for (let date = yesterday; date.isSameOrBefore(endFillDate); date.add(1, 'day')) {\n        const hours = await this.getOperatingHoursForDate(date);\n        if (hours !== undefined) {\n          if (!Array.isArray(hours)) {\n            this.emit(\n                'error',\n                new Error(\n                    // eslint-disable-next-line max-len\n                    `Hours for ${this.name} date ${date.format('YYYY-MM-DD')} returned invalid non-Array ${JSON.stringify(hours)}`,\n                ),\n            );\n            continue;\n          }\n          // ignore if we're not within the operating hours AND the date is in the past\n          //  this will strip out yesterday once we've left that day's opening hours\n          const isInsideAnyDateHours = hours.find((h) => {\n            return now.isBetween(h.openingTime, h.closingTime);\n          });\n          if (now.isAfter(date, 'day') && isInsideAnyDateHours === undefined) {\n            continue;\n          }\n          dates[date.format('YYYY-MM-DD')] = hours;\n        }\n      }\n\n      return dates;\n    } catch (err) {\n      console.error('Error getting calendar', err);\n      this.emit('error', err);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Return the number of milliseconds until the next time the park is open.\n   * Will return 0 if park is already open.\n   * @return{number} Milliseconds until the park is open\n   */\n  async getNextOpeningTime() {\n    const calendar = await this.getCalendar();\n    const now = this.getTimeNowMoment();\n\n    const dates = Object.keys(calendar);\n    const nextOpeningTime = dates.reduce((p, date) => {\n      return Math.min(p, calendar[date].reduce((p2, time) => {\n        const msUntilOpening = moment(time.openingTime).diff(now);\n        // if the opening time is in the past, is the closing time in the future?\n        if (msUntilOpening <= 0) {\n          if (moment(time.closingTime).diff(now) > 0) {\n            return 0;\n          } else {\n            // otherwise this entire time block is in the past, ignore it\n            return p2;\n          }\n        }\n        return Math.min(p2, msUntilOpening);\n      }, Number.MAX_SAFE_INTEGER));\n    }, Number.MAX_SAFE_INTEGER);\n\n    return nextOpeningTime === Number.MAX_SAFE_INTEGER ? null : nextOpeningTime;\n  }\n\n  /**\n   * Return the number of milliseconds until closing time. Or 0 if already closed.\n   * @return {number}\n   */\n  async getNextClosingTime() {\n    const today = await this.getCalendarForToday();\n    if (today !== undefined) {\n      const now = this.getTimeNowMoment();\n      const closingTime = today.reduce((p, hours) => {\n        if (!now.isBetween(hours.openingTime, hours.closingTime)) {\n          return 0;\n        }\n\n        return Math.max(moment(hours.closingTime).diff(now), p);\n      }, 0);\n\n      return closingTime;\n    }\n    return 0;\n  }\n\n  /**\n   * Return the time until the park is open.\n   * @return{momentDuration} Time until park opens as a Moment Duration.\n   * Zero if already open, or null if unable to find time\n   */\n  async getNextOpeningTimeMomentDuration() {\n    const ms = await this.getNextOpeningTime();\n\n    if (ms === null) return null;\n    return moment.duration(ms, 'milliseconds');\n  }\n\n  /**\n   * Get the current park date, taking into consideration park hours past midnight etc.\n   * Eg. if the park is open past midnight, return yesterday's date.\n   * @return{moment} Park's \"active date\" as a Moment object\n   */\n  async getActiveParkDateMoment() {\n    const calendar = await this.getCalendar();\n\n    const nowInPark = moment(this.getTimeNow()).tz(this.config.timezone);\n    // check yesterday, today, and tomorrow to find any park hours that we're currently in\n    //  (including any extra hours etc.)\n    //  we will fall-back to the current date if none of these match\n    const isInParkHours = [\n      nowInPark.clone().add(-1, 'day'),\n      nowInPark,\n      nowInPark.clone().add(1, 'day'),\n    ].map((date) => {\n      // build array of our park calendar entries\n      return {\n        date,\n        data: calendar[date.format('YYYY-MM-DD')],\n      };\n    }).filter((parkHours) => {\n      // filter out any park hours that doesn't include the current time\n      if (!parkHours.data) return false;\n      const isInAnyParkHours = parkHours.data.find((hours) => {\n        return (nowInPark.isBetween(moment(hours.openingTime), moment(hours.closingTime)));\n      });\n      return !!isInAnyParkHours;\n    });\n\n    if (isInParkHours.length === 0) {\n      // just return today's calendar\n      return nowInPark;\n    }\n    // otherwise return the hours that we currently match\n    return isInParkHours[0].date;\n  }\n\n  /**\n   * Get the current park date, taking into consideration park hours past midnight etc.\n   * Eg. if the park is open past midnight, return yesterday's date.\n   * @return{string} Date in YYYY-MM-DD format\n   */\n  async getActiveParkDate() {\n    return (await this.getActiveParkDateMoment()).format('YYYY-MM-DD');\n  }\n\n  /**\n   * Get the park opening hours for today\n   */\n  async getCalendarForToday() {\n    const todaysDate = await this.getActiveParkDate();\n    const calendar = await this.getCalendar();\n    return calendar[todaysDate];\n  }\n\n  /**\n   * Get the park opening hours for tomorrow\n   */\n  async getCalendarForTomorrow() {\n    const todaysDate = await this.getActiveParkDate();\n    const tomorrow = moment(todaysDate, 'YYYY-MM-DD').add(1, 'day');\n    const calendar = await this.getCalendar();\n    return calendar[tomorrow.format('YYYY-MM-DD')];\n  }\n}\n\nexport default Park;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/park.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 191,
    "kind": "function",
    "name": "delay",
    "memberof": "lib/parks/park.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/park.js~delay",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/park.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "milliseconds",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 192,
    "kind": "class",
    "name": "Park",
    "memberof": "lib/parks/park.js",
    "static": true,
    "longname": "lib/parks/park.js~Park",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/park.js",
    "importStyle": "{Park}",
    "description": "Base Park Object",
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "lib/parks/entity.js~Entity"
    ]
  },
  {
    "__docId__": 193,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/park.js~Park#constructor",
    "access": "public",
    "description": "Create a new park object",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 194,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#cache",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "member",
    "name": "initialised",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#initialised",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "member",
    "name": "hasRunPostInit",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#hasRunPostInit",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "member",
    "name": "hasRunUpdate",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#hasRunUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "member",
    "name": "_pendingTags",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#_pendingTags",
    "access": "private",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "member",
    "name": "_attractions",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#_attractions",
    "access": "private",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "_currentDate",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#_currentDate",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "method",
    "name": "shutdown",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#shutdown",
    "access": "public",
    "description": "Call this to shutdown the park object.<br />This is an async call, so wait until it has resolved to continue.",
    "lineNumber": 57,
    "params": [],
    "return": null
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "getParkUniqueID",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/park.js~Park#getParkUniqueID",
    "access": "public",
    "description": "Get a globally unique ID for this park",
    "lineNumber": 66,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "getAttractions",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getAttractions",
    "access": "public",
    "description": "Get Park Attractions",
    "lineNumber": 73,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "init",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#init",
    "access": "public",
    "description": "Setup the park for use<br />Call to ensure the object has been initialised before accessing data",
    "lineNumber": 83,
    "params": [],
    "return": null
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "_postOfflineLoad",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_postOfflineLoad",
    "access": "private",
    "description": "",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@inheritdocs",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "_runInit",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_runInit",
    "access": "private",
    "description": "Run all the internal stages of the init process",
    "lineNumber": 109,
    "params": [],
    "return": null
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "ensureReady",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#ensureReady",
    "access": "public",
    "description": "Awaits until park is initalised and has run at least one update.",
    "lineNumber": 146,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "cacheAttractionObject",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#cacheAttractionObject",
    "access": "public",
    "description": "Cache an attraction",
    "lineNumber": 160,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "ID of the attraction to be cached"
      }
    ],
    "return": null
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_buildAttractionObject",
    "access": "private",
    "description": "Build an object representing an attraction from sourced data<br />This object should not contain any \"state\" data, just static information about the attraction",
    "lineNumber": 178,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Object containing at least 'name'.\nAlso accepts 'type', which is an {@link attractionType}"
    }
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "_getAttractionByIDInternal",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/park.js~Park#_getAttractionByIDInternal",
    "access": "private",
    "description": "Get the attraction object for a given ID (skips all generation/safety checks etc,)",
    "lineNumber": 188,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "findAttractionByID",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#findAttractionByID",
    "access": "public",
    "description": "Get data about a attraction from its ID",
    "lineNumber": 202,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The attraction object for the given ID, or undefined"
    }
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "_findAttractionByID",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_findAttractionByID",
    "access": "private",
    "description": "Get data about a attraction from its ID",
    "lineNumber": 213,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The attraction object for the given ID, or undefined"
    }
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "removeAttractionTag",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#removeAttractionTag",
    "access": "public",
    "description": "Remove a tag from a given attraction ID",
    "lineNumber": 311,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "toggleAttractionTag",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#toggleAttractionTag",
    "access": "public",
    "description": "Set a toggle tag for an attraction.<br />This is different from more complex tags that expect a data structure.<br />Use this for tags that don't have any actual value, but are just present. Eg. FastPass as a feature.",
    "lineNumber": 330,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "setAttractionTag",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#setAttractionTag",
    "access": "public",
    "description": "Set an attraction tag<br />Used for metadata on rides, such as location, thrill level, fastpass availability etc.",
    "lineNumber": 343,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Attraction ID to update (or the actual object)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Tag key to set"
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "Tag type to use"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Tag value to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if tag was stored successfully"
    }
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "updateAttractionState",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#updateAttractionState",
    "access": "public",
    "description": "Update an attraction state",
    "lineNumber": 384,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      },
      {
        "nullable": null,
        "types": [
          "statusType"
        ],
        "spread": false,
        "optional": false,
        "name": "status",
        "description": "New Attraction state"
      }
    ],
    "return": null
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "updateAttractionQueue",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#updateAttractionQueue",
    "access": "public",
    "description": "Update the queue status for an attraction",
    "lineNumber": 419,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Attraction ID to update"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "queueValue",
        "description": "Updated Wait Time in minutes, or null if wait time doesn't exist or isn't valid.\nSet waitTime to undefined to remove this queue type from the attraction.\nBoardingGroup and ReturnTime types expect an object containing queue details instead of a number"
      },
      {
        "nullable": null,
        "types": [
          "queueType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "Type of queue to update (standup, virtual, fastpass etc.)"
      }
    ],
    "return": null
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "postUpdate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#postUpdate",
    "access": "private",
    "description": "Called after each successful update, handle any clean-up or extra work here",
    "lineNumber": 542,
    "params": [],
    "return": null
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "update",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#update",
    "access": "public",
    "description": "Update this park<br />This is automatically called for you unless disableParkUpdate is set to false",
    "lineNumber": 551,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "_runUpdate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_runUpdate",
    "access": "private",
    "description": "Internal method to actually run our update",
    "lineNumber": 559,
    "params": [],
    "return": null
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "_dateRefresh",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_dateRefresh",
    "access": "private",
    "description": "Called when the park's date changes<br />Eg. when passing midnight in the park's local timezone<br /> or if late opening hours finish the morning after (eg. open until 2am, will be called just after 2am)",
    "lineNumber": 593,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "newDate",
        "description": "Current Park Date"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "oldDate",
        "description": "The previous date for this park before the update (can be null if park just initialised)"
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "_checkDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_checkDate",
    "access": "private",
    "description": "Check if the park's \"active date\" has changed",
    "lineNumber": 598,
    "params": [],
    "return": null
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_init",
    "access": "private",
    "description": "Internal function<br />Called by init() to initialise the object",
    "lineNumber": 619,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "_postInit",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_postInit",
    "access": "private",
    "description": "Internal function<br />Called by init() to initialise the object",
    "lineNumber": 630,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_update",
    "access": "private",
    "description": "Update function the park object calls on interval to update internal state",
    "lineNumber": 639,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "_getOperatingHoursForDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_getOperatingHoursForDate",
    "access": "private",
    "description": "Given a moment date, return an array of opening hours for this park, or undefined<br />Each entry should contain openingTime, closingTime, and type (of scheduleType)",
    "lineNumber": 651,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "getOperatingHoursForDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getOperatingHoursForDate",
    "access": "public",
    "description": "Get the operating hours for the supplied date<br />Will return undefined if the park API cannot return data for this date<br /> (park is closed, too far in future, too far in past, etc.)",
    "lineNumber": 663,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "A momentjs object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "_getRestaurantOperatingHoursForDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_getRestaurantOperatingHoursForDate",
    "access": "private",
    "description": "Given a moment date, return an array of opening hours for the restaurants in this park, or undefined<br />Ech entry should contain openingTime closingTime",
    "lineNumber": 675,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "getRestaurantOperatingHoursForDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getRestaurantOperatingHoursForDate",
    "access": "public",
    "description": "Get the restaurant operating hours for the supplied date",
    "lineNumber": 684,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "getCalendar",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getCalendar",
    "access": "public",
    "description": "Get Operating Calendar for this park<br />@return{object} Object keyed to dates in YYYY-MM-DD format.<br />Each date entry will contain an array of operating hours.",
    "lineNumber": 695,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "getNextOpeningTime",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getNextOpeningTime",
    "access": "public",
    "description": "Return the number of milliseconds until the next time the park is open.<br />Will return 0 if park is already open.<br />@return{number} Milliseconds until the park is open",
    "lineNumber": 749,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "getNextClosingTime",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getNextClosingTime",
    "access": "public",
    "description": "Return the number of milliseconds until closing time. Or 0 if already closed.",
    "lineNumber": 777,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "getNextOpeningTimeMomentDuration",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getNextOpeningTimeMomentDuration",
    "access": "public",
    "description": "Return the time until the park is open.<br />@return{momentDuration} Time until park opens as a Moment Duration.<br />Zero if already open, or null if unable to find time",
    "lineNumber": 799,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "getActiveParkDateMoment",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getActiveParkDateMoment",
    "access": "public",
    "description": "Get the current park date, taking into consideration park hours past midnight etc.<br />Eg. if the park is open past midnight, return yesterday's date.<br />@return{moment} Park's \"active date\" as a Moment object",
    "lineNumber": 811,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "getActiveParkDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getActiveParkDate",
    "access": "public",
    "description": "Get the current park date, taking into consideration park hours past midnight etc.<br />Eg. if the park is open past midnight, return yesterday's date.<br />@return{string} Date in YYYY-MM-DD format",
    "lineNumber": 850,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "method",
    "name": "getCalendarForToday",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getCalendarForToday",
    "access": "public",
    "description": "Get the park opening hours for today",
    "lineNumber": 857,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 243,
    "kind": "method",
    "name": "getCalendarForTomorrow",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getCalendarForTomorrow",
    "access": "public",
    "description": "Get the park opening hours for tomorrow",
    "lineNumber": 866,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "file",
    "name": "lib/parks/parkTypes.js",
    "content": "\n/**\n * Possible types of queue\n * @enum\n */\nexport const queueType = Object.freeze({\n  // your standard \"stand-by queueing\"\n  standBy: 'STANDBY',\n  // identical to standby, but one guest at a time\n  singleRider: 'SINGLE_RIDER',\n  // virtual queue or \"classic\" paper fast-pass style system\n  //  can reserve a spot for a later time\n  returnTime: 'RETURN_TIME',\n  // special type, \"boarding group\"\n  //  guests reserve a slot to enter the attracion, but the time is not known\n  //  \"boarding groups\" are called in sequence when capacity allows\n  // eg. Rise of the Resistance at Disney\n  boardingGroup: 'BOARDING_GROUP',\n});\n\n/**\n * Possible types of state for a return time queue\n * @enum\n */\nexport const returnTimeState = Object.freeze({\n  // there are places still available\n  available: 'AVAILABLE',\n  // more slots will be available later\n  temporarilyFull: 'TEMP_FULL',\n  // all slots have been reserved for the day\n  finished: 'FINISHED',\n});\n\n/**\n * Status an attraction can be in (Operating, Down, etc.)\n * @enum\n */\nexport const statusType = Object.freeze({\n  operating: 'OPERATING',\n  down: 'DOWN',\n  closed: 'CLOSED',\n  refurbishment: 'REFURBISHMENT',\n});\n\n/**\n * Entity types\n * @enum\n */\nexport const entityType = Object.freeze({\n  resort: 'RESORT',\n  park: 'PARK',\n  attraction: 'ATTRACTION',\n  restaurant: 'RESTAURANT',\n  hotel: 'HOTEL',\n  show: 'SHOW',\n});\n\n/**\n * All known attraction types (ride, show, etc.)\n * @enum\n */\nexport const attractionType = Object.freeze({\n  ride: 'RIDE',\n  show: 'SHOW',\n  transport: 'TRANSPORT',\n  parade: 'PARADE',\n  meetAndGreet: 'MEET_AND_GREET',\n  other: 'OTHER',\n});\n\n/**\n * All possible schedule types\n * @enum\n */\nexport const scheduleType = Object.freeze({\n  operating: 'OPERATING', // normal park operating hours\n  ticketed: 'TICKETED_EVENT', // ticketed event. Halloween Horror nights etc.\n  private: 'PRIVATE_EVENT',\n  extraHours: 'EXTRA_HOURS', // \"extra magic hours\", \"early park admission\", etc.\n  informational: 'INFO', // some non-operating hours, listed for information (eg. \"You can now park hop\")\n});\n\n/**\n * All possible Tag types for attractions\n * @enum\n */\nexport const tagType = Object.freeze({\n  location: 'LOCATION',\n  fastPass: 'FASTPASS',\n  mayGetWet: 'MAY_GET_WET',\n  unsuitableForPregnantPeople: 'UNSUITABLE_PREGNANT',\n  minimumHeight: 'MINIMUM_HEIGHT',\n  maximumHeight: 'MAXIMUM_HEIGHT',\n  onRidePhoto: 'ONRIDE_PHOTO',\n  singleRider: 'SINGLE_RIDER',\n  childSwap: 'CHILD_SWAP',\n});\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/parkTypes.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 245,
    "kind": "variable",
    "name": "queueType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~queueType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{queueType}",
    "description": "Possible types of queue",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 246,
    "kind": "variable",
    "name": "returnTimeState",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~returnTimeState",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{returnTimeState}",
    "description": "Possible types of state for a return time queue",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "variable",
    "name": "statusType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~statusType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{statusType}",
    "description": "Status an attraction can be in (Operating, Down, etc.)",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "variable",
    "name": "entityType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~entityType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{entityType}",
    "description": "Entity types",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "variable",
    "name": "attractionType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~attractionType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{attractionType}",
    "description": "All known attraction types (ride, show, etc.)",
    "lineNumber": 62,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "variable",
    "name": "scheduleType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~scheduleType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{scheduleType}",
    "description": "All possible schedule types",
    "lineNumber": 75,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 251,
    "kind": "variable",
    "name": "tagType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~tagType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{tagType}",
    "description": "All possible Tag types for attractions",
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 252,
    "kind": "file",
    "name": "lib/parks/resort.js",
    "content": "import Entity from './entity.js';\nimport Park from './park.js';\n\n/**\n * The base Resort object\n */\nexport class Resort extends Entity {\n  /**\n   * Construct a new empty Resort object\n   * @param {object} options\n   * @param {object} parkOptions Options to pass onto all parks within this resort\n   */\n  constructor(options = {}, parkOptions = {}) {\n    super(options);\n\n    // remember the passed-in park options to use for any new parks we create\n    this._newParkOptions = parkOptions;\n\n    // construct all our parks (unless Park objects are already handed to us)\n    this._parks = [];\n\n    // if we were passed-in park classes, construct them\n    if (options.parks) {\n      [].concat(options.parks).forEach((park) => {\n        if (park instanceof Park) {\n          this.addPark(park);\n        } else {\n          this.addParkClass(park);\n        }\n      });\n    }\n  }\n\n  /**\n   * Add a new park to this resort. Will cosntruct into a new Park object\n   * @param {class<Park>} ParkClass\n   */\n  addParkClass(ParkClass) {\n    const alreadyExist = this._parks.find((x) => x instanceof ParkClass);\n    if (alreadyExist === undefined) {\n      if (ParkClass instanceof Park) {\n        const newPark = new ParkClass(this._newParkOptions);\n        this._parks.push(newPark);\n      } else {\n        throw new Error(`Cannot construct new Park object from ${ParkClass}, not a Park class`);\n      }\n    }\n  }\n\n  /**\n   * Add an already constructed park to this resort\n   * @param {Park} parkObject\n   */\n  addPark(parkObject) {\n    const alreadyExist = this._parks.find((x) => x.getParkUniqueID() === parkObject.getParkUniqueID());\n    if (alreadyExist === undefined) {\n      this._parks.push(parkObject);\n    }\n  }\n\n  /**\n   * Get all the parks within this resort\n   * @return {array<Park>}\n   */\n  getParks() {\n    return this._parks;\n  }\n}\n\nexport default Resort;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/resort.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 253,
    "kind": "class",
    "name": "Resort",
    "memberof": "lib/parks/resort.js",
    "static": true,
    "longname": "lib/parks/resort.js~Resort",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/resort.js",
    "importStyle": "{Resort}",
    "description": "The base Resort object",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "lib/parks/entity.js~Entity"
    ]
  },
  {
    "__docId__": 254,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/resort.js~Resort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/resort.js~Resort#constructor",
    "access": "public",
    "description": "Construct a new empty Resort object",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "parkOptions",
        "description": "Options to pass onto all parks within this resort"
      }
    ]
  },
  {
    "__docId__": 255,
    "kind": "member",
    "name": "_newParkOptions",
    "memberof": "lib/parks/resort.js~Resort",
    "static": false,
    "longname": "lib/parks/resort.js~Resort#_newParkOptions",
    "access": "private",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "member",
    "name": "_parks",
    "memberof": "lib/parks/resort.js~Resort",
    "static": false,
    "longname": "lib/parks/resort.js~Resort#_parks",
    "access": "private",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "addParkClass",
    "memberof": "lib/parks/resort.js~Resort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/resort.js~Resort#addParkClass",
    "access": "public",
    "description": "Add a new park to this resort. Will cosntruct into a new Park object",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "class<Park>"
        ],
        "spread": false,
        "optional": false,
        "name": "ParkClass",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "addPark",
    "memberof": "lib/parks/resort.js~Resort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/resort.js~Resort#addPark",
    "access": "public",
    "description": "Add an already constructed park to this resort",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "Park"
        ],
        "spread": false,
        "optional": false,
        "name": "parkObject",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 259,
    "kind": "method",
    "name": "getParks",
    "memberof": "lib/parks/resort.js~Resort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/resort.js~Resort#getParks",
    "access": "public",
    "description": "Get all the parks within this resort",
    "lineNumber": 65,
    "return": {
      "nullable": null,
      "types": [
        "array<Park>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 260,
    "kind": "file",
    "name": "lib/parks/sieve.js",
    "content": "import mingo from 'mingo';\n\n/**\n * Build a mongo-style filter function\n * @param {object} conf\n * @return {function}\n */\nexport function Sieve(conf = {}) {\n  const query = new mingo.Query(conf);\n  return (x) => query.test(x);\n}\n\nexport default Sieve;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/sieve.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 261,
    "kind": "function",
    "name": "Sieve",
    "memberof": "lib/parks/sieve.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/sieve.js~Sieve",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/sieve.js",
    "importStyle": "{Sieve}",
    "description": "Build a mongo-style filter function",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 262,
    "kind": "file",
    "name": "lib/parks/tags.js",
    "content": "// this file handles storing different tag types\n\nimport {tagType} from './parkTypes.js';\n\n/**\n * Validate a rider height tag. Used for min/max heights\n * @param {string} key\n * @param {*} data\n * @return {boolean}\n */\nconst riderHeightValidate = (key, data) => {\n  if (!validateObjectContainsOnlyGivenKeys(data, ['height', 'unit'])) {\n    return false;\n  }\n\n  const validUnits = ['cm', 'in'];\n  if (validUnits.indexOf(data.unit) < 0) {\n    return false;\n  }\n\n  return !isNaN(data.height) && data.height >= 0;\n};\n\n/**\n * Simple tags that don't have a value entry.\n * Instead, these tags are either present or not.\n */\nconst simpleTags = {\n  [tagType.fastPass]: true,\n  [tagType.mayGetWet]: true,\n  [tagType.unsuitableForPregnantPeople]: true,\n  [tagType.onRidePhoto]: true,\n  [tagType.singleRider]: true,\n  [tagType.childSwap]: true,\n};\n\n/**\n * Each tag type must have a validator function to confirm the incoming tag value is correct\n */\nconst validators = {\n  // Location tags\n  [tagType.location]: (key, data) => {\n    // make sure we have our longitude and latitude keys\n    if (!validateObjectContainsOnlyGivenKeys(data, ['longitude', 'latitude'])) {\n      return false;\n    }\n\n    // make sure our keys are valid numbers\n    if (isNaN(data.longitude) || isNaN(data.latitude)) {\n      return false;\n    }\n\n    return true;\n  },\n  // minimum height allowed to ride\n  //  must contain \"height\" as a number, and a \"unit\" which can be 'cm' (centimeters) or 'in' (inches)\n  [tagType.minimumHeight]: riderHeightValidate,\n  // maximum height allowed to ride\n  //  must contain \"height\" as a number, and a \"unit\" which can be 'cm' (centimeters) or 'in' (inches)\n  [tagType.maximumHeight]: riderHeightValidate,\n};\n\n\n/**\n * Given an object, validate that it only contains the given keys\n * Will return false if the object is missing any keys, or has additional keys not listed\n * @param {object} data\n * @param {array<string>} keys\n * @return {boolean}\n */\nfunction validateObjectContainsOnlyGivenKeys(data, keys) {\n  // make sure our input is an object\n  if (typeof data !== 'object' || data === null) return false;\n\n  // make sure our incoming keys is an array\n  keys = [].concat(keys);\n\n  // get the keys of our incoming object\n  const dataKeys = Object.keys(data);\n  // early bail if we have a different number of keys\n  if (dataKeys.length !== keys.length) return false;\n\n  // filter all our keys against our data key\n  // TODO - this may get slow for large objects, look to optimise\n  const matchingKeys = keys.filter((key) => {\n    return dataKeys.indexOf(key) >= 0;\n  });\n  // if our filtered keys is still the same length, we have all the keys we want\n  return (matchingKeys.length === dataKeys.length);\n}\n\n/**\n * Is the supplied tag type supported?\n * @param {tagType} type\n * @return {boolean}\n */\nexport function isValidTagType(type) {\n  return validators[type] !== undefined || simpleTags[type] !== undefined;\n}\n\n/**\n * Is the given type a \"simple tag\" (one with no actual value)\n * @param {tagType} type\n * @return {boolean}\n */\nexport function isSimpleTagType(type) {\n  return simpleTags[type] !== undefined;\n}\n\n/**\n * Validate a tag value based on its type\n * @param {string} key Tag name - some tags must have a valid name\n * @param {tagType} type The type for this tag entry\n * @param {*} value The tag data to validate matches this tag format's data structure\n * @return {boolean}\n */\nexport function isValidTag(key, type, value) {\n  if (!isValidTagType(type)) {\n    return false;\n  }\n\n  // simple tags don't need to run a validator\n  if (isSimpleTagType(type)) {\n    return true;\n  }\n\n  if (key === undefined) return false;\n\n  // run tag validator to confirm we are a valid tag\n  const validator = validators[type];\n  return (validator(key, value));\n}\n\n/**\n * Given a tag key, type, and value - parse, validate, and return the full expected tag object\n * @param {string} key Tag name - some tags must have a valid name\n * @param {tagType} type The type for this tag entry\n * @param {*} value The tag data to validate matches this tag format's data structure\n * @return {object} The tag object to use, or undefined if it isn't valid\n */\nexport function getValidTagObject(key, type, value) {\n  if (!isValidTag(key, type, value)) {\n    return undefined;\n  }\n\n  // return data structure based on tag type\n  if (isSimpleTagType(type)) {\n    return {\n      type,\n    };\n  } else {\n    return {\n      key,\n      value,\n      type,\n    };\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/tags.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 263,
    "kind": "function",
    "name": "riderHeightValidate",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~riderHeightValidate",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Validate a rider height tag. Used for min/max heights",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 264,
    "kind": "variable",
    "name": "simpleTags",
    "memberof": "lib/parks/tags.js",
    "static": true,
    "longname": "lib/parks/tags.js~simpleTags",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Simple tags that don't have a value entry.<br />Instead, these tags are either present or not.",
    "lineNumber": 28,
    "type": {
      "types": [
        "{\"undefined\": boolean}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 265,
    "kind": "variable",
    "name": "validators",
    "memberof": "lib/parks/tags.js",
    "static": true,
    "longname": "lib/parks/tags.js~validators",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Each tag type must have a validator function to confirm the incoming tag value is correct",
    "lineNumber": 40,
    "type": {
      "types": [
        "{\"undefined\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 266,
    "kind": "function",
    "name": "validateObjectContainsOnlyGivenKeys",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~validateObjectContainsOnlyGivenKeys",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Given an object, validate that it only contains the given keys<br />Will return false if the object is missing any keys, or has additional keys not listed",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 267,
    "kind": "function",
    "name": "isValidTagType",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~isValidTagType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": "{isValidTagType}",
    "description": "Is the supplied tag type supported?",
    "lineNumber": 97,
    "params": [
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 268,
    "kind": "function",
    "name": "isSimpleTagType",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~isSimpleTagType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": "{isSimpleTagType}",
    "description": "Is the given type a \"simple tag\" (one with no actual value)",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 269,
    "kind": "function",
    "name": "isValidTag",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~isValidTag",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": "{isValidTag}",
    "description": "Validate a tag value based on its type",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Tag name - some tags must have a valid name"
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type for this tag entry"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The tag data to validate matches this tag format's data structure"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 270,
    "kind": "function",
    "name": "getValidTagObject",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~getValidTagObject",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": "{getValidTagObject}",
    "description": "Given a tag key, type, and value - parse, validate, and return the full expected tag object",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Tag name - some tags must have a valid name"
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type for this tag entry"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The tag data to validate matches this tag format's data structure"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The tag object to use, or undefined if it isn't valid"
    }
  },
  {
    "__docId__": 271,
    "kind": "file",
    "name": "lib/parks/tdr/tokyodisneyresort.js",
    "content": "import {Park} from '../park.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType} from '../parkTypes.js';\nimport moment from 'moment-timezone';\n\n/**\n * TokyoDisneyResortPark Object\n */\nexport class TokyoDisneyResortPark extends Park {\n  /**\n   * Create a new TokyoDisneyResortPark object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Tokyo Disney Resort Park';\n    options.timezone = options.timezone || 'Asia/Tokyo';\n\n    options.apiKey = options.apiKey || '';\n    options.apiAuth = options.apiAuth || '';\n    options.apiOS = options.apiOS || '';\n    options.apiBase = options.apiBase || '';\n    options.apiVersion = options.apiVersion || '';\n    options.parkId = options.parkId || '';\n\n    // any custom environment variable prefixes we want to use for this park (optional)\n    options.configPrefixes = ['TDR'].concat(options.configPrefixes || []);\n\n    super(options);\n\n    if (!this.config.apiKey) throw new Error('Missing TDR apiKey');\n    if (!this.config.apiAuth) throw new Error('Missing TDR apiAuth');\n    if (!this.config.apiOS) throw new Error('Missing TDR apiOS');\n    if (!this.config.apiBase) throw new Error('Missing TDR apiBase');\n    if (!this.config.apiVersion) throw new Error('Missing TDR apiVersion');\n    if (!this.config.parkId) throw new Error('Missing TDR parkId');\n\n    // some convenience strings\n    this.config.parkIdLower = this.config.parkId.toLowerCase();\n    this.config.parkIdUpper = this.config.parkId.toUpperCase();\n\n    this.injectForDomain({\n      hostname: new URL(this.config.apiBase).hostname,\n    }, async (method, url, data, options) => {\n      const appVersion = (await this.fetchLatestVersion()) || this.config.apiVersion;\n\n      options.headers['user-agent'] = `TokyoDisneyResortApp/${appVersion} Android/${this.config.apiOS}`;\n      options.headers['x-api-key'] = this.config.apiKey;\n      options.headers['X-PORTAL-LANGUAGE'] = 'en-US';\n      options.headers['X-PORTAL-OS-VERSION'] = `Android ${this.config.apiOS}`;\n      options.headers['X-PORTAL-APP-VERSION'] = appVersion;\n      options.headers['X-PORTAL-DEVICE-NAME'] = 'OnePlus5';\n      options.headers.connection = 'keep-alive';\n      options.headers['Accept-Encoding'] = 'gzip';\n      options.headers.Accept = 'application/json';\n      options.headers['Content-Type'] = 'application/json';\n\n      if (!options.ignoreDeviceID) {\n        const deviceID = await this.fetchDeviceID();\n        options.headers['X-PORTAL-DEVICE-ID'] = deviceID;\n        options.headers['X-PORTAL-AUTH'] = this.config.apiAuth;\n      }\n\n      // we handle auth/500 errors ourselves for TDR\n      options.ignoreErrors = true;\n    });\n\n    this.http.injectForDomainResponse({\n      hostname: new URL(this.config.apiBase).hostname,\n    }, async (resp) => {\n      if (resp.statusCode === 400) {\n        console.log('TDR version invalid, fetch again...');\n        // force a store version update if we get a 400 error\n        await this.cache.setGlobal('tdr_appversion', undefined, -1);\n        return undefined;\n      }\n\n      if (resp.statusCode === 503) {\n        const maintenance = resp.body.errors.find((x) => x.code === 'error.systemMaintenance');\n        if (maintenance) {\n          // down for maintenance!\n          const now = this.getTimeNowMoment();\n          if (now.isBetween(maintenance.startAt, maintenance.endAt)) {\n            const endsIn = now.diff(maintenance.endAt, 'minutes');\n            this.log(`Tokyo Disney Resort API in maintenance. Ends in ${Math.abs(endsIn)} minutes`);\n            // return original response to avoid refetching again and again and again\n            return resp;\n          }\n        } else {\n          this.emit('error', new Error(`Invalid response from TDR ${JSON.stringify(resp.body)}`));\n        }\n      }\n\n      return resp;\n    });\n  }\n\n  /**\n   * Fetch the current app version on the Google Play store\n   * @return {string}\n   */\n  async fetchLatestVersion() {\n    return await this.cache.wrapGlobal(\n        'tdr_appversion',\n        async () => {\n          // use the themeparks.wiki appstore watcher API\n          const resp = await this.http(\n              'GET',\n              'https://appwatch.themeparks.wiki/latest/jp.tokyodisneyresort.portalapp',\n              {},\n          );\n          return resp.body.version;\n        },\n        1000 * 60 * 60 * 2,\n    );\n  }\n\n  /**\n   * Return or fetch a device ID to use for API calls\n   */\n  async fetchDeviceID() {\n    return await this.cache.wrapGlobal('tdr_device_id', async () => {\n      const resp = await this.http(\n          'POST',\n          `${this.config.apiBase}/rest/v1/devices`,\n          undefined,\n          {\n            ignoreDeviceID: true,\n          },\n      );\n\n      return resp.body.deviceId;\n    }, 1000 * 60 * 60 * 24 * 10); // use for 10 days\n  }\n\n  /**\n   * Get the latest facilities data for the entire resort\n   */\n  async fetchAllFacilitiesData() {\n    return await this.cache.wrapGlobal('tdr_facilities', async () => {\n      const headers = {};\n      const lastModifiedTime = await this.cache.getGlobal('tdr_facilities_last_modified');\n      if (lastModifiedTime !== undefined) {\n        headers['If-Modified-Since'] = lastModifiedTime;\n      }\n\n      const resp = await this.http('GET', `${this.config.apiBase}/rest/v2/facilities`, undefined, {\n        headers,\n      });\n\n      // store in a separate long-term cache so we can keep using it if the server data hasn't changed\n      if (resp.statusCode !== 304) {\n        // transform data into an array with \"facilityType\", rather than a nested object\n        const data = [];\n        Object.keys(resp.body).forEach((key) => {\n          resp.body[key].forEach((x) => {\n            data.push({\n              facilityType: key,\n              ...x,\n            });\n          });\n        });\n\n        await this.cache.setGlobal('tdr_facilities_data', data, Number.MAX_SAFE_INTEGER);\n        await this.cache.setGlobal(\n            'tdr_facilities_last_modified',\n            resp.headers['Last-Modified'],\n            Number.MAX_SAFE_INTEGER,\n        );\n        return data;\n      }\n\n      return await this.cache.getGlobal('tdr_facilities_data');\n    }, 1000 * 60 * 60 * 2); // check every 2 hours\n  }\n\n  /**\n   * Get facilities data for this park\n   */\n  async fetchFacilitiesData() {\n    return await this.cache.wrap('facilities', async () => {\n      const resortData = await this.fetchAllFacilitiesData();\n      return resortData.filter((x) => x.parkType === this.config.parkIdUpper);\n    }, 1000 * 60 * 15); // cache each park's facility data for 15 minutes, to avoid filtering too often\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _init() {\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _buildAttractionObject(attractionID) {\n    const facilityData = await this.fetchFacilitiesData();\n    const attr = facilityData.find((x) => x.facilityCode == attractionID);\n    if (attr === undefined) return undefined;\n\n    const tags = [];\n\n    tags.push({\n      type: tagType.fastPass,\n      value: !!attr.fastpass,\n    });\n\n    tags.push({\n      type: tagType.singleRider,\n      value: !!attr.filters.find((x) => x.type === 'SINGLE_RIDER'),\n    });\n\n    const heightUppper = attr.restrictions.find((x) => x.type === 'LOWER_HEIGHT');\n    if (heightUppper !== undefined) {\n      const heightMin = /(\\d+)\\s*cm/.exec(heightUppper.name);\n      if (heightMin) {\n        tags.push({\n          key: 'minimumHeight',\n          type: tagType.minimumHeight,\n          value: {\n            unit: 'cm',\n            height: Number(heightMin[1]),\n          },\n        });\n      }\n    }\n\n    const heightLower = attr.restrictions.find((x) => x.type === 'UPPER_HEIGHT');\n    if (heightLower !== undefined) {\n      const heightMax = /(\\d+)\\s*cm/.exec(heightLower.name);\n      if (heightMax) {\n        tags.push({\n          key: 'maximumHeight',\n          type: tagType.maximumHeight,\n          value: {\n            unit: 'cm',\n            height: Number(heightMax[1]),\n          },\n        });\n      }\n    }\n\n    tags.push({\n      type: tagType.unsuitableForPregnantPeople,\n      value: attr.filters.find((x) => x === 'EXPECTANT_MOTHER') === undefined,\n    });\n\n    return {\n      name: attr.nameKana,\n      type: attr.facilityType === 'attractions' ? attractionType.ride : attractionType.other,\n      tags,\n    };\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _update() {\n    const resp = await this.http(\n        'GET',\n        `${this.config.apiBase}/rest/v2/facilities/conditions`,\n    );\n\n    const attractions = resp?.body?.attractions;\n    if (!attractions) {\n      return;\n    }\n\n    await Promise.allSettled(attractions.map(async (attr) => {\n      let status = attr.standbyTime ? statusType.operating : statusType.closed;\n      switch (attr.facilityStatus) {\n        case 'CANCEL':\n          status = statusType.closed;\n          break;\n        case 'CLOSE_NOTICE':\n          status = statusType.down;\n          break;\n        case 'OPEN':\n          status = statusType.operating;\n          break;\n      }\n\n      await this.updateAttractionState(attr.facilityCode, status);\n      await this.updateAttractionQueue(\n          attr.facilityCode,\n        status == statusType.operating ? attr.standbyTime : null,\n        queueType.standBy,\n      );\n    }));\n  }\n\n  /**\n   * Fetch the upcoming calendar\n   */\n  async fetchCalendar() {\n    return await this.cache.wrapGlobal('tdr_calendar', async () => {\n      const cal = await this.http(\n          'GET',\n          `${this.config.apiBase}/rest/v1/parks/calendars`,\n      );\n\n      return cal.body;\n    }, 1000 * 60 * 60 * 12);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getOperatingHoursForDate(date) {\n    const cal = await this.fetchCalendar();\n\n    if (!Array.isArray(cal)) return undefined;\n\n    const dateString = date.format('YYYY-MM-DD');\n    const targetDate = cal.find((x) => {\n      return x.parkType === this.config.parkIdUpper &&\n        x.closedDay === false &&\n        x.undecided === false &&\n        x.date === dateString;\n    });\n    if (targetDate) {\n      const hours = [];\n      const momentParseFormat = 'YYYY-MM-DDTHH:mm';\n\n      hours.push({\n        openingTime: moment.tz(\n            `${dateString}T${targetDate.openTime}`,\n            momentParseFormat,\n            this.config.timezone).format(),\n        closingTime: moment.tz(\n            `${dateString}T${targetDate.closeTime}`,\n            momentParseFormat,\n            this.config.timezone).format(),\n        type: scheduleType.operating,\n      });\n\n      // \"sp\" opening times, i.e, magic hours\n      if (targetDate.spOpenTime && targetDate.spCloseTime) {\n        hours.push({\n          openingTime: moment.tz(\n              `${dateString}T${targetDate.spOpenTime}`,\n              momentParseFormat,\n              this.config.timezone).format(),\n          closingTime: moment.tz(\n              `${dateString}T${targetDate.spCloseTime}`,\n              momentParseFormat,\n              this.config.timezone).format(),\n          type: scheduleType.extraHours,\n        });\n      }\n\n      return hours;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Fetch the restaurant operating hours\n   */\n  async fetchRestaurantOperatingHours() {\n    const resp = await this.http(\n        'GET',\n        `${this.config.apiBase}/rest/v2/facilities/conditions`,\n    );\n\n    return resp.body.restaurants.map((restaurant) => {\n      // console.log(restaurant);\n      if (!restaurant.operatings || restaurant.operatings.length === 0) {\n        return {\n          restaurantID: restaurant.facilityCode,\n          openingTime: 0,\n          closingTime: 0,\n          status: statusType.closed,\n        };\n      }\n\n      // TODO: restaurant.facilityStatus check needed?\n      const momentParseFormat = 'YYYY-MM-DDTHH:mm';\n      const schedule = restaurant.operatings[0];\n\n      return {\n        restaurantID: restaurant.facilityCode,\n        openingTime: moment.tz(\n            schedule.startAt,\n            momentParseFormat,\n            this.config.timezone).format(),\n        closingTime: moment.tz(\n            schedule.endAt,\n            momentParseFormat,\n            this.config.timezone).format(),\n        status: statusType.operating,\n      };\n    });\n  }\n\n  /**\n     * Return restaurant operating hours for the supplied date\n     * @param {moment} date\n     */\n  async _getRestaurantOperatingHoursForDate(date) {\n    const cal = await this.fetchRestaurantOperatingHours();\n    if (!cal) return undefined;\n    return cal;\n  }\n}\n\nexport default TokyoDisneyResortPark;\n\n/**\n * Tokyo Disneyland\n */\nexport class TokyoDisneyland extends TokyoDisneyResortPark {\n  /**\n   * Construct new TokyoDisneyland Object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.name = 'Tokyo Disney Resort - Tokyo Disneyland';\n    options.parkId = 'tdl';\n\n    super(options);\n  }\n}\n\n/**\n * Tokyo DisneySea\n */\nexport class TokyoDisneySea extends TokyoDisneyResortPark {\n  /**\n   * Construct new TokyoDisneySea Object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.name = 'Tokyo Disney Resort - Tokyo DisneySea';\n    options.parkId = 'tds';\n\n    super(options);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/tdr/tokyodisneyresort.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 272,
    "kind": "class",
    "name": "TokyoDisneyResortPark",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js",
    "static": true,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tdr/tokyodisneyresort.js",
    "importStyle": "{TokyoDisneyResortPark}",
    "description": "TokyoDisneyResortPark Object",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "lib/parks/park.js~Park"
    ]
  },
  {
    "__docId__": 273,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#constructor",
    "access": "public",
    "description": "Create a new TokyoDisneyResortPark object",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 274,
    "kind": "method",
    "name": "fetchLatestVersion",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#fetchLatestVersion",
    "access": "public",
    "description": "Fetch the current app version on the Google Play store",
    "lineNumber": 100,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 275,
    "kind": "method",
    "name": "fetchDeviceID",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#fetchDeviceID",
    "access": "public",
    "description": "Return or fetch a device ID to use for API calls",
    "lineNumber": 119,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "fetchAllFacilitiesData",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#fetchAllFacilitiesData",
    "access": "public",
    "description": "Get the latest facilities data for the entire resort",
    "lineNumber": 137,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "fetchFacilitiesData",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#fetchFacilitiesData",
    "access": "public",
    "description": "Get facilities data for this park",
    "lineNumber": 178,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 278,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#_init",
    "access": "private",
    "description": "",
    "lineNumber": 188,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#_buildAttractionObject",
    "access": "private",
    "description": "",
    "lineNumber": 194,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "attractionID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"name\": *, \"type\": *, \"tags\": *}"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#_update",
    "access": "private",
    "description": "",
    "lineNumber": 256,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 281,
    "kind": "method",
    "name": "fetchCalendar",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#fetchCalendar",
    "access": "public",
    "description": "Fetch the upcoming calendar",
    "lineNumber": 293,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "method",
    "name": "_getOperatingHoursForDate",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#_getOperatingHoursForDate",
    "access": "private",
    "description": "",
    "lineNumber": 307,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "method",
    "name": "fetchRestaurantOperatingHours",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#fetchRestaurantOperatingHours",
    "access": "public",
    "description": "Fetch the restaurant operating hours",
    "lineNumber": 359,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "method",
    "name": "_getRestaurantOperatingHoursForDate",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResortPark#_getRestaurantOperatingHoursForDate",
    "access": "private",
    "description": "Return restaurant operating hours for the supplied date",
    "lineNumber": 399,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "class",
    "name": "TokyoDisneyland",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js",
    "static": true,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyland",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tdr/tokyodisneyresort.js",
    "importStyle": "{TokyoDisneyland}",
    "description": "Tokyo Disneyland",
    "lineNumber": 411,
    "interface": false,
    "extends": [
      "TokyoDisneyResortPark"
    ]
  },
  {
    "__docId__": 286,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyland",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyland#constructor",
    "access": "public",
    "description": "Construct new TokyoDisneyland Object",
    "lineNumber": 416,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 287,
    "kind": "class",
    "name": "TokyoDisneySea",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js",
    "static": true,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneySea",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tdr/tokyodisneyresort.js",
    "importStyle": "{TokyoDisneySea}",
    "description": "Tokyo DisneySea",
    "lineNumber": 427,
    "interface": false,
    "extends": [
      "TokyoDisneyResortPark"
    ]
  },
  {
    "__docId__": 288,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneySea",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneySea#constructor",
    "access": "public",
    "description": "Construct new TokyoDisneySea Object",
    "lineNumber": 432,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 289,
    "kind": "file",
    "name": "lib/parks/universal/universalstudios.js",
    "content": "import {Park} from '../park.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, returnTimeState} from '../parkTypes.js';\nimport moment from 'moment-timezone';\nimport crypto from 'crypto';\nimport {URL} from 'url';\n\n/**\n * Sample Park Object\n */\nexport class UniversalParkBase extends Park {\n  /**\n   * Create a new Sample Park object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Universal Park';\n    options.timezone = options.timezone || 'America/New_York';\n\n    options.secretKey = options.secretKey || '';\n    options.appKey = options.appKey || '';\n    options.venueID = options.venueID || '';\n    options.city = options.city || '';\n    options.vQueueURL = options.venueID || '';\n    options.baseURL = options.baseURL || '';\n    options.contentID = options.contentID || '';\n\n    // any custom environment variable prefixes we want to use for this park (optional)\n    options.configPrefixes = ['UNIVERSALSTUDIOS'].concat(options.configPrefixes || []);\n\n    super(options);\n\n    // here we can validate the resulting this.config object\n    if (!this.config.secretKey) throw new Error('Missing Universal secretKey');\n    if (!this.config.appKey) throw new Error('Missing Universal appKey');\n    if (!this.config.venueID) throw new Error('Missing Universal venueID');\n    this.config.venueID = Number(this.config.venueID);\n    if (!this.config.city) throw new Error('Missing Universal city');\n    if (!this.config.vQueueURL) throw new Error('Missing Universal vQueueURL');\n    if (!this.config.baseURL) throw new Error('Missing Universal baseURL');\n    if (!this.config.contentID) throw new Error('Missing Universal contentID');\n\n    const baseURLHostname = new URL(this.config.baseURL).hostname;\n\n    this.http.injectForDomain({\n      hostname: baseURLHostname,\n    }, async (method, url, data, options) => {\n      options.headers['X-UNIWebService-ApiKey'] = this.config.appKey;\n      if (!options.loginRequest) {\n        const token = await this.getServiceToken();\n        options.headers['X-UNIWebService-Token'] = token;\n      }\n    });\n\n    // listen to unauthorised responses, to generate a new token\n    this.http.injectForDomainResponse({\n      hostname: baseURLHostname,\n    }, async (response) => {\n      if (response.statusCode === 401) {\n        // clear out our token and try again\n        await this.cache.set('servicetoken', undefined, -1);\n        return undefined;\n      }\n\n      return response;\n    });\n  }\n\n  /**\n   * Get a service auth token for Universal\n   */\n  async getServiceToken() {\n    let tokenExpiration = null;\n    return await this.cache.wrap('servicetoken', async () => {\n      // create signature to get access token\n      const today = `${moment.utc().format('ddd, DD MMM YYYY HH:mm:ss')} GMT`;\n      const signatureBuilder = crypto.createHmac('sha256', this.config.secretKey);\n      signatureBuilder.update(`${this.config.appKey}\\n${today}\\n`);\n      // generate hash from signature builder\n      //  also convert trailing equal signs to unicode. because. I don't know\n      const signature = signatureBuilder.digest('base64').replace(/=$/, '\\u003d');\n\n      const resp = await this.http('POST', `${this.config.baseURL}?city=${this.config.city}`, {\n        apikey: this.config.appKey,\n        signature,\n      }, {\n        headers: {\n          'Date': today,\n        },\n        loginRequest: true,\n        json: true,\n      });\n\n      // remember the expiration time\n      const expireTime = resp.body.TokenExpirationUnix * 1000;\n      tokenExpiration = Math.max(+new Date() + (1000 * 60 * 60), expireTime - (+new Date()) - (1000 * 60 * 60 * 12));\n\n      return resp.body.Token;\n    }, () => {\n      return tokenExpiration;\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _init() {\n  }\n\n  /**\n   * Get all park POI data\n   */\n  async getPOI() {\n    return await this.cache.wrapGlobal(`universalstudios_${this.config.city}_poi`, async () => {\n      const data = await this.http('GET', `${this.config.baseURL}/pointsOfInterest`, {\n        city: this.config.city,\n      });\n      if (!data?.body?.Rides) {\n        throw new Error('Unable to fetch Universal POI data');\n      }\n      return data.body.Rides;\n    }, 1000 * 60 * 60 * 12); // 12 hours\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _buildAttractionObject(attractionID) {\n    const data = await this.getPOI();\n    if (data === undefined) return undefined;\n    const ride = data.find((x) => `${x.Id}` === attractionID && x.VenueId === this.config.venueID);\n    if (ride === undefined) return undefined;\n\n    const tags = [];\n\n    if (ride.Longitude && ride.Latitude) {\n      tags.push({\n        key: 'location',\n        type: tagType.location,\n        value: {\n          longitude: ride.Longitude,\n          latitude: ride.Latitude,\n        },\n      });\n    }\n\n    if (ride.MinHeightInInches) {\n      tags.push({\n        key: 'minimumHeight',\n        type: tagType.minimumHeight,\n        value: {\n          unit: 'in',\n          height: ride.MinHeightInInches,\n        },\n      });\n    }\n    if (ride.MaxHeightInInches) {\n      tags.push({\n        key: 'maximumHeight',\n        type: tagType.maximumHeight,\n        value: {\n          unit: 'in',\n          height: ride.MaxHeightInInches,\n        },\n      });\n    }\n\n    tags.push({\n      type: tagType.singleRider,\n      value: !!ride.HasSingleRiderLine,\n    });\n\n    tags.push({\n      type: tagType.fastPass,\n      value: !!ride.ExpressPassAccepted,\n    });\n\n    tags.push({\n      type: tagType.childSwap,\n      value: !!ride.HasChildSwap,\n    });\n\n    return {\n      name: ride.MblDisplayName,\n      type: attractionType.ride,\n      tags,\n    };\n  }\n\n  /**\n   * Get the current state of virtual queues for the resort\n   */\n  async getVirtualQueueStates() {\n    return await this.cache.wrap(`universalstudios_${this.config.city}_vqueuestate`, async () => {\n      const virtualData = await this.http('GET', `${this.config.baseURL}/Queues`, {\n        city: this.config.city,\n        page: 1,\n        pageSize: 'all',\n      });\n      return virtualData.body;\n    }, 1000 * 60); // 1 minute\n  }\n\n  /**\n   * Get current state for a virtual queue\n   * @param {number} queueId\n   * @return {object} Object containing startTime and endTime as a moment object.\n   * Or undefined if there are no times available.\n   */\n  async getVirtualQueueTimeForRide(queueId) {\n    return await this.cache.wrap(`vqueue_${queueId}`, async () => {\n      const todaysDate = (await this.getActiveParkDateMoment()).format('MM/DD/YYYY');\n      const res = await this.http(\n          'GET',\n          `${this.config.baseURL}/${this.config.vQueueURL}/${queueId}`, {\n            page: 1,\n            pageSize: 'all',\n            city: this.config.city,\n            appTimeForToday: todaysDate,\n          });\n\n      // find and return the earliest appointment time available\n      const earliestTime = res.body.AppointmentTimes.reduce((p, x) => {\n        const startTime = moment.tz(x.StartTime, this.config.timezone);\n        if (p === undefined || startTime.isBefore(p.startTime)) {\n          const endTime = moment.tz(x.EndTime, this.config.timezone);\n          return {\n            startTime,\n            endTime,\n          };\n        }\n        return p;\n      }, undefined);\n\n      return earliestTime;\n    }, 1000 * 60); // 1 minute\n  }\n\n  /**\n   * Fetch raw waiting times data\n   */\n  async getWaitingTimes() {\n    return await this.cache.wrapGlobal(`universalstudios_${this.config.city}_waittimes`, async () => {\n      const resp = await this.http('GET', `${this.config.baseURL}/pointsofinterest/rides/waittimes`, {\n        city: this.config.city,\n        pageSize: 'All',\n      });\n      return resp.body;\n    }, 1000 * 60); // cache for 1 minute\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _update() {\n    const data = await this.getWaitingTimes();\n\n    await Promise.allSettled(data.Results.filter(\n        (x) => x.ContentId.indexOf(this.config.contentID) === 0,\n    ).map(async (ride) => {\n      let queue = queueType.standBy;\n      let status = statusType.operating;\n      let postWaitTime = Math.max(0, ride.Value);\n      switch (ride.Value) {\n        case -50:\n          // wait time unknown\n          //  app just displays nothing for the ride status when -50\n          postWaitTime = null;\n          break;\n        case -9:\n          // this is a virtual line update, so bail out\n          queue = queueType.returnTime;\n          break;\n        case -8:\n          // not open yet\n          status = statusType.closed;\n          postWaitTime = null;\n          break;\n        case -7:\n          // \"ride now\"\n          break;\n        case -6:\n        case -5:\n          // \"closed inside of operating hours\", not sure what that means, but it's closed\n          status = statusType.closed;\n          postWaitTime = null;\n          break;\n        case -4:\n        case -3:\n          // bad weather\n          status = statusType.down;\n          postWaitTime = null;\n          break;\n        case -1:\n          // not open yet (too early)\n        case -2:\n          // \"delayed\", but expected to open\n          status = statusType.closed;\n          postWaitTime = null;\n          break;\n      }\n\n      await this.updateAttractionState(ride.Key, status);\n      if (queue == queueType.standBy) {\n        await this.updateAttractionQueue(ride.Key, postWaitTime, queueType.standBy);\n      } else {\n        await this.updateAttractionQueue(ride.Key, undefined, queueType.standBy);\n      }\n    }));\n\n    // also fetch virtual lines status\n    const virtualData = await this.getVirtualQueueStates();\n    const vResults = virtualData?.Results;\n    if (vResults !== undefined) {\n      await Promise.allSettled(vResults.map(async (ride) => {\n      // check the right this virtual queue is for is in this park\n        const actual = await this.findAttractionByID(ride.QueueEntityId);\n        if (actual === undefined) return;\n\n        if (ride.IsEnabled) {\n        // get next available slot\n          const nextSlot = await this.getVirtualQueueTimeForRide(ride.Id);\n\n          // update return time queue with slot data\n          await this.updateAttractionQueue(ride.QueueEntityId, {\n            returnStart: nextSlot === undefined ? null : nextSlot.startTime,\n            returnEnd: nextSlot === undefined ? null : nextSlot.endTime,\n            // TODO - can we tell the difference between temporarily full and finished for the day?\n            state: nextSlot === undefined ? returnTimeState.temporarilyFull : returnTimeState.available,\n          }, queueType.returnTime);\n        } else {\n        // virtual queue not enable, ensure return time queue type is not shown\n          await this.updateAttractionQueue(ride.QueueEntityId, undefined, queueType.returnTime);\n        }\n      }));\n    } else {\n      // virtual queue system is down, unset all virtual queues for this park\n      const toUpdate = this._attractions.map((x) => x.rideId);\n      for (let i=0; i<toUpdate.length; i++) {\n        await this.updateAttractionQueue(toUpdate[i], undefined, queueType.returnTime);\n      }\n    }\n  }\n\n  /**\n   * Get the latest raw opening hours for this park\n   */\n  async getLatestOpeningHours() {\n    return await this.cache.wrap('calendar_data', async () => {\n      const now = this.getTimeNowMoment();\n      const cal = await this.http('GET', `${this.config.baseURL}/venues/${this.config.venueID}/hours`, {\n        endDate: now.clone().add(120, 'days').format('MM/DD/YYYY'),\n      });\n      return cal.body;\n    }, 1000 * 60 * 60 * 24); // 1 day\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getOperatingHoursForDate(date) {\n    const cal = await this.getLatestOpeningHours();\n    const dateFormatted = date.format('YYYY-MM-DD');\n    const todaysCal = cal.find((x) => x.Date === dateFormatted);\n    if (todaysCal === undefined) return undefined;\n\n    if (todaysCal.VenueStatus === 'Closed') return undefined;\n\n    const ret = [];\n    ret.push({\n      openingTime: todaysCal.OpenTimeString,\n      closingTime: todaysCal.CloseTimeString,\n      type: scheduleType.operating,\n    });\n\n    if (todaysCal.EarlyEntryString) {\n      // extra hours\n      ret.push({\n        openingTime: todaysCal.EarlyEntryString,\n        closingTime: todaysCal.OpenTimeString,\n        type: scheduleType.extraHours,\n      });\n    }\n\n    // TODO - handle todaysCal.SpecialEntryString (when these exist)\n    if (todaysCal.SpecialEntryString) {\n      this.emit('error', new Error(`Unknown Universal SpecialEntryString ${todaysCal.SpecialEntryString}`));\n    }\n\n    return ret;\n  }\n}\n\nexport default UniversalParkBase;\n\n/**\n * Universal Studios Florida Park\n */\nexport class UniversalStudiosFlorida extends UniversalParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Universal Studios Florida';\n    options.venueID = 10010;\n    options.city = 'orlando';\n    options.contentID = 'com.uo.usf';\n\n    super(options);\n  }\n}\n\n/**\n * Islands Of Adventure Park\n */\nexport class UniversalIslandsOfAdventure extends UniversalParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Universal\\'s Islands Of Adventure';\n    options.venueID = 10000;\n    options.city = 'orlando';\n    options.contentID = 'com.uo.ioa';\n\n    super(options);\n  }\n}\n\n/**\n * Volcano Bay\n */\nexport class UniversalVolcanoBay extends UniversalParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Universal\\'s Volcano Bay';\n    options.venueID = 13801;\n    options.city = 'orlando';\n    options.contentID = 'com.uo.vb';\n\n    super(options);\n  }\n}\n\n/**\n * Universal Studios Hollywood\n */\nexport class UniversalStudios extends UniversalParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Universal Studios';\n    options.venueID = 13825;\n    options.city = 'hollywood';\n    options.contentID = 'com.uo.us';\n\n    super(options);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/universal/universalstudios.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 290,
    "kind": "class",
    "name": "UniversalParkBase",
    "memberof": "lib/parks/universal/universalstudios.js",
    "static": true,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universalstudios.js",
    "importStyle": "{UniversalParkBase}",
    "description": "Sample Park Object",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "lib/parks/park.js~Park"
    ]
  },
  {
    "__docId__": 291,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#constructor",
    "access": "public",
    "description": "Create a new Sample Park object",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "getServiceToken",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getServiceToken",
    "access": "public",
    "description": "Get a service auth token for Universal",
    "lineNumber": 71,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#_init",
    "access": "private",
    "description": "",
    "lineNumber": 106,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 294,
    "kind": "method",
    "name": "getPOI",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getPOI",
    "access": "public",
    "description": "Get all park POI data",
    "lineNumber": 112,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#_buildAttractionObject",
    "access": "private",
    "description": "",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "attractionID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"name\": *, \"type\": *, \"tags\": *}"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "method",
    "name": "getVirtualQueueStates",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getVirtualQueueStates",
    "access": "public",
    "description": "Get the current state of virtual queues for the resort",
    "lineNumber": 192,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "method",
    "name": "getVirtualQueueTimeForRide",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getVirtualQueueTimeForRide",
    "access": "public",
    "description": "Get current state for a virtual queue",
    "lineNumber": 209,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "queueId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Object containing startTime and endTime as a moment object.\nOr undefined if there are no times available."
    }
  },
  {
    "__docId__": 298,
    "kind": "method",
    "name": "getWaitingTimes",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getWaitingTimes",
    "access": "public",
    "description": "Fetch raw waiting times data",
    "lineNumber": 241,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#_update",
    "access": "private",
    "description": "",
    "lineNumber": 254,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 300,
    "kind": "method",
    "name": "getLatestOpeningHours",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getLatestOpeningHours",
    "access": "public",
    "description": "Get the latest raw opening hours for this park",
    "lineNumber": 347,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "method",
    "name": "_getOperatingHoursForDate",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#_getOperatingHoursForDate",
    "access": "private",
    "description": "",
    "lineNumber": 360,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "class",
    "name": "UniversalStudiosFlorida",
    "memberof": "lib/parks/universal/universalstudios.js",
    "static": true,
    "longname": "lib/parks/universal/universalstudios.js~UniversalStudiosFlorida",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universalstudios.js",
    "importStyle": "{UniversalStudiosFlorida}",
    "description": "Universal Studios Florida Park",
    "lineNumber": 398,
    "interface": false,
    "extends": [
      "UniversalParkBase"
    ]
  },
  {
    "__docId__": 303,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalStudiosFlorida",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalStudiosFlorida#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 402,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 304,
    "kind": "class",
    "name": "UniversalIslandsOfAdventure",
    "memberof": "lib/parks/universal/universalstudios.js",
    "static": true,
    "longname": "lib/parks/universal/universalstudios.js~UniversalIslandsOfAdventure",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universalstudios.js",
    "importStyle": "{UniversalIslandsOfAdventure}",
    "description": "Islands Of Adventure Park",
    "lineNumber": 415,
    "interface": false,
    "extends": [
      "UniversalParkBase"
    ]
  },
  {
    "__docId__": 305,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalIslandsOfAdventure",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalIslandsOfAdventure#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 419,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 306,
    "kind": "class",
    "name": "UniversalVolcanoBay",
    "memberof": "lib/parks/universal/universalstudios.js",
    "static": true,
    "longname": "lib/parks/universal/universalstudios.js~UniversalVolcanoBay",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universalstudios.js",
    "importStyle": "{UniversalVolcanoBay}",
    "description": "Volcano Bay",
    "lineNumber": 432,
    "interface": false,
    "extends": [
      "UniversalParkBase"
    ]
  },
  {
    "__docId__": 307,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalVolcanoBay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalVolcanoBay#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 436,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 308,
    "kind": "class",
    "name": "UniversalStudios",
    "memberof": "lib/parks/universal/universalstudios.js",
    "static": true,
    "longname": "lib/parks/universal/universalstudios.js~UniversalStudios",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universalstudios.js",
    "importStyle": "{UniversalStudios}",
    "description": "Universal Studios Hollywood",
    "lineNumber": 449,
    "interface": false,
    "extends": [
      "UniversalParkBase"
    ]
  },
  {
    "__docId__": 309,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalStudios",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalStudios#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 453,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 310,
    "kind": "file",
    "name": "lib/parks/wdw/waltdisneyworldbase.js",
    "content": "import {IndexedWDWDB, getEntityID} from './wdwdb.js';\nimport {Park} from '../park.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\nimport moment from 'moment-timezone';\n\nlet wdwDB = null;\n\n/**\n * Base Disney Park Class\n */\nexport class DisneyPark extends Park {\n  /**\n   * Create a new DisneyPark object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.resort_id = options.resort_id || '';\n    options.park_id = options.park_id || '';\n\n    if (!options.configPrefixes) {\n      options.configPrefixes = ['wdw'];\n    }\n\n    super(options);\n\n    if (this.config.park_id === '') {\n      throw new Error(`Missing park_id for class ${this.constructor.name}`);\n    }\n    if (this.config.resort_id === '') {\n      throw new Error(`Missing resort_id for class ${this.constructor.name}`);\n    }\n\n    this.refurbs = [];\n  }\n\n  /**\n * Get the live WDW database object\n * @return {object} wdwdb live database instance\n */\n  static getDatabase() {\n    if (!wdwDB) {\n      wdwDB = new IndexedWDWDB();\n    }\n    return wdwDB;\n  }\n\n  /**\n   * Get the channel ID for the facility status live update documents\n   * @return {string}\n   */\n  getFacilityStatusChannelID() {\n    return `${this.config.resort_id}.facilitystatus.1_0`;\n  }\n\n  /**\n   * Get calendar document ID for resort. This will include closures, refurbishments etc.\n   * @param {Moment} date\n   * @return {string} Document ID\n   */\n  getCalendarDocumentIDForDate(date) {\n    return `${this.config.resort_id}.calendar.1_0.${date.format('DD-MM')}`;\n  }\n\n  /**\n   * Get calendar data from WDW database for a given date\n   * @param {Moment} date\n   */\n  async getDatabaseCalendarForDate(date) {\n    const docID = this.getCalendarDocumentIDForDate(date);\n    await this.init(); // make sure we're setup\n    return await this.db.get(docID);\n  }\n\n  /**\n   * Update resort's refurbishment data\n   */\n  async updateRefurbishments() {\n    const calendar = await this.getDatabaseCalendarForDate(await this.getActiveParkDateMoment());\n    const refurbData = calendar?.refurbishments;\n\n    // capture rides previously down for refurb and mark them as closed instead\n    const oldRefurbs = JSON.parse(JSON.stringify(this.refurbs));\n\n    this.refurbs = [];\n    for (let i=0; i<refurbData.length; i++) {\n      if (refurbData[i].scheduleType !== 'Refurbishment') continue;\n\n      const entityID = getEntityID(refurbData[i].facilityId);\n      // search our index to make sure this attraction is in the correct park\n      const updateIndexEntry = await this.db.getEntityIndex(entityID, {\n        park_id: `${this.config.park_id}`,\n      });\n\n      if (updateIndexEntry.length === 0) continue;\n\n      this.refurbs.push({\n        entityID,\n      });\n    }\n\n    // mark attractions that were previously refurbed, but now aren't, as closed instead\n    for (let i=0; i<oldRefurbs.length; i++) {\n      if (this.refurbs.findIndex((x) => x.entityID === oldRefurbs[i].entityID) < 0) {\n        await this.updateAttractionState(oldRefurbs[i].entityID, statusType.closed);\n      }\n    }\n\n    // mark any entities in refurb list as down for refurbishment\n    for (let i=0; i<this.refurbs.length; i++) {\n      await this.updateAttractionState(this.refurbs[i].entityID, statusType.refurbishment);\n    }\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _dateRefresh(newDate, oldDate) {\n    // date has changed for our resort, update daily refurbishment schedule\n    await this.updateRefurbishments();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _init() {\n    // get a reference to our shared live database\n    this.db = DisneyPark.getDatabase();\n\n    // make sure the shared database is initialised\n    await this.db.init();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _postInit() {\n    // fetch latest refurb data\n    await this.updateRefurbishments();\n\n    // subscribe to any live facility status updates\n    this.db.subscribeToChannel(this.getFacilityStatusChannelID(), async (doc) => {\n      this._processAttractionStatusUpdate(doc);\n    });\n\n    // fetch the current attraction times\n    const allStatusDocs = await this.db.getByChannel(this.getFacilityStatusChannelID());\n    await Promise.allSettled(allStatusDocs.map(this._processAttractionStatusUpdate.bind(this)));\n  }\n\n  /**\n   * Process a document update from a facilitystatus channel\n   * @param {object} doc The updated document\n   */\n  async _processAttractionStatusUpdate(doc) {\n    // get our clean attraction ID\n    const entityID = getEntityID(doc.id);\n\n    // check attraction is within our park\n    const updateIndexEntry = await this.db.getEntityIndex(entityID, {\n      park_id: `${this.config.park_id}`,\n    });\n\n    // if we have no entries, then attraction is not in our park\n    if (updateIndexEntry.length === 0) {\n      return;\n    }\n\n    // get full attraction document\n    let attraction;\n    try {\n      attraction = await this.db.get(updateIndexEntry[0]._id);\n    } catch (e) {\n      return;\n    }\n    if (attraction === undefined) return;\n\n    // figure out general ride status\n    let status = statusType.operating;\n\n    // if our status document contains singleRider, then tag it\n    //  this is only available in live data, so we have to do it in our update\n    await this.toggleAttractionTag(entityID, tagType.singleRider, !!doc.singleRider);\n\n    // restaurants can have status \"Capacity\", \"Walk-Up Disabled\"\n    //  currently these fallback to \"Operating\", which matches the resturant state well enough\n\n    if (doc.status === 'Down') {\n      status = statusType.down;\n    } else if (doc.status === 'Closed') {\n      status = statusType.closed;\n    } else if (doc.status === 'Refurbishment') {\n      status = statusType.refurbishment;\n    }\n    // TODO - \"Virtual Queue\" status\n\n    // if name contains \"Temporarily Unavailable\", mark as closed\n    if (attraction.name.indexOf(' - Temporarily Unavailable') > 0) {\n      status = statusType.closed;\n    }\n\n    // check our refurb data and override any incoming status\n    if (this.refurbs.find((x) => x.entityID === entityID) !== undefined) {\n      status = statusType.refurbishment;\n    }\n\n    if (status == statusType.operating) {\n      // override status if the lastUpdate is really out-of-date\n      const statusUpdateTime = moment(doc.lastUpdate);\n      const now = this.getTimeNowMoment();\n      if (now.diff(statusUpdateTime, 'days') > 2) {\n        status = statusType.closed;\n        doc.waitMinutes = null;\n      }\n    }\n\n    // update attraction state\n    await this.updateAttractionState(entityID, status);\n\n    // update attraction standby queue\n    await this.updateAttractionQueue(entityID, doc.waitMinutes, queueType.standBy);\n\n    // if the ride has a single rider queue, record one with \"null\" to say it exists, we just don't it's length\n    await this.updateAttractionQueue(entityID, !!doc.singleRider ? null : undefined, queueType.singleRider);\n  }\n\n  /**\n   * Build an attraction object from an ID\n   * @param {string} attractionID Unique Attraction ID\n   */\n  async _buildAttractionObject(attractionID) {\n    // find a document for our attraction ID\n    const attr = await this.db.getEntityOne(attractionID);\n    if (attr) {\n      const tags = [];\n\n      // pregnant persons advisory\n      const pregnantWarning = attr.facets && !!attr.facets.find((f) => f.id === 'expectant-mothers');\n      tags.push({\n        type: tagType.unsuitableForPregnantPeople,\n        value: pregnantWarning,\n      });\n\n      // fast pass\n      tags.push({\n        type: tagType.fastPass,\n        value: !!attr.fastPassPlus,\n      });\n\n      // TODO - min height\n\n      if (attr.longitude && attr.latitude) {\n        // ride location tag\n        tags.push({\n          key: 'location',\n          type: tagType.location,\n          value: {\n            longitude: Number(attr.longitude),\n            latitude: Number(attr.latitude),\n          },\n        });\n      }\n\n      let attrEntityType = entityType.attraction;\n\n      if (attr.type.toLowerCase() === 'restaurant') {\n        attrEntityType = entityType.restaurant;\n      }\n\n      return {\n        name: attr.name,\n        entityType: attrEntityType,\n        type: attr.type === 'Attraction' ? attractionType.ride : attractionType.other, // TODO - sort attraction types\n        tags,\n      };\n    }\n\n    return undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _update() {\n    // TODO - parks that don't use the live database need to implement this function\n  }\n\n  /**\n   * Return the operating hours for the supplied date\n   * @param {moment} date\n   */\n  async _getOperatingHoursForDate(date) {\n    // TODO - wrap/cache this in Park so we don't keep fetching this date all the time\n    const dateCalendar = await this.db.getByChannel(\n        `${this.config.resort_id}.calendar.1_0`,\n        {\n          'id': date.format('DD-MM'),\n        },\n    );\n\n    if (dateCalendar.length >= 1) {\n      const calendar = dateCalendar[0];\n\n      const validHours = calendar.parkHours.filter((h) => {\n        // filter by hours for this park\n        return getEntityID(h.facilityId) === this.config.park_id &&\n        // that aren't closed hours (just ignore these)\n          h.scheduleType !== 'Closed' &&\n        // ignore annual pass blockout data\n        h.scheduleType.indexOf('blockout') < 0;\n      });\n\n      return validHours.map((x) => {\n        let hoursType = scheduleType.operating;\n\n        switch (x.scheduleType) {\n          case 'Operating':\n            hoursType = scheduleType.operating;\n            break;\n          case 'Park Hopping':\n            hoursType = scheduleType.informational;\n            break;\n          default:\n            // default to a ticketed event\n            hoursType = scheduleType.ticketed;\n            break;\n        }\n\n        return {\n          openingTime: moment(x.startTime).tz(this.config.timezone).format(),\n          closingTime: moment(x.endTime).tz(this.config.timezone).format(),\n          type: hoursType,\n          description: hoursType != scheduleType.operating ? x.scheduleType : undefined,\n        };\n      });\n    }\n\n    return undefined;\n  }\n}\n\nexport default DisneyPark;\n\n/**\n * Walt Disney World - Magic Kingdom\n */\nexport class WaltDisneyWorldMagicKingdom extends DisneyPark {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.park_id = '80007944';\n    options.resort_id = 'wdw';\n    options.name = 'Walt Disney World - Magic Kingdom';\n    options.timezone = 'America/New_York';\n\n    super(options);\n  }\n}\n\n/**\n * Walt Disney World - Epcot\n */\nexport class WaltDisneyWorldEpcot extends DisneyPark {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.park_id = '80007838';\n    options.resort_id = 'wdw';\n    options.name = 'Walt Disney World - Epcot';\n    options.timezone = 'America/New_York';\n\n    super(options);\n  }\n}\n\n/**\n * Walt Disney World - Hollywood Studios\n */\nexport class WaltDisneyWorldHollywoodStudios extends DisneyPark {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.park_id = '80007998';\n    options.resort_id = 'wdw';\n    options.name = 'Walt Disney World - Hollywood Studios';\n    options.timezone = 'America/New_York';\n\n    super(options);\n  }\n}\n\n/**\n * Walt Disney World - Animal Kingdom\n */\nexport class WaltDisneyWorldAnimalKingdom extends DisneyPark {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.park_id = '80007823';\n    options.resort_id = 'wdw';\n    options.name = 'Walt Disney World - Animal Kingdom';\n    options.timezone = 'America/New_York';\n\n    super(options);\n  }\n}\n\n/**\n * Disneyland Resort - Magic Kingdom\n */\nexport class DisneylandResortMagicKingdom extends DisneyPark {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.park_id = '330339';\n    options.resort_id = 'dlr';\n    options.name = 'Disneyland Resort - Magic Kingdom';\n    options.timezone = 'America/Los_Angeles';\n\n    super(options);\n  }\n}\n\n/**\n * Disneyland Resort - California Adventure\n */\nexport class DisneylandResortCaliforniaAdventure extends DisneyPark {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.park_id = '336894';\n    options.resort_id = 'dlr';\n    options.name = 'Disneyland Resort - California Adventure';\n    options.timezone = 'America/Los_Angeles';\n\n    super(options);\n  }\n}\n\n/**\n * Hong Kong Disneyland\n */\nexport class HongKongDisneylandPark extends DisneyPark {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.park_id = 'desHongKongDisneyland';\n    options.resort_id = 'hkdl';\n    options.name = 'Hong Kong Disneyland - Hong Kong Disneyland Park';\n    options.timezone = 'Asia/Hong_Kong';\n\n    super(options);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 311,
    "kind": "variable",
    "name": "wdwDB",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~wdwDB",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 312,
    "kind": "class",
    "name": "DisneyPark",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{DisneyPark}",
    "description": "Base Disney Park Class",
    "lineNumber": 11,
    "interface": false,
    "extends": [
      "lib/parks/park.js~Park"
    ]
  },
  {
    "__docId__": 313,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#constructor",
    "access": "public",
    "description": "Create a new DisneyPark object",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 314,
    "kind": "member",
    "name": "refurbs",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#refurbs",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "method",
    "name": "getDatabase",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark.getDatabase",
    "access": "public",
    "description": "Get the live WDW database object",
    "lineNumber": 40,
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "wdwdb live database instance"
    },
    "params": []
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "getFacilityStatusChannelID",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#getFacilityStatusChannelID",
    "access": "public",
    "description": "Get the channel ID for the facility status live update documents",
    "lineNumber": 51,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 317,
    "kind": "method",
    "name": "getCalendarDocumentIDForDate",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#getCalendarDocumentIDForDate",
    "access": "public",
    "description": "Get calendar document ID for resort. This will include closures, refurbishments etc.",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "Moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Document ID"
    }
  },
  {
    "__docId__": 318,
    "kind": "method",
    "name": "getDatabaseCalendarForDate",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#getDatabaseCalendarForDate",
    "access": "public",
    "description": "Get calendar data from WDW database for a given date",
    "lineNumber": 68,
    "params": [
      {
        "nullable": null,
        "types": [
          "Moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 319,
    "kind": "method",
    "name": "updateRefurbishments",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#updateRefurbishments",
    "access": "public",
    "description": "Update resort's refurbishment data",
    "lineNumber": 77,
    "params": [],
    "return": null
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "_dateRefresh",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_dateRefresh",
    "access": "private",
    "description": "",
    "lineNumber": 117,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "newDate",
        "types": [
          "*"
        ]
      },
      {
        "name": "oldDate",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 322,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_init",
    "access": "private",
    "description": "",
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 323,
    "kind": "member",
    "name": "db",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#db",
    "access": "public",
    "description": null,
    "lineNumber": 127,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "method",
    "name": "_postInit",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_postInit",
    "access": "private",
    "description": "",
    "lineNumber": 136,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 325,
    "kind": "method",
    "name": "_processAttractionStatusUpdate",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_processAttractionStatusUpdate",
    "access": "private",
    "description": "Process a document update from a facilitystatus channel",
    "lineNumber": 154,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "The updated document"
      }
    ],
    "return": null
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_buildAttractionObject",
    "access": "private",
    "description": "Build an attraction object from an ID",
    "lineNumber": 230,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_update",
    "access": "private",
    "description": "",
    "lineNumber": 283,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 328,
    "kind": "method",
    "name": "_getOperatingHoursForDate",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_getOperatingHoursForDate",
    "access": "private",
    "description": "Return the operating hours for the supplied date",
    "lineNumber": 291,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 329,
    "kind": "class",
    "name": "WaltDisneyWorldMagicKingdom",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldMagicKingdom",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{WaltDisneyWorldMagicKingdom}",
    "description": "Walt Disney World - Magic Kingdom",
    "lineNumber": 346,
    "interface": false,
    "extends": [
      "DisneyPark"
    ]
  },
  {
    "__docId__": 330,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldMagicKingdom",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldMagicKingdom#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 350,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 331,
    "kind": "class",
    "name": "WaltDisneyWorldEpcot",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldEpcot",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{WaltDisneyWorldEpcot}",
    "description": "Walt Disney World - Epcot",
    "lineNumber": 363,
    "interface": false,
    "extends": [
      "DisneyPark"
    ]
  },
  {
    "__docId__": 332,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldEpcot",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldEpcot#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 367,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 333,
    "kind": "class",
    "name": "WaltDisneyWorldHollywoodStudios",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldHollywoodStudios",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{WaltDisneyWorldHollywoodStudios}",
    "description": "Walt Disney World - Hollywood Studios",
    "lineNumber": 380,
    "interface": false,
    "extends": [
      "DisneyPark"
    ]
  },
  {
    "__docId__": 334,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldHollywoodStudios",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldHollywoodStudios#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 384,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 335,
    "kind": "class",
    "name": "WaltDisneyWorldAnimalKingdom",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldAnimalKingdom",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{WaltDisneyWorldAnimalKingdom}",
    "description": "Walt Disney World - Animal Kingdom",
    "lineNumber": 397,
    "interface": false,
    "extends": [
      "DisneyPark"
    ]
  },
  {
    "__docId__": 336,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldAnimalKingdom",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldAnimalKingdom#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 401,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 337,
    "kind": "class",
    "name": "DisneylandResortMagicKingdom",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneylandResortMagicKingdom",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{DisneylandResortMagicKingdom}",
    "description": "Disneyland Resort - Magic Kingdom",
    "lineNumber": 414,
    "interface": false,
    "extends": [
      "DisneyPark"
    ]
  },
  {
    "__docId__": 338,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneylandResortMagicKingdom",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneylandResortMagicKingdom#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 418,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 339,
    "kind": "class",
    "name": "DisneylandResortCaliforniaAdventure",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneylandResortCaliforniaAdventure",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{DisneylandResortCaliforniaAdventure}",
    "description": "Disneyland Resort - California Adventure",
    "lineNumber": 431,
    "interface": false,
    "extends": [
      "DisneyPark"
    ]
  },
  {
    "__docId__": 340,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneylandResortCaliforniaAdventure",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneylandResortCaliforniaAdventure#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 435,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 341,
    "kind": "class",
    "name": "HongKongDisneylandPark",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~HongKongDisneylandPark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{HongKongDisneylandPark}",
    "description": "Hong Kong Disneyland",
    "lineNumber": 448,
    "interface": false,
    "extends": [
      "DisneyPark"
    ]
  },
  {
    "__docId__": 342,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~HongKongDisneylandPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~HongKongDisneylandPark#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 452,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 343,
    "kind": "file",
    "name": "lib/parks/wdw/wdwdatabase.js",
    "content": "import Database from '../database.js';\nimport WDWDB from './wdwdb.js';\n\n/**\n * @inheritdoc\n */\nexport class DatabaseWDW extends Database {\n  /**\n   * @inheritdoc\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    super(options);\n\n    this.db = new WDWDB();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getEntities() {\n    // make sure our synced database is up-to-date\n    await this.db.init();\n  }\n}\n\nexport default DatabaseWDW;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/wdw/wdwdatabase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 344,
    "kind": "class",
    "name": "DatabaseWDW",
    "memberof": "lib/parks/wdw/wdwdatabase.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdatabase.js",
    "importStyle": "{DatabaseWDW}",
    "description": "",
    "lineNumber": 7,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "lib/parks/database.js~Database"
    ]
  },
  {
    "__docId__": 345,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 346,
    "kind": "member",
    "name": "db",
    "memberof": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW",
    "static": false,
    "longname": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW#db",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "_getEntities",
    "memberof": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW#_getEntities",
    "access": "private",
    "description": "",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 348,
    "kind": "file",
    "name": "lib/parks/wdw/wdwdb.js",
    "content": "import PouchDB from 'pouchdb';\nimport ReplicationStream from 'pouchdb-replication-stream';\nimport sift from 'sift';\nimport {promises as fs, constants as fsConstants, createReadStream, createWriteStream} from 'fs';\nimport path from 'path';\n\nimport {parseConfig} from '../../configBase.js';\n\n/**\n * Given a document, return it's entity ID for the WDW database\n * @param {object|string} doc CouchDB document or a document ID\n * @return {string}\n */\nexport function getEntityID(doc) {\n  const docId = doc?.id || doc;\n\n  if (!docId) {\n    console.trace('Unable to find ID from', JSON.stringify(doc));\n    return undefined;\n  }\n\n  const stack = docId.split(':');\n  const lowestLevelEntity = stack[stack.length - 1];\n\n  const parts = lowestLevelEntity.split(';');\n  if (parts <= 1) return undefined;\n\n  return parts.find((p) => {\n    // edge-case for some documents with no attraction attached (guessing test documents)\n    if (p === 'Unassigned') return false;\n\n    const keyval = p.split('=');\n    return (keyval.length === 1);\n  });\n}\n\n// internal key names for our indexes. Stored as constants to save typing these over and over\nconst constants = {\n  INDEX_FACILITYSTATUS: 'facilityStatus',\n  INDEX_CHANNELS: 'channels',\n  INDEX_ENTITIES: 'entities',\n  INDEX_CHILDREN: 'children',\n  INDEX_NAMES: 'names',\n};\n\n// ancestors to include in our index\n//  we add these into our index objects to identify unique documents to index\nconst ancestorIndexes = [\n  {\n    key: 'ancestorLandId',\n    index: 'land_id',\n  },\n  {\n    key: 'ancestorResortId',\n    index: 'resort_id',\n  },\n  {\n    key: 'ancestorResortAreaId',\n    index: 'resort_area_id',\n  },\n  {\n    key: 'ancestorThemeParkId',\n    index: 'park_id',\n  },\n];\n\n// Super() function to call when we setup this class as a plugin\nconst pouchBulkDocs = PouchDB.prototype.bulkDocs;\n\n/**\n * An indexed live WDW database\n * Replicated WDW database to local disk for fast access\n * While replicating, will build an in-memory index of entities for fast lookup\n * Options to dump database to a single file or load a snapshot for quicker database boot ups\n */\nexport class IndexedWDWDB extends PouchDB {\n  /**\n   * Construct a new IndexedWDWDB object\n   * @param {object} opts PouchDB options object\n   * @param {string} [opts.remoteHost] Remote database to replicate\n   * @param {string} [opts.remoteUsername] Remote database username to authenticate\n   * @param {string} [opts.remotePassword] Remote database password to authenticate\n   * @param {string} [opts.dbName='wdw'] Local database name\n   * @param {string} [opts.snapshot] File location of a snapshot to 'seed' the database during startup\n   * @param {string} [opts.skipSync] Skip network replication, only use data already on disk\n   * @extends PouchDB\n   */\n  constructor(opts = {}) {\n    // default to enable auto_compaction\n    opts.auto_compaction = opts.auto_compaction || true;\n\n    opts.remoteHost = '';\n    opts.remoteUsername = '';\n    opts.remotePassword = '';\n    opts.dbName = opts.dbName || 'wdw';\n    opts.snapshot = ''; // optional snapshot to use when starting database\n    // 'name' is the config option pouchdb uses for the storage path\n    opts.name = opts.name || IndexedWDWDB.getDatabaseFilePath(opts.dbName);\n\n    opts.skipSync = opts.skipSync === undefined ? false : opts.skipSync;\n\n    opts.restartTimeout = opts.restartTimeout || 5;\n\n    opts.configPrefixes = ['WDWDB'].concat(opts.configPrefixes || []);\n    const config = parseConfig(opts);\n\n    super(config);\n    this.config = config;\n\n    // increase the maximum listeners to this database\n    this.setMaxListeners(50);\n\n    // setup our remote host to replicate locally\n    if (this.config.remoteHost) {\n      const remoteHostOptions = {\n        skip_setup: true,\n      };\n      if (this.config.remoteUsername && this.config.remotePassword) {\n        remoteHostOptions.auth = {\n          username: this.config.remoteUsername,\n          password: this.config.remotePassword,\n        };\n      }\n\n      this.remoteDB = new PouchDB(this.config.remoteHost, remoteHostOptions);\n    }\n\n    this.synced = false;\n    this.replicating = false;\n\n    this._index = {};\n    this._setupPromise = null;\n    this._indexSetup = false;\n  }\n\n  /**\n * Get the LevelDOWN database location to use\n * @param {string} name Database name\n * @return {string}\n */\n  static getDatabaseFilePath(name) {\n    return path.join(process.cwd(), `db.${name}`);\n  }\n\n  /**\n   * Initialise the live database, returns once finished an initial sync\n   */\n  async init() {\n    if (this.synced) {\n      return;\n    }\n\n    if (this.initPromiseSync) return this.initPromiseSync;\n\n    // first, syncronise our database before we start rolling updates\n    this.initPromiseSync = this._loadAndInit();\n    // keep the Promise as a variable so we can keep returning it for any additional init() calls\n    await this.initPromiseSync;\n    this.initPromiseSync = null;\n\n    console.log(`Database finished setup!`);\n\n    this.synced = true;\n\n    if (!this.config.skipSync && this.remoteDB) {\n      this._replicate();\n    }\n  }\n\n  /**\n   * Start database replication\n   * @private\n   */\n  _replicate() {\n    if (this.replicating) return;\n    this.replicating = true;\n\n    let noChangeTimeout = null;\n    let replicationHandle = null;\n\n    // how many minutes before killing and restarting replication\n    const noChangeTimer = Number(this.config.restartTimeout) || 5;\n\n    // function to reboot the replicate based on various possible failure states\n    const rebootReplicator = (err) => {\n      if (noChangeTimeout) {\n        clearTimeout(noChangeTimeout);\n      }\n      if (replicationHandle) {\n        replicationHandle.cancel();\n        replicationHandle = null;\n      }\n\n      if (err) {\n        console.error('Replication Error!', new Date(), err);\n      }\n\n      console.log('Restarting replicator...');\n      this.replicating = false;\n      setTimeout(this._replicate.bind(this), 1000);\n    };\n\n    const resetTimeoutTimer = () => {\n      if (noChangeTimeout) {\n        clearTimeout(noChangeTimeout);\n      }\n      noChangeTimeout = setTimeout(() => {\n        console.log('Replicator timed out...');\n        rebootReplicator();\n      }, 1000 * 60 * noChangeTimer);\n    };\n\n    try {\n      replicationHandle = PouchDB.replicate(this.remoteDB, this, {\n        live: true,\n        retry: true,\n      }).on('change', () => {\n        // reset a timer whenever we get a change\n        //  if the timer is ever fired, we will restart the replicator\n        resetTimeoutTimer();\n      }).on('error', (e) => {\n        rebootReplicator(e);\n      });\n\n      // always start the change timer immediately\n      //  otherwise if we start repliating in the middle of the night (when no changes are happening)\n      //  on('change') never fires, so we can lose connection and never fire the timeout\n      resetTimeoutTimer();\n    } catch (e) {\n      rebootReplicator(e);\n    }\n  }\n\n  /**\n   * Internal function\n   * Loads and performs an initial sync on the database\n   * @private\n   */\n  async _loadAndInit() {\n    // first, try and restore from disk (will check if an existing snapshot exists)\n    await this.loadSnapshot();\n\n    // load up our indexes\n    await this._initIndexes();\n\n    // reindex every document once we've initialised from disk\n    //  do this before replication, since all new docs will be auto-indexed\n    const docs = await this.allDocs({\n      include_docs: true,\n    });\n    console.log('Building index...');\n    await Promise.allSettled(docs.rows.map((doc) => {\n      return this._indexWDWDocument(doc.doc);\n    }));\n\n    // optionally skip replicating with remote (for local fast testing)\n    if (this.config.skipSync || !this.remoteDB) {\n      return;\n    }\n\n    // then perform an initial replication from remote to local\n    console.log('Performing initial replication...');\n    return await PouchDB.replicate(this.remoteDB, this, {\n      batch_size: 500,\n    }).catch((e) => {\n      console.error(`Replication error: ${e}`);\n    });\n  }\n\n  /**\n   * Get the filename we use for saving backups of the database to disk\n   * Used for creating simple \"snapshots\" to reduce initial sync times\n   * @param {string} [postfix] Optional postfix for the filename\n   * eg. Use postfix to generate a temporary version of a file to write to before replacing the \"real\" database\n   * @return {string}\n   */\n  getDumpFilename(postfix = '') {\n    return path.join('localdb', `${this.config.dbName}${postfix}.db`);\n  }\n\n  /**\n   * Restore a database backup from disk\n   * Perform this after running \"dump()\" on a previous synced database\n   * This will help to reduce the initial sync time for large databases\n   * @param {string} [snapshotFile] File path of the snapshot to restore into the database\n   * snapshotFile will use default saveSnapshot result location if not supplied\n   */\n  async loadSnapshot(snapshotFile = '') {\n    if (this.synced || this.replicating) {\n      console.warn('Trying to load database snapshot when replication has already started');\n      return;\n    }\n\n    const useCustomSnapshot = !!snapshotFile;\n    const dumpPath = useCustomSnapshot ? snapshotFile : this.getDumpFilename();\n\n    // if our database dump doesn't exist, then early out and we'll do a normal sync\n    try {\n      await fs.access(dumpPath, fsConstants.F_OK);\n    } catch (error) {\n      return;\n    }\n\n    console.log('Restoring database from disk...');\n\n    // otherwise, load up our database from disk\n    const ws = createReadStream(dumpPath);\n    return this.load(ws, {\n      batch_size: 500,\n    });\n  }\n\n  /**\n   * Save a snapshot of this live database to disk\n   * This will be used to \"seed\" the database to speed up syncs for future runs\n   * @return {string} Path to resulting database snapshot\n   */\n  async saveSnapshot() {\n    if (this.databaseDumpPendingPromise) {\n      return this.databaseDumpPendingPromise;\n    }\n\n    console.log('Dumping database to disk...');\n\n    const dumpPath = this.getDumpFilename();\n    const dumpPathNew = this.getDumpFilename('_new');\n\n    // dump database to our new location\n    const ws = createWriteStream(dumpPathNew);\n    this.databaseDumpPendingPromise = this.dump(ws, {\n      batch_size: 500,\n    });\n    // save Promise so multiple \"dump()\" calls can stack cleanly\n    await this.databaseDumpPendingPromise;\n    this.databaseDumpPendingPromise = null;\n\n    // rename new database dump to our final intended location\n    return fs.rename(dumpPathNew, dumpPath).then(() => {\n      // finally, return the actual path of the snapshot\n      return dumpPath;\n    });\n  }\n\n  /**\n   * Index initialisation\n   * This function wraps taking care of creating our indexes once only\n   * @private\n   */\n  async _initIndexes() {\n    if (this._indexSetup) {\n      return;\n    }\n\n    if (this._setupPromise) {\n      return this._setupPromise;\n    }\n\n    this._setupPromise = this._createIndexes();\n    await this._setupPromise;\n    this._indexSetup = true;\n    return;\n  }\n\n  /**\n   * Setup our WDW indexes\n   * @private\n   */\n  async _createIndexes() {\n    await this._createIndex(constants.INDEX_ENTITIES);\n    await this._createIndex(constants.INDEX_CHANNELS);\n    await this._createIndex(constants.INDEX_FACILITYSTATUS, []);\n    await this._createIndex(constants.INDEX_CHILDREN);\n    await this._createIndex(constants.INDEX_NAMES);\n  }\n\n  /**\n   * Get the internal index object for the given index type\n   * @param {object} name Index name (see constants.INDEX_*)\n   * @return {*}\n   * @private\n   */\n  getIndex(name) {\n    return this._index[name].index;\n  }\n\n  /**\n   * Create an index object to be used by this database\n   * @param {string} name Index name\n   * @param {*} defaultIndex Index initial object state\n   * @private\n   */\n  async _createIndex(name, defaultIndex = {}) {\n    this._index[name] = {\n      index: defaultIndex,\n    };\n  }\n\n  /**\n   * Given a WDW document, extract key identifiable data\n   * This is used to build a look-up index of unique document types\n   * See ancestorIndexes for some of the keys we use\n   * This is important so we can tell the difference between entities with the same ID, but different purposes\n   * eg. an entity ID can have multiple documents, one for the attraction itself, one for it's wait times, etc.\n   * These need to both be in the index under the same entity ID, but with different properties to make them distinct\n   * @param {object} doc WDW Database Document\n   * @return {object} Index object containing important identifying data\n   * @private\n   */\n  _extractEntityKeys(doc) {\n    if (!doc || !doc.id) return undefined;\n\n    // some IDs are stacked using :\n    const stack = doc.id.split(':');\n    const lowestLevelEntity = stack[stack.length - 1];\n\n    const parts = lowestLevelEntity.split(';');\n    if (parts <= 1) return undefined;\n\n    // some documents can have different parents, they're the same, but different path to get there\n    const parentStackEl = stack.length > 1 ? stack[stack.length - 2] : undefined;\n    const parent = parentStackEl ? this._extractEntityKeys({id: parentStackEl}).id : undefined;\n\n    const ret = {\n      parent,\n    };\n\n    // special case for calendars\n    if (doc.channels.find((x) => x.indexOf('.calendar.') >= 0) !== undefined) {\n      ret.entityType = 'calendar';\n    }\n\n    parts.forEach((p) => {\n      const keyval = p.split('=');\n      if (keyval.length === 1) {\n        ret.id = keyval[0];\n      } else {\n        ret[keyval[0]] = keyval[1];\n      }\n    });\n\n    // if this document is in a \"facilitystatus\" channel, add an extra tag\n    //  this is so we don't collide with the actaul document for this attraction\n    //  but also so we can filter it easier later\n    const facilityStatus = doc.channels && (doc.channels.find((x) => x.indexOf('facilitystatus') >= 0) !== undefined);\n    if (facilityStatus) {\n      ret.facilityStatus = true;\n    }\n\n    // include channels in our index\n    if (doc.channels) {\n      const channels = JSON.parse(JSON.stringify(doc.channels));\n      channels.sort();\n      ret.channel = channels.join(',');\n    }\n\n    // add any ancestor data to our index (that we a) care about and b) can find) - see ancestorIndexes\n    ancestorIndexes.forEach((ancestorIndex) => {\n      if (doc[ancestorIndex.key]) {\n        const ancestorID = getEntityID(doc[ancestorIndex.key]);\n        if (ancestorID) {\n          ret[ancestorIndex.index] = ancestorID;\n        }\n      }\n    });\n\n    return ret;\n  }\n\n  /**\n   * Given a WDW database document, try to return its language\n   * @param {object} doc\n   * @return {string} Language of this document. Eg. en_intl, en_us\n   * @private\n   */\n  _extractChannelLanguage(doc) {\n    // pull channel from doc\n    if (!doc.channels) return undefined;\n\n    const langs = doc.channels.map((x) => {\n      // extract last \\.* from the end of the channel name\n      // language-specific channels end with \"en_us\" or something\n      // channels without locale end with a version number eg. \"1_0\"\n      return x.slice(x.lastIndexOf('.') + 1);\n    }).filter((x) => {\n      // check each one to see the language tag starts with a version number\n      return isNaN(Number(x.slice(0, 1)));\n    });\n\n    // default to 'en_intl' if we cannot find a language in our channels\n    return langs[0] || 'en_intl';\n  }\n\n  /**\n   * Remove all indexes referencing docID from the given index\n   * @param {object} index\n   * @param {string} docID\n   */\n  _removeFromArrayIndex(index, docID) {\n    Object.keys(index).forEach((key) => {\n      const indexIDs = index[key].map(\n          (x, idx) => {\n            return x._id === docID ? idx : undefined;\n          }).\n          filter((x) => x !== undefined);\n\n      indexIDs.forEach((idx) => {\n        index[key].splice(idx, 1);\n      });\n    });\n  }\n\n  /**\n   * Add a document to the database index\n   * Used for fast lookups of entities etc. to the correct documents\n   * @param {object} doc CouchDB document to index\n   * @private\n   */\n  async _indexWDWDocument(doc) {\n    if (doc._deleted) {\n      // remove document from all indexes\n\n      // facility status\n      //  quick hack to turn the facility status index into the same type as the others so I can reuse my code\n      const facilityIndexObject = {index: this.getIndex(constants.INDEX_FACILITYSTATUS)};\n      this._removeFromArrayIndex(facilityIndexObject, doc._id);\n\n      // channels\n      this._removeFromArrayIndex(this.getIndex(constants.INDEX_CHANNELS), doc._id);\n\n      // entity index\n      this._removeFromArrayIndex(this.getIndex(constants.INDEX_ENTITIES), doc._id);\n\n      // ancestor data\n      //  look through all ancestor index items and remove this document\n      const childIndex = this.getIndex(constants.INDEX_CHILDREN);\n      const indexIDs = Object.keys(childIndex);\n      indexIDs.forEach((index) => {\n        const idx = childIndex[index].indexOf(doc._id);\n        if (idx >= 0) {\n          childIndex[index].splice(idx, 1);\n        }\n      });\n\n      // name index\n      const nameIndex = this.getIndex(constants.INDEX_NAMES);\n      const nameIndexIDs = Object.keys(nameIndex);\n      nameIndexIDs.forEach((index) => {\n        const idx = childIndex[index].indexOf(doc._id);\n        if (idx >= 0) {\n          childIndex[index].splice(idx, 1);\n        }\n      });\n\n      return;\n    }\n\n    const entity = this._extractEntityKeys(doc);\n    if (entity && entity.id && entity.entityType) {\n      const id = entity.id;\n\n      const newIndexEntry = {\n        ...entity,\n        language: this._extractChannelLanguage(doc),\n        _id: doc._id,\n      };\n\n      // special-case, index all facility status documents in another index\n      if (newIndexEntry.facilityStatus) {\n        const facilityIndex = this.getIndex(constants.INDEX_FACILITYSTATUS);\n\n        const docExists = facilityIndex.findIndex((x) => {\n          return x.id === newIndexEntry.id;\n        });\n        if (docExists >= 0) {\n          facilityIndex[docExists] = newIndexEntry;\n        } else {\n          facilityIndex.push(newIndexEntry);\n        }\n      }\n\n      // index all documents based on channel\n      if (doc.channels) {\n        const channelIndex = this.getIndex(constants.INDEX_CHANNELS);\n        doc.channels.forEach((channel) => {\n          if (!channelIndex[channel]) {\n            channelIndex[channel] = [];\n          }\n          channelIndex[channel].push(newIndexEntry);\n        });\n      }\n\n      // index ancestors (so we can find all children of a given entity)\n      const locs = doc?.relatedLocations;\n      if (locs) {\n        const ancestors = locs ? locs.map((x) => x.ancestors || []).flat() : [];\n        const childrenIndex = this.getIndex(constants.INDEX_CHILDREN);\n        for (let i=0; i<ancestors.length; i++) {\n          const entity = getEntityID(ancestors[i].id);\n          if (entity) {\n            // found entity ID for this ancestor, create or update an entry for it\n            if (childrenIndex[entity] === undefined) {\n              childrenIndex[entity] = [];\n            }\n            if (childrenIndex[entity].indexOf(doc._id) < 0) {\n              childrenIndex[entity].push(doc._id);\n            }\n          }\n        }\n      }\n\n      // index document names for text searching\n      let docName = doc?.name;\n      if (docName) {\n        // simplify our doc name to only alphanumeric characters\n        docName = docName.toLowerCase().replace(/[^a-z0-9]/g, '');\n        const nameIndex = this.getIndex(constants.INDEX_NAMES);\n        if (!nameIndex[docName]) {\n          nameIndex[docName] = [];\n        }\n        nameIndex[docName].push(doc._id);\n      }\n\n      const newIndexKeys = Object.keys(newIndexEntry);\n\n      const entityIndex = this.getIndex(constants.INDEX_ENTITIES);\n      if (!entityIndex[id]) {\n        entityIndex[id] = [];\n      }\n      const findExisting = entityIndex[id].findIndex((x) => {\n        // if # keys are different, not a match\n        if (Object.keys(x).length !== newIndexKeys.length) return false;\n\n        // look for any mismatches between the keys\n        const findMismatch = newIndexKeys.find((key) => {\n          // _id is supposed to be different, so ignore it regardless of if it matches or not\n          if (key === '_id') return false;\n          return (newIndexEntry[key] !== x[key]);\n        });\n        return !findMismatch;\n      });\n\n      if (findExisting < 0) {\n        // entry doesn't exist, add to our list\n        entityIndex[id].push(newIndexEntry);\n      } else {\n        // replace existing entry that matches all the same properties\n        if (entityIndex[id][findExisting]._id !== newIndexEntry._id) {\n          entityIndex[id][findExisting] = newIndexEntry;\n        }\n      }\n    }\n  }\n\n  /**\n   * Get an array of documents from an array of _id\n   * @param {array<string>} ids\n   */\n  async getDocsById(ids) {\n    await this.init();\n\n    return (await Promise.all(ids.map((id) => {\n      // fetch each document using our local DB\n      return this.get(id);\n    }))).filter((doc) => {\n      // filter our any docs that failed to be fetched (they have been deleted etc.)\n      return doc !== undefined;\n    });\n  }\n\n  /**\n   * Find search index entries by ID\n   * If you want the actual document and not just the meta-index data, use getEntity() instead\n   * @param {string} id\n   * @param {object} [filter]\n   * @return {array<object>} Returns the index data for this entity ID\n   */\n  async getEntityIndex(id, filter = {}) {\n    await this.init();\n\n    const entityIndex = this.getIndex(constants.INDEX_ENTITIES);\n    const indexEntry = entityIndex[id];\n    if (!indexEntry) return [];\n\n    // filter entries by supplied filter options before resolving\n    return indexEntry.filter(sift(filter));\n  }\n\n  /**\n   * Return an array of children document IDs for a given entity ID\n   * @param {string} id\n   */\n  async getDocChildren(id) {\n    await this.init();\n\n    const childrenIndex = this.getIndex(constants.INDEX_CHILDREN);\n    const children = childrenIndex[id];\n    if (!children) return [];\n    return children;\n  }\n\n  /**\n   * Very rudementary text search for documents matching the incoming name.\n   * name argument will be stripped of all non-alphanumeric characters for searching.\n   * Will return an array of document IDs with matching name substrings.\n   * @param {string} name\n   */\n  async getDocNameSearch(name) {\n    const searchName = name.toLowerCase().replace(/[^a-z0-9]/g, '');\n    const nameIndex = await this.getIndex(constants.INDEX_NAMES);\n    const names = Object.keys(nameIndex);\n    const found = names.filter((x) => {\n      return x.indexOf(searchName) >= 0;\n    });\n    return found.map((x) => nameIndex[x]).flat();\n  }\n\n  /**\n   * Search for an entity in the WDW database\n   * @param {string} id Entity ID\n   * @param {object} [filter] Filter index by field\n   * @return {array<object>} Returns all documents for this entity ID\n   */\n  async getEntity(id, filter = {}) {\n    const entities = await this.getEntityIndex(id, filter);\n\n    // resolve each index entry to our full documents\n    return this.getDocsById(entities.map((entry) => {\n      return entry._id;\n    }));\n  }\n\n\n  /**\n   * Search for an entity in the WDW database\n   * Attempts to return the \"best candidate\" single document that matches the incoming ID\n   * @param {string} id Entity ID\n   * @param {object} [filter] Optional index filter\n   * @return {object} Returns the best candidate single document, or undefined\n   */\n  async getEntityOne(id, filter = {}) {\n    const entities = await this.getEntityIndex(id, filter);\n    if (entities.length === 0) return undefined;\n\n    // filter to find the best document of the ones available\n    //  prioritise language en_intl\n    const enIntl = entities.find((doc) => {\n      return doc.language === 'en_intl' && !doc.facilityStatus; // don't include facilityStatus docs by-default\n    });\n    if (enIntl) {\n      return await this.get(enIntl._id);\n    }\n\n    //  2nd priority: en_US\n    const enUS = entities.find((doc) => {\n      return doc.language === 'en_us' && !doc.facilityStatus; // don't include facilityStatus docs by-default\n    });\n    if (enUS) {\n      return await this.get(enUS._id);\n    }\n\n    // otherwise just return the first entry in out list\n    return await this.get(entities[0]._id);\n  }\n\n  /**\n   * Get the live facility status for a given entity ID\n   * @param {string} id Entity ID\n   * @return {object} Facility status document, or undefined\n   */\n  async getFacilityStatus(id) {\n    await this.init();\n\n    const statusIndex = this.getIndex(constants.INDEX_FACILITYSTATUS);\n\n    // look up entity ID in our facility status index\n    const indexEntity = statusIndex.find((x) => {\n      return x.id === id;\n    });\n    if (!indexEntity) return undefined;\n\n    return await this.get(indexEntity._id);\n  }\n\n  /**\n   * Find all documents by channel\n   * eg. 'wdw.facilitystatus.1_0' to get all WDW facility status documents\n   * @param {string} channel Channel ID\n   * @param {object} [filter] Optional document index filter\n   * @return {array<object>} All documents in this channel (or empty array)\n   */\n  async getByChannel(channel, filter = {}) {\n    await this.init();\n\n    const channelIndex = this.getIndex(constants.INDEX_CHANNELS);\n\n    const channelData = channelIndex[channel];\n    if (!channelData) {\n      return [];\n    }\n\n    // return resolved documents for the channel\n    return this.getDocsById(channelData.filter(sift(filter)).map((entry) => {\n      return entry._id;\n    }));\n  }\n\n  /**\n   * Return all documents in the database that match the given filter\n   * This is a slow operation! Use sparingly!\n   * @param {object} [filter]\n   * @return {array<object>}\n   */\n  async find(filter = {}) {\n    await this.init();\n\n    const docs = await this.allDocs({\n      include_docs: true,\n    });\n\n    return docs.rows.map((row) => row.doc).filter(sift(filter));\n  }\n\n  /**\n   * Subscribe to all database changes with an optional mongo-style filter\n   * @param {object} [filter]\n   * @param {function} callback\n   */\n  subscribeToChanges(filter, callback) {\n    if (typeof filter === 'function') {\n      // if no filter passed in, call ourselves with an empty set\n      this.subscribeToChanges({}, callback);\n    } else {\n      // listen to changes from now onwards, passing in our filter function\n      this.changes({\n        since: 'now',\n        live: true,\n        include_docs: true,\n        filter: sift(filter),\n      }).on('change', (change) => {\n        callback(change.doc);\n      });\n    }\n  }\n\n  /**\n   * Subscribe to all changes to a channel\n   * @param {string} channel\n   * @param {function} callback\n   */\n  subscribeToChannel(channel, callback) {\n    // only return documents that contain the supplied channel\n    this.subscribeToChanges({\n      channels: {\n        $elemMatch: channel,\n      },\n    }, callback);\n  }\n\n  /**\n   * Plugin function to intercept bulkDocs function\n   * We index any WDW documents we find for easier lookup later\n   * @param  {...any} args bulkDocs in\n   * @private\n   */\n  static async _pluginBulkDocs(...args) {\n    await this._initIndexes();\n\n    const body = args[0];\n    const docs = Array.isArray(body) ? body : body.docs;\n\n    // index each document being added to the database\n    await Promise.allSettled(docs.map((doc) => {\n      return this._indexWDWDocument(doc);\n    }));\n\n    // All documents check out. Pass them to PouchDB.\n    return pouchBulkDocs.call(this, ...args);\n  }\n}\n\n// add our plugin function\nIndexedWDWDB.plugin({\n  bulkDocs: IndexedWDWDB._pluginBulkDocs,\n});\n\n// pouchdb-replication-stream allows us to \"seed\" the database with an initial database dump\n//  incredibly useful for the wdw db, which is pretty huge\nIndexedWDWDB.plugin(ReplicationStream.plugin);\nPouchDB.adapter('writableStream', ReplicationStream.adapters.writableStream);\n\nexport default IndexedWDWDB;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/wdw/wdwdb.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 349,
    "kind": "function",
    "name": "getEntityID",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~getEntityID",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": "{getEntityID}",
    "description": "Given a document, return it's entity ID for the WDW database",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "object",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "CouchDB document or a document ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 350,
    "kind": "variable",
    "name": "constants",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~constants",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "{\"INDEX_FACILITYSTATUS\": string, \"INDEX_CHANNELS\": string, \"INDEX_ENTITIES\": string, \"INDEX_CHILDREN\": string, \"INDEX_NAMES\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 351,
    "kind": "variable",
    "name": "ancestorIndexes",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~ancestorIndexes",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 352,
    "kind": "variable",
    "name": "pouchBulkDocs",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~pouchBulkDocs",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 353,
    "kind": "class",
    "name": "IndexedWDWDB",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": "{IndexedWDWDB}",
    "description": "An indexed live WDW database<br />Replicated WDW database to local disk for fast access<br />While replicating, will build an in-memory index of entities for fast lookup<br />Options to dump database to a single file or load a snapshot for quicker database boot ups",
    "lineNumber": 76,
    "interface": false,
    "extends": [
      "pouchdb~PouchDB"
    ]
  },
  {
    "__docId__": 354,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#constructor",
    "access": "public",
    "description": "Construct a new IndexedWDWDB object",
    "lineNumber": 88,
    "unknown": [
      {
        "tagName": "@extends",
        "tagValue": "PouchDB"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "PouchDB options object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.remoteHost",
        "description": "Remote database to replicate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.remoteUsername",
        "description": "Remote database username to authenticate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.remotePassword",
        "description": "Remote database password to authenticate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wdw'",
        "defaultRaw": "'wdw'",
        "name": "opts.dbName",
        "description": "Local database name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.snapshot",
        "description": "File location of a snapshot to 'seed' the database during startup"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.skipSync",
        "description": "Skip network replication, only use data already on disk"
      }
    ]
  },
  {
    "__docId__": 355,
    "kind": "member",
    "name": "config",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#config",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 356,
    "kind": "member",
    "name": "remoteDB",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#remoteDB",
    "access": "public",
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 357,
    "kind": "member",
    "name": "synced",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#synced",
    "access": "public",
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 358,
    "kind": "member",
    "name": "replicating",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#replicating",
    "access": "public",
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 359,
    "kind": "member",
    "name": "_index",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_index",
    "access": "private",
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 360,
    "kind": "member",
    "name": "_setupPromise",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_setupPromise",
    "access": "private",
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 361,
    "kind": "member",
    "name": "_indexSetup",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_indexSetup",
    "access": "private",
    "description": null,
    "lineNumber": 133,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 362,
    "kind": "method",
    "name": "getDatabaseFilePath",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB.getDatabaseFilePath",
    "access": "public",
    "description": "Get the LevelDOWN database location to use",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Database name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 363,
    "kind": "method",
    "name": "init",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#init",
    "access": "public",
    "description": "Initialise the live database, returns once finished an initial sync",
    "lineNumber": 148,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 364,
    "kind": "member",
    "name": "initPromiseSync",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#initPromiseSync",
    "access": "public",
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "_replicate",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_replicate",
    "access": "private",
    "description": "Start database replication",
    "lineNumber": 174,
    "params": [],
    "return": null
  },
  {
    "__docId__": 370,
    "kind": "method",
    "name": "_loadAndInit",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_loadAndInit",
    "access": "private",
    "description": "Internal function<br />Loads and performs an initial sync on the database",
    "lineNumber": 239,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 371,
    "kind": "method",
    "name": "getDumpFilename",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getDumpFilename",
    "access": "public",
    "description": "Get the filename we use for saving backups of the database to disk<br />Used for creating simple \"snapshots\" to reduce initial sync times",
    "lineNumber": 277,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "postfix",
        "description": "Optional postfix for the filename\neg. Use postfix to generate a temporary version of a file to write to before replacing the \"real\" database"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 372,
    "kind": "method",
    "name": "loadSnapshot",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#loadSnapshot",
    "access": "public",
    "description": "Restore a database backup from disk<br />Perform this after running \"dump()\" on a previous synced database<br />This will help to reduce the initial sync time for large databases",
    "lineNumber": 288,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "snapshotFile",
        "description": "File path of the snapshot to restore into the database\nsnapshotFile will use default saveSnapshot result location if not supplied"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 373,
    "kind": "method",
    "name": "saveSnapshot",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#saveSnapshot",
    "access": "public",
    "description": "Save a snapshot of this live database to disk<br />This will be used to \"seed\" the database to speed up syncs for future runs",
    "lineNumber": 318,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Path to resulting database snapshot"
    },
    "params": []
  },
  {
    "__docId__": 374,
    "kind": "member",
    "name": "databaseDumpPendingPromise",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#databaseDumpPendingPromise",
    "access": "public",
    "description": null,
    "lineNumber": 330,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 376,
    "kind": "method",
    "name": "_initIndexes",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_initIndexes",
    "access": "private",
    "description": "Index initialisation<br />This function wraps taking care of creating our indexes once only",
    "lineNumber": 349,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 379,
    "kind": "method",
    "name": "_createIndexes",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_createIndexes",
    "access": "private",
    "description": "Setup our WDW indexes",
    "lineNumber": 368,
    "params": [],
    "return": null
  },
  {
    "__docId__": 380,
    "kind": "method",
    "name": "getIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getIndex",
    "access": "private",
    "description": "Get the internal index object for the given index type",
    "lineNumber": 382,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Index name (see constants.INDEX_*)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 381,
    "kind": "method",
    "name": "_createIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_createIndex",
    "access": "private",
    "description": "Create an index object to be used by this database",
    "lineNumber": 392,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Index name"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "defaultIndex",
        "description": "Index initial object state"
      }
    ],
    "return": null
  },
  {
    "__docId__": 382,
    "kind": "method",
    "name": "_extractEntityKeys",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_extractEntityKeys",
    "access": "private",
    "description": "Given a WDW document, extract key identifiable data<br />This is used to build a look-up index of unique document types<br />See ancestorIndexes for some of the keys we use<br />This is important so we can tell the difference between entities with the same ID, but different purposes<br />eg. an entity ID can have multiple documents, one for the attraction itself, one for it's wait times, etc.<br />These need to both be in the index under the same entity ID, but with different properties to make them distinct",
    "lineNumber": 409,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "WDW Database Document"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Index object containing important identifying data"
    }
  },
  {
    "__docId__": 383,
    "kind": "method",
    "name": "_extractChannelLanguage",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_extractChannelLanguage",
    "access": "private",
    "description": "Given a WDW database document, try to return its language",
    "lineNumber": 475,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Language of this document. Eg. en_intl, en_us"
    }
  },
  {
    "__docId__": 384,
    "kind": "method",
    "name": "_removeFromArrayIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_removeFromArrayIndex",
    "access": "private",
    "description": "Remove all indexes referencing docID from the given index",
    "lineNumber": 498,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 385,
    "kind": "method",
    "name": "_indexWDWDocument",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_indexWDWDocument",
    "access": "private",
    "description": "Add a document to the database index<br />Used for fast lookups of entities etc. to the correct documents",
    "lineNumber": 518,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "CouchDB document to index"
      }
    ],
    "return": null
  },
  {
    "__docId__": 386,
    "kind": "method",
    "name": "getDocsById",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getDocsById",
    "access": "public",
    "description": "Get an array of documents from an array of _id",
    "lineNumber": 658,
    "params": [
      {
        "nullable": null,
        "types": [
          "array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 387,
    "kind": "method",
    "name": "getEntityIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getEntityIndex",
    "access": "public",
    "description": "Find search index entries by ID<br />If you want the actual document and not just the meta-index data, use getEntity() instead",
    "lineNumber": 677,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": "Returns the index data for this entity ID"
    }
  },
  {
    "__docId__": 388,
    "kind": "method",
    "name": "getDocChildren",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getDocChildren",
    "access": "public",
    "description": "Return an array of children document IDs for a given entity ID",
    "lineNumber": 692,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "method",
    "name": "getDocNameSearch",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getDocNameSearch",
    "access": "public",
    "description": "Very rudementary text search for documents matching the incoming name.<br />name argument will be stripped of all non-alphanumeric characters for searching.<br />Will return an array of document IDs with matching name substrings.",
    "lineNumber": 707,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 390,
    "kind": "method",
    "name": "getEntity",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getEntity",
    "access": "public",
    "description": "Search for an entity in the WDW database",
    "lineNumber": 723,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Entity ID"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": "Filter index by field"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": "Returns all documents for this entity ID"
    }
  },
  {
    "__docId__": 391,
    "kind": "method",
    "name": "getEntityOne",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getEntityOne",
    "access": "public",
    "description": "Search for an entity in the WDW database<br />Attempts to return the \"best candidate\" single document that matches the incoming ID",
    "lineNumber": 740,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Entity ID"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": "Optional index filter"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Returns the best candidate single document, or undefined"
    }
  },
  {
    "__docId__": 392,
    "kind": "method",
    "name": "getFacilityStatus",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getFacilityStatus",
    "access": "public",
    "description": "Get the live facility status for a given entity ID",
    "lineNumber": 770,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Entity ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Facility status document, or undefined"
    }
  },
  {
    "__docId__": 393,
    "kind": "method",
    "name": "getByChannel",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getByChannel",
    "access": "public",
    "description": "Find all documents by channel<br />eg. 'wdw.facilitystatus.1_0' to get all WDW facility status documents",
    "lineNumber": 791,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "channel",
        "description": "Channel ID"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": "Optional document index filter"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": "All documents in this channel (or empty array)"
    }
  },
  {
    "__docId__": 394,
    "kind": "method",
    "name": "find",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#find",
    "access": "public",
    "description": "Return all documents in the database that match the given filter<br />This is a slow operation! Use sparingly!",
    "lineNumber": 813,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 395,
    "kind": "method",
    "name": "subscribeToChanges",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#subscribeToChanges",
    "access": "public",
    "description": "Subscribe to all database changes with an optional mongo-style filter",
    "lineNumber": 828,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 396,
    "kind": "method",
    "name": "subscribeToChannel",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#subscribeToChannel",
    "access": "public",
    "description": "Subscribe to all changes to a channel",
    "lineNumber": 850,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "channel",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 397,
    "kind": "method",
    "name": "_pluginBulkDocs",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB._pluginBulkDocs",
    "access": "private",
    "description": "Plugin function to intercept bulkDocs function<br />We index any WDW documents we find for easier lookup later",
    "lineNumber": 865,
    "params": [
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "bulkDocs in"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 398,
    "kind": "file",
    "name": "lib/reusePromises.js",
    "content": "/**\n * Module that wraps re-using the same Promise multiple times.\n * This allows a function to be called multiple times before returning, but only return once.\n * Useful for latent network requests,\n *  such as requesting a document from multiple sources, but only making one HTTP request.\n */\n\nconst activeFunctions = [];\n\n/**\n * Find the active function with these arguments\n * @param {*} self\n * @param {function} fn\n * @param {string} argsSerialised\n * @return {number}\n * @private\n */\nfunction findActiveFunctionIndex(self, fn, argsSerialised) {\n  return activeFunctions.findIndex((x) => {\n    return x.self === self && x.fn === fn && x.args === argsSerialised;\n  });\n}\n\n/**\n * Reuse a function until it resolves\n * @param {*} self\n * @param {function} fn\n * @param  {...any} args Arguments to pass to the function\n * @return {Promise}\n */\nexport function reusePromise(self, fn, ...args) {\n  return _reusePromise(false, self, fn, ...args);\n}\n\n/**\n * Reuse a function, returning it's result forever\n * @param {*} self\n * @param {function} fn\n * @param  {...any} args Arguments to pass to the function\n * @return {Promise}\n */\nexport function reusePromiseForever(self, fn, ...args) {\n  return _reusePromise(true, self, fn, ...args);\n}\n\n/**\n * Internal call to run a Promise once time (and optionally keep result forever)\n * @param {boolean} useResultForever\n * @param {*} self\n * @param {function} fn\n * @param  {...any} args\n * @return {Promise}\n * @private\n */\nfunction _reusePromise(useResultForever, self, fn, ...args) {\n  // search for existing promise that hasn't resolved yet\n  const argsSerialise = args ? JSON.stringify(args) : null;\n  const existingFunctionIndex = findActiveFunctionIndex(self, fn, argsSerialise);\n  const existingFunction = existingFunctionIndex >= 0 ? activeFunctions[existingFunctionIndex] : undefined;\n  if (existingFunction) {\n    if (existingFunction.resolved) {\n      return existingFunction.value;\n    }\n    return existingFunction.promise;\n  }\n\n  const cleanupPendingFunction = () => {\n    const pendingFunctionIDX = findActiveFunctionIndex(self, fn, argsSerialise);\n    if (pendingFunctionIDX >= 0) {\n      if (!useResultForever) {\n      // clean up pending Promise\n        activeFunctions.splice(pendingFunctionIDX, 1);\n      }\n    }\n  };\n\n  // didn't find a pending existing promise, make a new one!\n  const newPromise = (self !== null && self !== undefined) ? fn.apply(self, args) : fn(...args);\n  newPromise.then((value) => {\n    // clean up our pending Promise\n    if (!useResultForever) {\n      cleanupPendingFunction();\n    } else {\n      const pendingFunctionIDX = findActiveFunctionIndex(self, fn, argsSerialise);\n      if (pendingFunctionIDX >= 0) {\n      // store result so we can re-use it for future calls\n        activeFunctions[pendingFunctionIDX].resolved = true;\n        activeFunctions[pendingFunctionIDX].value = value;\n      }\n    }\n\n    return value;\n  }).catch((err) => {\n    cleanupPendingFunction();\n    throw err;\n  });\n  activeFunctions.push({\n    fn,\n    self,\n    args: argsSerialise,\n    promise: newPromise,\n    resolved: false,\n  });\n  return newPromise;\n}\n\nexport default reusePromise;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/reusePromises.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 399,
    "kind": "variable",
    "name": "activeFunctions",
    "memberof": "lib/reusePromises.js",
    "static": true,
    "longname": "lib/reusePromises.js~activeFunctions",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/reusePromises.js",
    "importStyle": null,
    "description": "Module that wraps re-using the same Promise multiple times.<br />This allows a function to be called multiple times before returning, but only return once.<br />Useful for latent network requests,<br /> such as requesting a document from multiple sources, but only making one HTTP request.",
    "lineNumber": 8,
    "type": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 400,
    "kind": "function",
    "name": "findActiveFunctionIndex",
    "memberof": "lib/reusePromises.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/reusePromises.js~findActiveFunctionIndex",
    "access": "private",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/reusePromises.js",
    "importStyle": null,
    "description": "Find the active function with these arguments",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "self",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "argsSerialised",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 401,
    "kind": "function",
    "name": "reusePromise",
    "memberof": "lib/reusePromises.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/reusePromises.js~reusePromise",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/reusePromises.js",
    "importStyle": "{reusePromise}",
    "description": "Reuse a function until it resolves",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "self",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Arguments to pass to the function"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 402,
    "kind": "function",
    "name": "reusePromiseForever",
    "memberof": "lib/reusePromises.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/reusePromises.js~reusePromiseForever",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/reusePromises.js",
    "importStyle": "{reusePromiseForever}",
    "description": "Reuse a function, returning it's result forever",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "self",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Arguments to pass to the function"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 403,
    "kind": "function",
    "name": "_reusePromise",
    "memberof": "lib/reusePromises.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/reusePromises.js~_reusePromise",
    "access": "private",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/reusePromises.js",
    "importStyle": null,
    "description": "Internal call to run a Promise once time (and optionally keep result forever)",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useResultForever",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "self",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "kind": "index",
    "content": "# Parks API\n\n![Unit Test](https://github.com/ThemeParks/parksapi/workflows/Unit%20Test/badge.svg) ![Documentation Build](https://github.com/ThemeParks/parksapi/workflows/ESDoc/badge.svg)\n\n[API Documentation](https://themeparks.github.io/parksapi/)\n\nThis is a backend module to fetch and query live data for themeparks.\n\nTemplate support is provided in this module. Most parks require some form of credentials, which are not supplied in this repo.\n",
    "longname": "/home/runner/work/parksapi/parksapi/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@themeparks/parksapi\",\n  \"type\": \"module\",\n  \"version\": \"1.2.36\",\n  \"description\": \"\",\n  \"engines\": {\n    \"npm\": \">=6\",\n    \"node\": \">=14\"\n  },\n  \"main\": \"lib/index.js\",\n  \"exports\": {\n    \".\": \"./lib/index.js\",\n    \"./park\": \"./lib/parks/park.js\",\n    \"./parkTypes\": \"./lib/parks/parkTypes.js\",\n    \"./cache/\": \"./lib/cache/\",\n    \"./cache\": \"./lib/cache.js\",\n    \"./tags\": \"./lib/parks/tags.js\"\n  },\n  \"scripts\": {\n    \"test\": \"eslint ./lib/**\",\n    \"docs\": \"esdoc\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/ThemeParks/parksapi.git\"\n  },\n  \"author\": \"@cube\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ThemeParks/parksapi/issues\"\n  },\n  \"homepage\": \"https://github.com/ThemeParks/parksapi#readme\",\n  \"dependencies\": {\n    \"dotenv\": \"^8.2.0\",\n    \"egoroof-blowfish\": \"^2.2.2\",\n    \"fetch-cookie\": \"^0.10.1\",\n    \"json-diff\": \"^0.5.4\",\n    \"mingo\": \"^3.0.6\",\n    \"moment-timezone\": \"^0.5.31\",\n    \"needle\": \"^2.5.0\",\n    \"node-fetch\": \"^2.6.1\",\n    \"pouchdb\": \"^7.2.1\",\n    \"pouchdb-replication-stream\": \"github:pouchdb-community/pouchdb-replication-stream#56f0511\",\n    \"promise-retry\": \"^2.0.1\",\n    \"random-useragent\": \"^0.4.0\",\n    \"sift\": \"^13.1.10\",\n    \"tough-cookie\": \"^4.0.0\",\n    \"uuid\": \"^8.3.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/traverse\": \"^7.11.0\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^7.4.0\",\n    \"eslint-config-google\": \"^0.14.0\"\n  }\n}\n",
    "longname": "/home/runner/work/parksapi/parksapi/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]