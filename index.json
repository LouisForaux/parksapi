[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "lib/cache/cacheBase.js",
    "content": "import fs from 'fs';\n\n/**\n * Our base Cache implementation\n * Extend this class with new implementations to create different cache types (in-memory, database, file system etc.)\n * @class\n */\nexport default class CacheBase {\n  /**\n     * @param {Object} options\n     */\n  constructor(options = {}) {\n    // stack up multiple cache wraps so they wait for a single request to finish\n    this.pendingCacheWraps = {};\n\n    this.failedCacheWraps = {};\n\n    this.pendingLocks = [];\n    this.hasPendingLocks = false;\n  }\n\n  /**\n     * Internal implementation of Get()\n     * @param {string} key Unique key name for this cache entry\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     * @abstract\n     * @private\n     */\n  async _get(key) {\n    throw new Error('Missing Implementation CacheBase::_get(key)');\n  }\n\n  /**\n     * Internal implementation of Set()\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} object Data to be set\n     * @abstract\n     * @private\n     */\n  async _set(key, object) {\n    throw new Error('Missing Implementation CacheBase::_set(key, object)');\n  }\n\n  /**\n     * Internal operation to delete a key\n     * @param {string} key Key name to delete\n     * @abstract\n     * @private\n     */\n  async _del(key) {\n    throw new Error('Missing Implementation CacheBase::_del(key)');\n  }\n\n  /**\n     * Internal implementation of getKeys()\n     * @param {string} prefix\n     * @abstract\n     * @private\n     */\n  async _getKeys(prefix) {\n    throw new Error('Missing Implementation CacheBase::_getKeys(prefix)');\n  }\n\n  /**\n     * Get a cached object\n     * @param {string} key Unique key name for this cache entry\n     * @param {boolean} [getFullObject] Get the full cache entry, including expiry time, even if expired\n     * @param {boolean} [force=false] Force set, bypassing transaction blocks\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     */\n  async get(key, getFullObject = false, force = false) {\n    if (!force) {\n      await this.blockOnPendingTransactions();\n    }\n\n    const now = +new Date();\n\n    // then use our internal cache if we haven't got the value stored locally\n    const cacheValue = await this._get(key);\n    if (cacheValue !== undefined) {\n      if (getFullObject) {\n        return cacheValue;\n      }\n\n      if (cacheValue.expires >= now) {\n        return cacheValue.value;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n     * Set a key in our cache\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} value\n     * @param {(Function|number)} [ttl=3600000] How long the cache entry should last in milliseconds\n     * @param {boolean} [force=false] Force set, bypassing transaction blocks\n     *  Can be a number or a function that will return a number\n     *  Default 1 hour\n     */\n  async set(key, value, ttl = 3600000, force = false) {\n    // resolve our cache time\n    let cacheTime = ttl;\n    // if our cache time input is a function, resolve it and store the result (in milliseconds)\n    if (typeof cacheTime === 'function') {\n      cacheTime = await cacheTime();\n    }\n\n    if (!force) {\n      await this.blockOnPendingTransactions();\n    }\n\n    if (cacheTime < 0) {\n      // delete key if ttl is negative\n      await this._del(key);\n    } else {\n      // call the private _Set implementation to actually set the key\n      await this._set(key, {\n        value,\n        expires: (+new Date()) + cacheTime,\n      });\n    }\n  }\n\n  /**\n     * A helper \"wrap\" function that will return a cached value if present\n     *  This will call the supplied function to fetch it if the value isn't present in the cache\n     * @param {string} key Unique key name for this cache entry\n     * @param {function} fn Fetch function that will be called if the cache entry is not present\n     * @param {(function|number)} [ttl] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     */\n  async wrap(key, fn, ttl) {\n    // if another system is already wrapping this key, return it's pending Promise\n    if (this.pendingCacheWraps[key] !== undefined) {\n      return this.pendingCacheWraps[key];\n    }\n\n    // wrap all await calls in another Promise that we store\n    //  this allows multiple calls to Wrap to stack up, and they all get the same result\n    this.pendingCacheWraps[key] = new Promise(async (resolve) => {\n      // try and fetch the cached value\n      const cachedValue = await this.get(key, true);\n\n      // if not in our cache, call the supplied fetcher function\n      if (cachedValue !== undefined) {\n        // check timestamp to see if value is still valid\n        const now = +new Date();\n        if (cachedValue.expires > now) {\n          // it is! return it!\n          return resolve(cachedValue.value);\n        }\n        // it isn't! fall through and run our wrap function to get new data\n      }\n\n      let error = null;\n      try {\n        const newValue = await fn();\n\n        // set the new value in our cache\n        this.failedCacheWraps[key] = 0;\n        await this.set(key, newValue, ttl);\n        return resolve(newValue);\n      } catch (e) {\n        // store in case we want to throw this later\n        error = e;\n        console.error(`Error caching value ${key}`, e);\n      }\n\n      if (this.failedCacheWraps[key] === undefined) {\n        this.failedCacheWraps[key] = 0;\n      }\n      this.failedCacheWraps[key]++;\n\n      // failed! store old data briefly, then return old data back\n      await this.set(key, cachedValue?.value, 1000 * 30); // try again in 30 seconds\n      if (this.failedCacheWraps[key] > 5) {\n        // report after multiple failures\n        if (error !== null) {\n          // throw the actual error if we had one\n          throw error;\n        }\n        throw new Error(`Failed to resolve wrap function for cache key ${key}`);\n      }\n      return resolve(cachedValue?.value);\n    });\n    const cachedValue = await this.pendingCacheWraps[key];\n    this.pendingCacheWraps[key] = undefined;\n\n    // if debugging, store data to disk\n    if (process.env.DEBUG_WRITE) {\n      if (!fs.existsSync('./debug_cache')) {\n        fs.mkdirSync('./debug_cache');\n      }\n      fs.writeFileSync(`debug_cache/${key.replace(/[^a-zA-Z0-9_-]/g, '')}.json`, JSON.stringify(cachedValue, null, 2));\n    }\n\n    // return the fetched or calculated value\n    return cachedValue;\n  }\n\n  /**\n   * Get an array of all the cached keys matching the supplied prefix\n   * @param {string} [prefix='']\n   * @return {array<string>}\n   */\n  async getKeys(prefix = '') {\n    return this._getKeys(prefix);\n  }\n\n  /**\n   * Run a transaction.\n   * All other queries are halted while this is running\n   * @param {function} func\n   * @param {function} [keyModifierFunc=null] Optional function that translates incoming keys\n   */\n  async runTransaction(func, keyModifierFunc = null) {\n    // function to convert key names (used by scopedCache)\n    const keyNamer = keyModifierFunc ? keyModifierFunc : (key) => key;\n\n    return new Promise(async (resolve) => {\n      this.pendingLocks.push(async () => {\n        // call function with a helper stub with core functions\n        //  use this to make requests inside transaction\n        await func({\n          get: async (key, getFullObject) => {\n            return this.get(keyNamer(key), getFullObject, true);\n          },\n          set: async (key, value, ttl) => {\n            return this.set(keyNamer(key), value, ttl, true);\n          },\n        });\n        resolve();\n      });\n\n      // process all our pending locks\n      if (!this.hasPendingLocks) {\n        this.hasPendingLocks = true;\n        while (this.pendingLocks.length > 0) {\n          const currLock = this.pendingLocks.shift();\n          await currLock();\n        }\n        this.hasPendingLocks = false;\n      }\n    });\n  }\n\n  /**\n   * Block if we have any pending transactions\n   * @return {Promise}\n   */\n  async blockOnPendingTransactions() {\n    if (this.hasPendingLocks) {\n      return new Promise((resolve) => {\n        this.pendingLocks.push(resolve);\n      });\n    }\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheBase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "CacheBase",
    "memberof": "lib/cache/cacheBase.js",
    "static": true,
    "longname": "lib/cache/cacheBase.js~CacheBase",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache/cacheBase.js",
    "importStyle": "CacheBase",
    "description": "Our base Cache implementation<br />Extend this class with new implementations to create different cache types (in-memory, database, file system etc.)",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "pendingCacheWraps",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#pendingCacheWraps",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "failedCacheWraps",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#failedCacheWraps",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "pendingLocks",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#pendingLocks",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "hasPendingLocks",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#hasPendingLocks",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_get",
    "access": "private",
    "description": "Internal implementation of Get()",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    },
    "abstract": true
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_set",
    "access": "private",
    "description": "Internal implementation of Set()",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "object",
        "description": "Data to be set"
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "_del",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_del",
    "access": "private",
    "description": "Internal operation to delete a key",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Key name to delete"
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_getKeys",
    "access": "private",
    "description": "Internal implementation of getKeys()",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "prefix",
        "description": ""
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "get",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#get",
    "access": "public",
    "description": "Get a cached object",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "getFullObject",
        "description": "Get the full cache entry, including expiry time, even if expired"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "force",
        "description": "Force set, bypassing transaction blocks"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "set",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#set",
    "access": "public",
    "description": "Set a key in our cache",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3600000",
        "defaultRaw": 3600000,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "force",
        "description": "Force set, bypassing transaction blocks\n Can be a number or a function that will return a number\n Default 1 hour"
      }
    ],
    "return": null
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "wrap",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#wrap",
    "access": "public",
    "description": "A helper \"wrap\" function that will return a cached value if present<br /> This will call the supplied function to fetch it if the value isn't present in the cache",
    "lineNumber": 134,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "Fetch function that will be called if the cache entry is not present"
      },
      {
        "nullable": null,
        "types": [
          "function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "getKeys",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#getKeys",
    "access": "public",
    "description": "Get an array of all the cached keys matching the supplied prefix",
    "lineNumber": 208,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "prefix",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "runTransaction",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#runTransaction",
    "access": "public",
    "description": "Run a transaction.<br />All other queries are halted while this is running",
    "lineNumber": 218,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "keyModifierFunc",
        "description": "Optional function that translates incoming keys"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "blockOnPendingTransactions",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#blockOnPendingTransactions",
    "access": "public",
    "description": "Block if we have any pending transactions",
    "lineNumber": 253,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 67,
    "kind": "file",
    "name": "lib/cache/cacheLevel.js",
    "content": "import CacheBase from './cacheBase.js';\nimport levelup from 'levelup';\nimport leveldown from 'leveldown';\nimport memdown from 'memdown';\nimport path from 'path';\n\nconst memory = false;\n\n/**\n * A cache implementation using LevelDown\n * @extends CacheBase\n * @class\n */\nexport default class CacheLevel extends CacheBase {\n  /**\n   * Create new Memory cache object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    super(options);\n\n    // setup our Level database\n    if (memory) {\n      this.db = levelup(memdown());\n    } else {\n      this.db = levelup(leveldown(path.join(process.cwd(), 'db.cache')));\n    }\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _get(key) {\n    try {\n      const cacheEntry = await this.db.get(key);\n      if (cacheEntry !== undefined) {\n        return JSON.parse(cacheEntry);\n      }\n    } catch (err) {\n      // ignore NotFoundError, throw any other errors back up the chain\n      if (err.name !== 'NotFoundError') {\n        throw err;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _set(key, object) {\n    await this.db.put(key, JSON.stringify(object));\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _del(key) {\n    await this.db.del(key);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getKeys(prefix) {\n    return new Promise((resolve) => {\n      const keys = [];\n      const keyStream = this.db.createKeyStream();\n      keyStream.on('data', (data) => {\n        if (data.indexOf(prefix) === 0) {\n          keys.push(data.toString());\n        }\n      });\n      keyStream.on('end', () => {\n        return resolve(keys);\n      });\n    });\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheLevel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 68,
    "kind": "variable",
    "name": "memory",
    "memberof": "lib/cache/cacheLevel.js",
    "static": true,
    "longname": "lib/cache/cacheLevel.js~memory",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/cache/cacheLevel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 69,
    "kind": "class",
    "name": "CacheLevel",
    "memberof": "lib/cache/cacheLevel.js",
    "static": true,
    "longname": "lib/cache/cacheLevel.js~CacheLevel",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache/cacheLevel.js",
    "importStyle": "CacheLevel",
    "description": "A cache implementation using LevelDown",
    "lineNumber": 14,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 70,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#constructor",
    "access": "public",
    "description": "Create new Memory cache object",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "db",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#db",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_get",
    "access": "private",
    "description": "",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_set",
    "access": "private",
    "description": "",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "object",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "_del",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_del",
    "access": "private",
    "description": "",
    "lineNumber": 59,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_getKeys",
    "access": "private",
    "description": "",
    "lineNumber": 66,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "file",
    "name": "lib/cache/cacheLmdb.js",
    "content": "import CacheBase from './cacheBase.js';\nimport path from 'path';\n\nimport {open} from 'lmdb';\n\n/**\n * A cache implementation using LMDB\n * @extends CacheBase\n * @class\n */\nexport default class CacheLmdb extends CacheBase {\n  /**\n   * Create new Memory cache object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    super(options);\n\n    // setup our database\n    this.db = open({\n      path: path.join(process.cwd(), 'db.datacache'),\n      compression: true,\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _get(key) {\n    return this.db.get(key);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _set(key, object) {\n    await this.db.put(key, object);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _del(key) {\n    await this.db.remove(key);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getKeys(prefix) {\n    const keys = [];\n    for (const key of this.db.getKeys()) {\n      if (!prefix || key.startsWith(prefix)) {\n        keys.push(key);\n      }\n    }\n    return keys;\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheLmdb.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 78,
    "kind": "class",
    "name": "CacheLmdb",
    "memberof": "lib/cache/cacheLmdb.js",
    "static": true,
    "longname": "lib/cache/cacheLmdb.js~CacheLmdb",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache/cacheLmdb.js",
    "importStyle": "CacheLmdb",
    "description": "A cache implementation using LMDB",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 79,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheLmdb.js~CacheLmdb",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheLmdb.js~CacheLmdb#constructor",
    "access": "public",
    "description": "Create new Memory cache object",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "db",
    "memberof": "lib/cache/cacheLmdb.js~CacheLmdb",
    "static": false,
    "longname": "lib/cache/cacheLmdb.js~CacheLmdb#db",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheLmdb.js~CacheLmdb",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLmdb.js~CacheLmdb#_get",
    "access": "private",
    "description": "",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheLmdb.js~CacheLmdb",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLmdb.js~CacheLmdb#_set",
    "access": "private",
    "description": "",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "object",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "_del",
    "memberof": "lib/cache/cacheLmdb.js~CacheLmdb",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLmdb.js~CacheLmdb#_del",
    "access": "private",
    "description": "",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheLmdb.js~CacheLmdb",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLmdb.js~CacheLmdb#_getKeys",
    "access": "private",
    "description": "",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "file",
    "name": "lib/cache/cacheMemory.js",
    "content": "import CacheBase from './cacheBase.js';\n\n/**\n * A basic in-memory cache implementation\n * @extends CacheBase\n * @class\n */\nexport default class CacheMemory extends CacheBase {\n  /**\n   * Create new Memory cache object\n   * @param {object} options\n   */\n  constructor(options) {\n    super(options);\n\n    this.cache = {};\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _get(key) {\n    const cacheEntry = this.cache[key];\n    if (cacheEntry !== undefined) {\n      return cacheEntry;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _set(key, object) {\n    this.cache[key] = object;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _del(key) {\n    if (this.cache[key]) {\n      delete this.cache[key];\n    }\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getKeys(prefix) {\n    return Object.keys(this.cache).filter((key) => {\n      return key.indexOf(prefix) === 0;\n    });\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheMemory.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 86,
    "kind": "class",
    "name": "CacheMemory",
    "memberof": "lib/cache/cacheMemory.js",
    "static": true,
    "longname": "lib/cache/cacheMemory.js~CacheMemory",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache/cacheMemory.js",
    "importStyle": "CacheMemory",
    "description": "A basic in-memory cache implementation",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 87,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#constructor",
    "access": "public",
    "description": "Create new Memory cache object",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#cache",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_get",
    "access": "private",
    "description": "",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_set",
    "access": "private",
    "description": "",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "object",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "_del",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_del",
    "access": "private",
    "description": "",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_getKeys",
    "access": "private",
    "description": "",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "file",
    "name": "lib/cache/scopedCache.js",
    "content": "import {getCache} from '../cache.js';\nimport {reusePromiseForever} from '../reusePromises.js';\n\n/**\n * A wrapper class for accessing the cache.\n * Prefixes a string before each key to avoid conflicts.\n */\nexport class ScopedCache {\n  /**\n   * Create a new ScopedCache object by passing in the key prefix descired\n   * @param {string} keyPrefix\n   * @param {number} [version] Cache version, bump this to invalidate existing cache entries for a scope\n   * @param {object} [cacheObject=null] Manually supply a cache object to use\n   */\n  constructor(keyPrefix, version = 0, cacheObject = null) {\n    this.prefix = keyPrefix;\n    this.version = version;\n\n    this.cache = null;\n    this.cacheOverride = cacheObject;\n  }\n\n  /**\n   * Initialise the cache for this scope\n   */\n  async initCache() {\n    return await reusePromiseForever(this, this._initCache);\n  }\n\n  /**\n   * Internal cache initialisation\n   */\n  async _initCache() {\n    if (this.cache) {\n      return this.cache;\n    }\n\n    if (!!this.cacheOverride) {\n      this.cache = this.cacheOverride;\n    } else {\n      this.cache = await getCache();\n    }\n\n    // check and flush cache if version mismatch\n    const cacheVersion = await this.cache.get(this.generateScopedKey('%%version%%'));\n    if (cacheVersion !== undefined && cacheVersion != this.version) {\n      // find all cache entries with this scope, and remove them\n      const keys = await this.cache.getKeys(`${this.prefix}_`);\n\n      await Promise.allSettled(keys.map((key) => {\n        // set expire date to 1 millisecond ago (this basically deletes it)\n        return this.cache.set(key, {}, -1);\n      }));\n    }\n\n    // set our new cache version with a very very long ttl\n    await this.cache.set(this.generateScopedKey('%%version%%'), this.version, Number.MAX_SAFE_INTEGER);\n    this._initCachePromise = null;\n\n    return this.cache;\n  }\n\n  /**\n   * Generate a scoped key by adding our prefix to the incoming key\n   * @param {string} inKey\n   * @return {string} Scoped key\n   */\n  generateScopedKey(inKey) {\n    return `${this.prefix}_${inKey}`;\n  }\n\n  /**\n     * Get a cached object\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {boolean} [getFullObject] Get the full cache entry, including expiry time, even if expired\n     * @param {boolean} [force=false] Force set, bypassing transaction blocks\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     */\n  async get(key, getFullObject = false, force = false) {\n    return this.getGlobal(this.generateScopedKey(key), getFullObject, force);\n  }\n\n  /**\n     * Get a cached object from the global cache (skipping the scope prefix)\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {boolean} [getFullObject] Get the full cache entry, including expiry time, even if expired\n     * @param {boolean} [force=false] Force set, bypassing transaction blocks\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     */\n  async getGlobal(key, getFullObject = false, force = false) {\n    const cache = await this.initCache();\n    return cache.get(key, getFullObject, force);\n  }\n\n  /**\n     * Set a key in our cache\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} value\n     * @param {(Function|number)} [ttl=3600000] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     *  Default 1 hour\n     */\n  async set(key, value, ttl = 3600000) {\n    return this.setGlobal(this.generateScopedKey(key), value, ttl);\n  }\n\n  /**\n     * Set a key in our global cache, skipping the scoped prefix\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} value\n     * @param {(Function|number)} [ttl=3600000] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     *  Default 1 hour\n     */\n  async setGlobal(key, value, ttl = 3600000) {\n    const cache = await this.initCache();\n    return cache.set(key, value, ttl);\n  }\n\n  /**\n     * A helper \"wrap\" function that will return a cached value if present\n     *  This will call the supplied function to fetch it if the value isn't present in the cache\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {function} fn Fetch function that will be called if the cache entry is not present\n     * @param {(function|number)} [ttl] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     */\n  async wrap(key, fn, ttl) {\n    return this.wrapGlobal(this.generateScopedKey(key), fn, ttl);\n  }\n\n  /**\n     * A helper \"wrap\" function that will return a cached value if present (in the global scope)\n     *  This will call the supplied function to fetch it if the value isn't present in the cache\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {function} fn Fetch function that will be called if the cache entry is not present\n     * @param {(function|number)} [ttl] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     */\n  async wrapGlobal(key, fn, ttl) {\n    const cache = await this.initCache();\n    return cache.wrap(key, fn, ttl);\n  }\n\n  /**\n   * Run a series of functions in a single transaction\n   * @param {functions} func\n   * @return {promise}\n   */\n  async runTransaction(func) {\n    const cache = await this.initCache();\n    return cache.runTransaction(func, (key) => {\n      return this.generateScopedKey(key);\n    });\n  }\n\n  /**\n   * Block if we have any pending transactions\n   * @return {Promise}\n   */\n  async blockOnPendingTransactions() {\n    const cache = await this.initCache();\n    return cache.blockOnPendingTransactions();\n  }\n\n  /**\n   * Get an array of all the cached keys matching the supplied prefix\n   * @param {string} [prefix='']\n   * @return {array<string>}\n   */\n  async getKeys(prefix = '') {\n    const cache = await this.initCache();\n    return (await cache.getKeys(`${this.prefix}_${prefix}`)).map((x) => {\n      // return keys without our scoped cache prefix\n      return x.slice(this.prefix.length + 1);\n    });\n  }\n}\n\nexport default ScopedCache;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/scopedCache.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 94,
    "kind": "class",
    "name": "ScopedCache",
    "memberof": "lib/cache/scopedCache.js",
    "static": true,
    "longname": "lib/cache/scopedCache.js~ScopedCache",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache/scopedCache.js",
    "importStyle": "{ScopedCache}",
    "description": "A wrapper class for accessing the cache.<br />Prefixes a string before each key to avoid conflicts.",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 95,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#constructor",
    "access": "public",
    "description": "Create a new ScopedCache object by passing in the key prefix descired",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "keyPrefix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "version",
        "description": "Cache version, bump this to invalidate existing cache entries for a scope"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "cacheObject",
        "description": "Manually supply a cache object to use"
      }
    ]
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "prefix",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#prefix",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "version",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#version",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#cache",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "cacheOverride",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#cacheOverride",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "initCache",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#initCache",
    "access": "public",
    "description": "Initialise the cache for this scope",
    "lineNumber": 26,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "_initCache",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#_initCache",
    "access": "private",
    "description": "Internal cache initialisation",
    "lineNumber": 33,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "member",
    "name": "_initCachePromise",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#_initCachePromise",
    "access": "private",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "generateScopedKey",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#generateScopedKey",
    "access": "public",
    "description": "Generate a scoped key by adding our prefix to the incoming key",
    "lineNumber": 68,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inKey",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Scoped key"
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "get",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#get",
    "access": "public",
    "description": "Get a cached object",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "getFullObject",
        "description": "Get the full cache entry, including expiry time, even if expired"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "force",
        "description": "Force set, bypassing transaction blocks"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    }
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "getGlobal",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#getGlobal",
    "access": "public",
    "description": "Get a cached object from the global cache (skipping the scope prefix)",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "getFullObject",
        "description": "Get the full cache entry, including expiry time, even if expired"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "force",
        "description": "Force set, bypassing transaction blocks"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    }
  },
  {
    "__docId__": 108,
    "kind": "method",
    "name": "set",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#set",
    "access": "public",
    "description": "Set a key in our cache",
    "lineNumber": 109,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3600000",
        "defaultRaw": 3600000,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number\n Default 1 hour"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "setGlobal",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#setGlobal",
    "access": "public",
    "description": "Set a key in our global cache, skipping the scoped prefix",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3600000",
        "defaultRaw": 3600000,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number\n Default 1 hour"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "wrap",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#wrap",
    "access": "public",
    "description": "A helper \"wrap\" function that will return a cached value if present<br /> This will call the supplied function to fetch it if the value isn't present in the cache",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "Fetch function that will be called if the cache entry is not present"
      },
      {
        "nullable": null,
        "types": [
          "function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "wrapGlobal",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#wrapGlobal",
    "access": "public",
    "description": "A helper \"wrap\" function that will return a cached value if present (in the global scope)<br /> This will call the supplied function to fetch it if the value isn't present in the cache",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "Fetch function that will be called if the cache entry is not present"
      },
      {
        "nullable": null,
        "types": [
          "function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "runTransaction",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#runTransaction",
    "access": "public",
    "description": "Run a series of functions in a single transaction",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "functions"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "blockOnPendingTransactions",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#blockOnPendingTransactions",
    "access": "public",
    "description": "Block if we have any pending transactions",
    "lineNumber": 173,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "getKeys",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#getKeys",
    "access": "public",
    "description": "Get an array of all the cached keys matching the supplied prefix",
    "lineNumber": 183,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "prefix",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 115,
    "kind": "file",
    "name": "lib/cache.js",
    "content": "/**\n * Cache provider\n */\n\n// import CacheLevel from './cache/cacheLevel.js';\nimport CacheLmdb from './cache/cacheLmdb.js';\n\n// our global cache instance\nlet CacheInstance = null;\n// const cacheLevel = new CacheLevel();\nconst cacheLmdb = new CacheLmdb();\n\n/**\n * Create a new Cache Instance.\n * This function should only be called once for the lifetime of the module.\n */\nasync function createCacheInstance() {\n  // TODO - accept configured caches through environment variables (or other?)\n  return cacheLmdb;\n}\n\n/**\n  * Get the configured Cache implementation\n  */\nexport async function getCache() {\n  if (CacheInstance === null) {\n    CacheInstance = await createCacheInstance();\n  }\n\n  return CacheInstance;\n}\n\nexport default {\n  getCache,\n};\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 116,
    "kind": "variable",
    "name": "CacheInstance",
    "memberof": "lib/cache.js",
    "static": true,
    "longname": "lib/cache.js~CacheInstance",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/cache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 117,
    "kind": "variable",
    "name": "cacheLmdb",
    "memberof": "lib/cache.js",
    "static": true,
    "longname": "lib/cache.js~cacheLmdb",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/cache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "lib/cache/cacheLmdb.js~CacheLmdb"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 118,
    "kind": "function",
    "name": "createCacheInstance",
    "memberof": "lib/cache.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/cache.js~createCacheInstance",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/cache.js",
    "importStyle": null,
    "description": "Create a new Cache Instance.<br />This function should only be called once for the lifetime of the module.",
    "lineNumber": 17,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 119,
    "kind": "function",
    "name": "getCache",
    "memberof": "lib/cache.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/cache.js~getCache",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/cache.js",
    "importStyle": "{getCache}",
    "description": "Get the configured Cache implementation",
    "lineNumber": 25,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "file",
    "name": "lib/configBase.js",
    "content": "// load any environment variables from .env (if it exists)\nimport DotEnv from 'dotenv';\nDotEnv.config();\n\nimport EventEmitter from 'events';\n\n/**\n * Combine given options with environment variables\n * @param {object} options Incoming options\n * @return {object} Processed configuration options\n */\nexport function parseConfig(options = {}) {\n  const configKeys = Object.keys(options);\n\n  const config = {};\n\n  options.configPrefixes = ['THEMEPARKS'].concat(\n      options.configPrefixes || [],\n  );\n\n  // build this.config object with our settings\n  configKeys.forEach((key) => {\n    // default prefixes are either \"classname_\" or \"THEMEPARKS_\"\n    //  classes can add more with configPrefixes\n    options.configPrefixes.forEach((prefix) => {\n      const configEnvName = `${prefix}_${key}`.toUpperCase();\n\n      if (process.env[configEnvName]) {\n        // console.log(`Using env variable ${configEnvName}`);\n        config[key] = process.env[configEnvName];\n        // console.log(` ${key}(env.${configEnvName})=${config[key]}`);\n      }\n    });\n\n    if (config[key] === undefined) {\n      config[key] = options[key];\n    } else {\n      // convert env variable to number if the base default is a number\n      if (typeof config[key] === 'number') {\n        config[key] = Number(config[key]);\n      } else if (typeof config[key] === 'boolean') {\n        // convert any boolean configs too\n        config[key] = (config[key] === 'true');\n      }\n    }\n  });\n\n  return config;\n}\n\n/**\n * Base Config Object\n * Supports classes with a single argument \"options\"\n * These will be sorted into a member called \"this.config\" containing all the same keys\n *\n * Crucially, these can also be overriden through environment variables\n * For example, for a config option \"timeout\" for class Database, this could be overriden through either:\n *   env.THEMEPARKS_TIMEOUT (using a \"global module name\")\n *   env.DATABASE_TIMEOUT (using the class name)\n *\n * Classes can also add additional prefixes to the supported environment variables through:\n *   new ClassInstance({configPrefixes: ['myCustomPrefix']});\n * Which would also allow env.MYCUSTOMPREFIX_TIMEOUT to be used\n *\n * Note that a default value must be supplied for the environment variable to be processed\n * If the default value is a number, the environment variable will be cast to a number as well\n * @class\n */\nexport class ConfigBase extends EventEmitter {\n  /**\n   * A base class that can be configured through environment variables\n   * @param {object} options Config for instantiating this object\n   */\n  constructor(options = {}) {\n    super();\n\n    options.configPrefixes = [this.constructor.name].concat(\n        options.configPrefixes || [],\n    );\n\n    this.config = parseConfig(options || {});\n  }\n}\n\nexport default ConfigBase;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/configBase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 121,
    "kind": "function",
    "name": "parseConfig",
    "memberof": "lib/configBase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/configBase.js~parseConfig",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/configBase.js",
    "importStyle": "{parseConfig}",
    "description": "Combine given options with environment variables",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Incoming options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Processed configuration options"
    }
  },
  {
    "__docId__": 122,
    "kind": "class",
    "name": "ConfigBase",
    "memberof": "lib/configBase.js",
    "static": true,
    "longname": "lib/configBase.js~ConfigBase",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/configBase.js",
    "importStyle": "{ConfigBase}",
    "description": "Base Config Object<br />Supports classes with a single argument \"options\"<br />These will be sorted into a member called \"this.config\" containing all the same keys<br /><br />Crucially, these can also be overriden through environment variables<br />For example, for a config option \"timeout\" for class Database, this could be overriden through either:<br />  env.THEMEPARKS_TIMEOUT (using a \"global module name\")<br />  env.DATABASE_TIMEOUT (using the class name)<br /><br />Classes can also add additional prefixes to the supported environment variables through:<br />  new ClassInstance({configPrefixes: ['myCustomPrefix']});<br />Which would also allow env.MYCUSTOMPREFIX_TIMEOUT to be used<br /><br />Note that a default value must be supplied for the environment variable to be processed<br />If the default value is a number, the environment variable will be cast to a number as well",
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 123,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/configBase.js~ConfigBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/configBase.js~ConfigBase#constructor",
    "access": "public",
    "description": "A base class that can be configured through environment variables",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Config for instantiating this object"
      }
    ]
  },
  {
    "__docId__": 124,
    "kind": "member",
    "name": "config",
    "memberof": "lib/configBase.js~ConfigBase",
    "static": false,
    "longname": "lib/configBase.js~ConfigBase#config",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "file",
    "name": "lib/index.js",
    "content": "import Efteling from './parks/efteling/efteling.js';\nimport {\n  WaltDisneyWorldResort,\n  DisneylandResort,\n  HongKongDisneyland,\n} from './parks/wdw/waltdisneyworldbase.js';\nimport {\n  DisneylandParis,\n} from './parks/dlp/disneylandparis.js';\nimport {\n  ShanghaiDisneylandResort,\n} from './parks/shdr/shanghaidisneyresort.js';\nimport {\n  TokyoDisneyResort,\n} from './parks/tdr/tokyodisneyresort.js';\nimport {\n  // destinations\n  UniversalStudios,\n  UniversalOrlando,\n} from './parks/universal/universal.js';\nimport {\n  // destinations\n  EuropaPark,\n} from './parks/europa/europapark.js';\nimport {\n  ParcAsterix\n} from './parks/parcasterix/parcasterix.js';\nimport {\n  Phantasialand,\n} from './parks/phantasialand/phantasialand.js';\nimport {\n  SeaworldOrlando,\n  SeaworldSanAntonio,\n  SeaworldSanDiego,\n  BuschGardensTampa,\n  BuschGardensWilliamsburg,\n} from './parks/seaworld/seaworld.js';\nimport {\n  AltonTowers,\n  ThorpePark,\n  ChessingtonWorldOfAdventures,\n  LegolandWindsor,\n  LegolandOrlando,\n  Gardaland,\n  HeidePark,\n} from './parks/attractionsio/attractionsio.js';\nimport {\n  PortAventuraWorld,\n} from './parks/portaventura/portaventura.js';\nimport {\n  Toverland,\n} from './parks/toverland/toverland.js';\nimport {\n  Dollywood,\n  SilverDollarCity,\n} from './parks/herschend/herschendparks.js';\nimport {\n  Plopsaland,\n  HolidayPark,\n} from './parks/plopsaland/plopsa.js';\nimport {\n  Bellewaerde,\n  WalibiHolland,\n} from './parks/bellewaerde/bellewaerde.js';\nimport {\n  Liseberg,\n} from './parks/liseberg/liseberg.js';\nimport {\n  CedarPoint,\n  KnottsBerryFarm,\n  CaliforniasGreatAmerica,\n  CanadasWonderland,\n  Carowinds,\n  KingsIsland,\n  DorneyPark,\n  KingsDominion,\n  MichigansAdventure,\n  ValleyFair,\n  WorldsOfFun,\n} from './parks/te2/te2.js';\nimport {\n  Hersheypark,\n} from './parks/hershey/hersheypark.js';\n\nexport default {\n  destinations: {\n    WaltDisneyWorldResort,\n    DisneylandResort,\n    DisneylandParis,\n    TokyoDisneyResort,\n    HongKongDisneyland,\n    ShanghaiDisneylandResort,\n    UniversalStudios,\n    UniversalOrlando,\n    EuropaPark,\n    Efteling,\n    Phantasialand,\n    SeaworldOrlando,\n    SeaworldSanAntonio,\n    SeaworldSanDiego,\n    BuschGardensTampa,\n    BuschGardensWilliamsburg,\n    AltonTowers,\n    ThorpePark,\n    ChessingtonWorldOfAdventures,\n    LegolandWindsor,\n    LegolandOrlando,\n    Gardaland,\n    PortAventuraWorld,\n    ParcAsterix,\n    Toverland,\n    Dollywood,\n    SilverDollarCity,\n    Plopsaland,\n    HolidayPark,\n    Bellewaerde,\n    WalibiHolland,\n    HeidePark,\n    Liseberg,\n    CedarPoint,\n    KnottsBerryFarm,\n    CaliforniasGreatAmerica,\n    CanadasWonderland,\n    Carowinds,\n    KingsIsland,\n    DorneyPark,\n    KingsDominion,\n    MichigansAdventure,\n    ValleyFair,\n    WorldsOfFun,\n    Hersheypark,\n  },\n};\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 126,
    "kind": "file",
    "name": "lib/parks/attractionsio/attractionsio.js",
    "content": "import {Destination} from '../destination.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\n\nimport {v4 as uuidv4} from 'uuid';\nimport moment from 'moment';\nimport unzip from 'yauzl';\nimport {promisify} from 'util';\n\nconst unzipFromBuffer = promisify(unzip.fromBuffer);\n\nconst langs = ['en-GB', 'en-US', 'en-AU', 'en-CA', 'es-419', 'de-DE', 'it'];\n/**\n * Helper to extract name from a variable\n * @param {String|Object} name \n * @returns \n */\nfunction extractName(name) {\n  if (typeof name === 'object') {\n    // if we have translations, pick in priority order...\n    const langIdx = langs.findIndex((lang) => !!name[lang]);\n    if (langIdx > -1) {\n      return name[langs[langIdx]];\n    } else {\n      // otherwise just pick the first one\n      return Object.values(name)[0];\n    }\n  }\n\n  return name;\n}\n\nexport class AttractionsIO extends Destination {\n  constructor(options = {}) {\n    options.destinationId = options.destinationId || '';\n    options.parkId = options.parkId || '';\n    options.baseURL = options.baseURL || '';\n    options.timezone = options.timezone || 'Europe/London';\n    options.appBuild = options.appBuild || undefined;\n    options.appVersion = options.appVersion || '';\n    options.deviceIdentifier = options.deviceIdentifier || '123';\n    options.apiKey = options.apiKey || '';\n    options.initialDataVersion = options.initialDataVersion || undefined;\n    options.calendarURL = options.calendarURL || '';\n\n    // allow env config for all attractionsio destinations\n    options.configPrefixes = ['ATTRACTIONSIO'];\n\n    // invalidate cache\n    options.cacheVersion = options.cacheVersion || '3';\n\n    super(options);\n\n    if (!this.config.destinationId) throw new Error('destinationId is required');\n    if (!this.config.parkId) throw new Error('parkId is required');\n    if (!this.config.baseURL) throw new Error('Missing attractions.io base URL');\n    if (!this.config.appBuild) throw new Error('Missing appBuild');\n    if (!this.config.appVersion) throw new Error('Missing appVersion');\n    if (!this.config.deviceIdentifier) throw new Error('Missing deviceIdentifier');\n    if (!this.config.apiKey) throw new Error('Missing apiKey');\n    if (!this.config.calendarURL) throw new Error('Missing calendarURL');\n\n    // API hooks for auto-login\n    const baseURLHostname = new URL(this.config.baseURL).hostname;\n\n    // login when accessing API domain\n    this.http.injectForDomain({\n      hostname: baseURLHostname,\n    }, async (method, url, data, options) => {\n\n      // always include the current date\n      options.headers.date = moment().format();\n\n      if (options.skipDeviceId) {\n        // special case for initial device setup\n        options.headers['authorization'] = `Attractions-Io api-key=\"${this.config.apiKey}\"`;\n        return;\n      }\n\n      const deviceId = await this.getDeviceId();\n      options.headers['authorization'] = `Attractions-Io api-key=\"${this.config.apiKey}\", installation-token=\"${deviceId}\"`;\n    });\n  }\n\n  /**\n   * Create a device ID to login to the API\n   */\n  async getDeviceId() {\n    '@cache|481801'; // cache 11 months\n    const deviceId = uuidv4();\n\n    const resp = await this.http('POST', `${this.config.baseURL}installation`, {\n      user_identifier: deviceId,\n      app_build: this.config.appBuild,\n      app_version: this.config.appVersion,\n      device_identifier: this.config.deviceIdentifier,\n    }, {\n      skipDeviceId: true,\n    });\n\n    return resp.body.token;\n  }\n\n  /**\n   * Get POI data for this destination\n   */\n  async getPOIData(depth = 0) {\n    '@cache|720'; // cache for 12 hours\n\n    // get current data asset version\n    const currentParkDataVersion = (await this.cache.get('currentParkDataVersion')) || this.config.initialDataVersion;\n\n    const dataQueryOptions = {};\n    if (currentParkDataVersion) {\n      dataQueryOptions.version = currentParkDataVersion;\n    }\n\n    // query current data version\n    const dataVersionQuery = await this.http('GET', `${this.config.baseURL}data`, Object.keys(dataQueryOptions).length > 0 ? dataQueryOptions : undefined);\n\n    if (dataVersionQuery.statusCode === 202) {\n      // data is being generated, wait for it to finish and try again...\n\n      // give up after 5 tries...\n      if (depth < 5) {\n        // wait 10 seconds\n        this.log('Status Code 202 receieved. Data is still being generated, waiting 10 seconds and trying again...');\n        await new Promise((resolve) => setTimeout(resolve, 10 * 1000));\n        // try again\n        return this.getPOIData(depth++);\n      }\n    }\n\n    if (dataVersionQuery.statusCode === 303) {\n      // redirect to new data asset\n      const newDataAssets = dataVersionQuery.headers.location;\n\n      // download the new data asset and extract records.json\n      const assetData = await this.downloadAssetPack(newDataAssets);\n\n      // save assetData in long-term cache\n      await this.cache.set('assetData', assetData, 1000 * 60 * 60 * 24 * 365 * 2); // cache for 2 years\n      // save the current data asset version\n      await this.cache.set('currentParkDataVersion', assetData.manifestData.version, 1000 * 60 * 60 * 24 * 365 * 2); // cache for 2 years\n\n      return assetData.recordsData;\n    }\n\n    // in all other scenarios, return our previously cached data\n    const assetData = await this.cache.get('assetData');\n    if (!assetData?.recordsData) {\n      this.emit('error', new Error(`No asset data found, return code ${dataVersionQuery.statusCode}`));\n    }\n    return assetData.recordsData;\n  }\n\n  /**\n   * Download asset zip file. Extract manifest and records data.\n   * @param {String} url \n   * @returns \n   */\n  async downloadAssetPack(url) {\n    const resp = await this.http('GET', url);\n\n    // read a single JSON file from a zip object\n    const readZipFile = async (zip, file) => {\n      const openReadStream = promisify(zip.openReadStream.bind(zip));\n      const readStream = await openReadStream(file);\n\n      let data = '';\n      readStream.on('data', (chunk) => {\n        data += chunk;\n      });\n\n      return new Promise((resolve, reject) => {\n        readStream.on('end', () => {\n          try {\n            data = JSON.parse(data);\n            return resolve(data);\n          } catch (e) {\n            return reject(new Error(`JSON parse error extracting ${file.fileName}: ${e}`));\n          }\n        });\n      });\n    }\n\n    // unzip data\n    const zip = await unzipFromBuffer(resp.body, {\n      lazyEntries: true,\n    });\n    let manifestData;\n    let recordsData;\n\n    const filenames = [\n      'manifest.json',\n      'records.json',\n    ];\n\n    zip.on('entry', async (file) => {\n      if (filenames.indexOf(file.fileName) > -1) {\n        // read the file\n        const data = await readZipFile(zip, file);\n\n        // store the data\n        if (file.fileName === 'manifest.json') {\n          manifestData = data;\n        } else if (file.fileName === 'records.json') {\n          recordsData = data;\n        }\n      }\n\n      zip.readEntry();\n    });\n\n    return new Promise((resolve, reject) => {\n      zip.on('end', () => {\n        if (!manifestData) {\n          return reject(new Error('No manifest.json found in zip file'));\n        }\n        if (!recordsData) {\n          return reject(new Error('No records.json found in zip file'));\n        }\n\n        return resolve({\n          manifestData,\n          recordsData,\n        });\n      });\n\n      // start reading file...\n      zip.readEntry();\n    });\n  }\n\n  /**\n   * Given a category string, return all category IDs\n   * eg. \"Attractions\" will return the \"Attractions\" category and all child categories, such as \"Thrills\" etc.\n   */\n  async getCategoryIDs(categoryName) {\n    '@cache|120';\n\n    const destinationData = await this.getPOIData();\n\n    // find parent category\n    const cats = [];\n    const attractionCats = destinationData.Category.filter((x) => {\n      return extractName(x.Name) === categoryName;\n    });\n    if (!attractionCats || attractionCats.length === 0) return [];\n\n    // return main category\n    // cats.push(attractionCat._id);\n    cats.push(...attractionCats.map((x) => x._id));\n\n    // concat child cateories too\n    attractionCats.forEach((parentCat) => {\n      cats.push(...destinationData.Category.filter((x) => {\n        return x.Parent == parentCat._id;\n      }).map((x) => x._id));\n    });\n\n    return cats;\n  }\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data \n   * @returns {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    entity._id = `${data?._id || undefined}`;\n    entity.name = extractName(data?.Name || undefined);\n\n    if (data?.DirectionsLocation) {\n      try {\n        const loc = data.DirectionsLocation.split(',').map(Number);\n        entity.location = {\n          latitude: loc[0],\n          longitude: loc[1],\n        };\n      } catch (e) {\n        // ignore\n      }\n    }\n    if (data?.Location) {\n      try {\n        const loc = data.Location.split(',').map(Number);\n        entity.location = {\n          latitude: loc[0],\n          longitude: loc[1],\n        };\n      } catch (e) {\n        // ignore\n      }\n    }\n\n    entity._tags = [];\n    // minimum height\n    if (data?.MinimumHeightRequirement !== undefined) {\n      entity._tags.push({\n        id: 'minimumHeight',\n        value: Math.floor(data.MinimumHeightRequirement * 100),\n      });\n    }\n    // minimum height unaccompanied\n    if (data?.MinimumUnaccompaniedHeightRequirement !== null && data?.MinimumUnaccompaniedHeightRequirement !== undefined) {\n      entity._tags.push({\n        id: 'minimumHeightUnaccompanied',\n        value: Math.floor(data.MinimumUnaccompaniedHeightRequirement * 100),\n      });\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    const destinationData = await this.getPOIData();\n\n    // TODO - hardcode or find a better way to find our destination data\n    // Note: What about merlin resorts with multiple parks? i.e, Legoland Orlando - any others?\n    if (!destinationData?.Resort) {\n      throw new Error('No resort data found');\n    }\n    if (destinationData.Resort.length > 1) {\n      throw new Error('Multiple resorts found in destination data');\n    }\n\n    const resortData = destinationData.Resort[0];\n    if (!resortData) throw new Error('No resort data found');\n\n    return {\n      ...this.buildBaseEntityObject(resortData),\n      _id: this.config.destinationId,\n      slug: this.config.destinationId,\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    const destinationData = await this.getPOIData();\n\n    if (!destinationData?.Resort?.length) {\n      throw new Error('No resort data found');\n    }\n\n    const park = destinationData.Resort[0];\n    const parkObj = {\n      ...this.buildBaseEntityObject(park),\n      _parentId: this.config.destinationId,\n      _destinationId: this.config.destinationId,\n      entityType: entityType.park,\n      _id: this.config.parkId,\n    };\n    parkObj.name = parkObj.name.replace(/\\s*Resort/, '');\n    parkObj.slug = parkObj.name.toLowerCase().replace(/[^\\w]/g, '');\n    return [parkObj];\n  }\n\n  /**\n   * Helper function to generate entities from a list of category names\n   * @param {Array<String>} categoryNames\n   * @returns \n   */\n  async _buildEntitiesFromCategories(categoryNames, parentId, attributes = {}) {\n    const categoryIDs = [];\n    for (let i = 0; i < categoryNames.length; i++) {\n      const categories = await this.getCategoryIDs(categoryNames[i]);\n      categoryIDs.push(...categories);\n    }\n\n    const categoryData = await this.getPOIData();\n\n    const ents = categoryData.Item.filter((x) => categoryIDs.indexOf(x.Category) >= 0);\n\n    return ents.map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        _parentId: parentId,\n        _parkId: parentId,\n        _destinationId: this.config.destinationId,\n        ...attributes,\n      };\n    });\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    return this._buildEntitiesFromCategories(['Attractions', 'Rides', 'Water Rides', 'Thrill Rides', 'Coasters', 'Intense Thrills', 'Rides & Shows'], this.config.parkId, {\n      entityType: entityType.attraction,\n      attractionType: attractionType.ride,\n    });\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    return this._buildEntitiesFromCategories(['Shows', 'Show', 'Live Shows'], this.config.parkId, {\n      entityType: entityType.show,\n    });\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    return this._buildEntitiesFromCategories(['Restaurants', 'Fast Food', 'Snacks', 'Healthy Food', 'Food', 'Dining', 'Food & Drink'], this.config.parkId, {\n      entityType: entityType.restaurant,\n    });\n  }\n\n  async _fetchLiveData() {\n    '@cache|1'; // cache for 1 minute\n    const resp = await this.http('GET', `https://live-data.attractions.io/${this.config.apiKey}.json`);\n\n    return resp.body.entities;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const liveData = await this._fetchLiveData();\n\n    // only return attractions\n    const attrs = await this.getAttractionEntities();\n    const attrIds = attrs.map((x) => `${x._id}`);\n\n    const validEnts = liveData.Item.records.filter((x) => {\n      return attrIds.indexOf(`${x._id}`) >= 0;\n    });\n\n    return validEnts.map((x) => {\n      const data = {\n        _id: `${x._id}`,\n        status: (!!x.IsOperational) ? statusType.operating : statusType.closed,\n      };\n\n      if (x.QueueTime !== undefined && x.QueueTime !== null && !isNaN(x.QueueTime)) {\n        data.queue = {\n          [queueType.standBy]: {\n            waitTime: Math.floor(x.QueueTime / 60),\n          },\n        };\n      }\n\n      return data;\n    });\n  }\n\n  async _fetchCalendar() {\n    '@cache|120'; // cache for 2 hours\n\n    const scheduleData = await this.http('GET', this.config.calendarURL);\n    return scheduleData.body;\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    const scheduleData = await this._fetchCalendar();\n\n    // assume 1 park per destination\n    const days = scheduleData.Locations[0].days;\n\n    // various random formats the calendar API can return in\n    const hourFormats = [\n      {\n        // eg. 10am - 5pm\n        regex: /(\\d{1,2})([a|p]m)\\s*\\-\\s*(\\d{1,2})([a|p]m)/,\n        process: (match, date) => {\n          return {\n            openingTime: date.clone().hour(Number(match[1]) + (match[2] === 'pm' ? 12 : 0)).minute(0).second(0).millisecond(0),\n            closingTime: date.clone().hour(Number(match[3]) + (match[4] === 'pm' ? 12 : 0)).minute(0).second(0).millisecond(0),\n          };\n        },\n      },\n      {\n        // eg. 10:00 - 17:00\n        regex: /(\\d{1,2}):(\\d{1,2})\\s*\\-\\s*(\\d{1,2}):(\\d{1,2})/,\n        process: (match, date) => {\n          return {\n            openingTime: date.clone().hour(Number(match[1])).minute(Number(match[2])).second(0).millisecond(0),\n            closingTime: date.clone().hour(Number(match[3])).minute(Number(match[4])).second(0).millisecond(0),\n          };\n        },\n      },\n    ];\n\n    const schedule = days.map((x) => {\n      const date = moment(x.key, 'YYYYMMDD').tz(this.config.timezone, true);\n\n      for (let i = 0; i < hourFormats.length; i++) {\n        const format = hourFormats[i];\n        const match = format.regex.exec(x.openingHours);\n        if (!match) continue;\n\n        const times = format.process(match, date);\n\n        return {\n          \"date\": date.format('YYYY-MM-DD'),\n          \"type\": \"OPERATING\",\n          \"openingTime\": times.openingTime.format(),\n          \"closingTime\": times.closingTime.format(),\n        };\n      }\n\n      return null;\n    }).filter((x) => !!x);\n\n    return [\n      {\n        _id: this.config.parkId,\n        schedule,\n      }\n    ];\n  }\n}\n\nexport class AltonTowers extends AttractionsIO {\n  constructor(config = {}) {\n    config.destinationId = config.destinationId || 'altontowersresort';\n    config.parkId = config.parkId || 'altontowers';\n    config.initialDataVersion = config.initialDataVersion || '2021-07-06T07:48:43Z';\n\n    config.appBuild = config.appBuild || 293;\n    config.appVersion = config.appVersion || '5.3';\n\n    super(config);\n  }\n}\n\nexport class ThorpePark extends AttractionsIO {\n  constructor(config = {}) {\n    config.destinationId = config.destinationId || 'thorpeparkresort';\n    config.parkId = config.parkId || 'thorpepark';\n    config.initialDataVersion = config.initialDataVersion || '2021-04-15T15:28:08Z';\n\n    config.appBuild = config.appBuild || 299;\n    config.appVersion = config.appVersion || '1.4';\n\n    super(config);\n  }\n}\n\nexport class ChessingtonWorldOfAdventures extends AttractionsIO {\n  constructor(config = {}) {\n    config.destinationId = config.destinationId || 'chessingtonworldofadventuresresort';\n    config.parkId = config.parkId || 'chessingtonworldofadventures';\n    config.initialDataVersion = config.initialDataVersion || '2021-08-19T09:59:06Z';\n\n    config.appBuild = config.appBuild || 178;\n    config.appVersion = config.appVersion || '3.3';\n\n    super(config);\n  }\n}\n\nexport class LegolandWindsor extends AttractionsIO {\n  constructor(config = {}) {\n    config.destinationId = config.destinationId || 'legolandwindsorresort';\n    config.parkId = config.parkId || 'legolandwindsor';\n    config.initialDataVersion = config.initialDataVersion || '2021-08-20T08:22:20Z';\n\n    config.appBuild = config.appBuild || 113;\n    config.appVersion = config.appVersion || '2.4';\n\n    super(config);\n  }\n}\n\nexport class LegolandOrlando extends AttractionsIO {\n  constructor(config = {}) {\n    config.timezone = config.timezone || 'America/New_York';\n    config.destinationId = config.destinationId || 'legolandorlandoresort';\n    config.parkId = config.parkId || 'legolandorlando';\n    config.initialDataVersion = config.initialDataVersion || '2021-08-09T15:48:56Z';\n\n    config.appBuild = config.appBuild || 115;\n    config.appVersion = config.appVersion || '1.6.1';\n\n    super(config);\n  }\n}\n\nexport class Gardaland extends AttractionsIO {\n  constructor(config = {}) {\n    config.timezone = config.timezone || 'Europe/Rome';\n    config.destinationId = config.destinationId || 'gardalandresort';\n    config.parkId = config.parkId || 'gardaland';\n    config.initialDataVersion = config.initialDataVersion || '2020-10-27T08:40:37Z';\n\n    config.appBuild = config.appBuild || 119;\n    config.appVersion = config.appVersion || '4.2';\n\n    super(config);\n  }\n}\n\nexport class HeidePark extends AttractionsIO {\n  constructor(config = {}) {\n    config.timezone = config.timezone || 'Europe/Berlin';\n    config.destinationId = config.destinationId || 'heideparkresort';\n    config.parkId = config.parkId || 'heidepark';\n    config.initialDataVersion = config.initialDataVersion || '2022-05-10T09:00:46Z';\n\n    config.appBuild = config.appBuild || 302018;\n    config.appVersion = config.appVersion || '4.0.5';\n\n    super(config);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/attractionsio/attractionsio.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 127,
    "kind": "variable",
    "name": "unzipFromBuffer",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~unzipFromBuffer",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 128,
    "kind": "variable",
    "name": "langs",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~langs",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 129,
    "kind": "function",
    "name": "extractName",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~extractName",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": null,
    "description": "Helper to extract name from a variable",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 130,
    "kind": "class",
    "name": "AttractionsIO",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": "{AttractionsIO}",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 131,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "getDeviceId",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#getDeviceId",
    "access": "public",
    "description": "Create a device ID to login to the API",
    "lineNumber": 87,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "getPOIData",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#getPOIData",
    "access": "public",
    "description": "Get POI data for this destination",
    "lineNumber": 106,
    "params": [
      {
        "name": "depth",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "downloadAssetPack",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#downloadAssetPack",
    "access": "public",
    "description": "Download asset zip file. Extract manifest and records data.",
    "lineNumber": 161,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "getCategoryIDs",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#getCategoryIDs",
    "access": "public",
    "description": "Given a category string, return all category IDs<br />eg. \"Attractions\" will return the \"Attractions\" category and all child categories, such as \"Thrills\" etc.",
    "lineNumber": 238,
    "params": [
      {
        "name": "categoryName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 270,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 321,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": *, \"slug\": *, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 347,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "_buildEntitiesFromCategories",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#_buildEntitiesFromCategories",
    "access": "private",
    "description": "Helper function to generate entities from a list of category names",
    "lineNumber": 372,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<String>"
        ],
        "spread": false,
        "optional": false,
        "name": "categoryNames",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 397,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 407,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 416,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "_fetchLiveData",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#_fetchLiveData",
    "access": "private",
    "description": null,
    "lineNumber": 422,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 432,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "_fetchCalendar",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#_fetchCalendar",
    "access": "private",
    "description": null,
    "lineNumber": 461,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AttractionsIO",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AttractionsIO#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 473,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 147,
    "kind": "class",
    "name": "AltonTowers",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~AltonTowers",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": "{AltonTowers}",
    "description": null,
    "lineNumber": 533,
    "undocument": true,
    "interface": false,
    "extends": [
      "AttractionsIO"
    ]
  },
  {
    "__docId__": 148,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/attractionsio/attractionsio.js~AltonTowers",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~AltonTowers#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 534,
    "undocument": true
  },
  {
    "__docId__": 149,
    "kind": "class",
    "name": "ThorpePark",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~ThorpePark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": "{ThorpePark}",
    "description": null,
    "lineNumber": 546,
    "undocument": true,
    "interface": false,
    "extends": [
      "AttractionsIO"
    ]
  },
  {
    "__docId__": 150,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/attractionsio/attractionsio.js~ThorpePark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~ThorpePark#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 547,
    "undocument": true
  },
  {
    "__docId__": 151,
    "kind": "class",
    "name": "ChessingtonWorldOfAdventures",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~ChessingtonWorldOfAdventures",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": "{ChessingtonWorldOfAdventures}",
    "description": null,
    "lineNumber": 559,
    "undocument": true,
    "interface": false,
    "extends": [
      "AttractionsIO"
    ]
  },
  {
    "__docId__": 152,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/attractionsio/attractionsio.js~ChessingtonWorldOfAdventures",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~ChessingtonWorldOfAdventures#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 560,
    "undocument": true
  },
  {
    "__docId__": 153,
    "kind": "class",
    "name": "LegolandWindsor",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~LegolandWindsor",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": "{LegolandWindsor}",
    "description": null,
    "lineNumber": 572,
    "undocument": true,
    "interface": false,
    "extends": [
      "AttractionsIO"
    ]
  },
  {
    "__docId__": 154,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/attractionsio/attractionsio.js~LegolandWindsor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~LegolandWindsor#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 573,
    "undocument": true
  },
  {
    "__docId__": 155,
    "kind": "class",
    "name": "LegolandOrlando",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~LegolandOrlando",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": "{LegolandOrlando}",
    "description": null,
    "lineNumber": 585,
    "undocument": true,
    "interface": false,
    "extends": [
      "AttractionsIO"
    ]
  },
  {
    "__docId__": 156,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/attractionsio/attractionsio.js~LegolandOrlando",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~LegolandOrlando#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 586,
    "undocument": true
  },
  {
    "__docId__": 157,
    "kind": "class",
    "name": "Gardaland",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~Gardaland",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": "{Gardaland}",
    "description": null,
    "lineNumber": 599,
    "undocument": true,
    "interface": false,
    "extends": [
      "AttractionsIO"
    ]
  },
  {
    "__docId__": 158,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/attractionsio/attractionsio.js~Gardaland",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~Gardaland#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 600,
    "undocument": true
  },
  {
    "__docId__": 159,
    "kind": "class",
    "name": "HeidePark",
    "memberof": "lib/parks/attractionsio/attractionsio.js",
    "static": true,
    "longname": "lib/parks/attractionsio/attractionsio.js~HeidePark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/attractionsio/attractionsio.js",
    "importStyle": "{HeidePark}",
    "description": null,
    "lineNumber": 613,
    "undocument": true,
    "interface": false,
    "extends": [
      "AttractionsIO"
    ]
  },
  {
    "__docId__": 160,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/attractionsio/attractionsio.js~HeidePark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/attractionsio/attractionsio.js~HeidePark#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 614,
    "undocument": true
  },
  {
    "__docId__": 161,
    "kind": "file",
    "name": "lib/parks/database.js",
    "content": "import ConfigBase from '../configBase.js';\nimport sieve from './sieve.js';\nimport {reusePromise, reusePromiseForever} from '../reusePromises.js';\nimport HTTP from './http.js';\nimport Cache from '../cache/scopedCache.js';\n\nconst Databases = {};\n\n/**\n * A class that handles fetching and storing data for a resort/park\n */\nexport class Database extends ConfigBase {\n  /**\n   * Construct a new Database object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.useragent = options.useragent || null;\n\n    super(options);\n\n    this.cache = new Cache(this.constructor.name, this.config.cacheVersion || 0);\n\n    this.http = new HTTP();\n    if (this.config.useragent) {\n      this.http.useragent = this.config.useragent;\n    }\n\n    this.http.injectForDomain({hostname: {$exists: true}}, (method, url) => {\n      this.log(method, url);\n    });\n  }\n\n  /**\n   * Pretty print log for this database\n   */\n  log(...args) {\n    console.log(`[\\x1b[32m${this.constructor.name}\\x1b[0m]`, ...args);\n  }\n\n  /**\n   * Get singleton of this class type\n   * @param {object} [options] Options to pass to new instance.\n   * Will only be used if the instance doesn't already exist\n   * @return {Database}\n   */\n  static get(options = {}) {\n    const className = this.name;\n    if (Databases[className] === undefined) {\n      Databases[className] = new this(options);\n    }\n    return Databases[className];\n  }\n\n  /**\n   * Initialise this database object\n   */\n  async init() {\n    // only ever call _init once\n    await reusePromiseForever(this, this._init);\n  }\n\n  /**\n   * Internal init function, override this in child classes for functionality\n   * @abstract\n   */\n  async _init() {}\n\n  /**\n   * Get entities from this database. Optionally filtering by some conditions\n   * @param {object} [filter]\n   */\n  async getEntities(filter = {}) {\n    await this.init();\n\n    const entities = await this.cache.wrap('entities', () => {\n      return reusePromise(this, this._getEntities);\n    }, 1000 * 60); // cache for a minute for faster access\n\n    const filterFn = sieve(filter);\n    return entities.filter(filterFn);\n  }\n\n  /**\n   * Find a single entity from this database\n   * @param {object} [filter]\n   */\n  async findEntity(filter = {}) {\n    const ents = await this.getEntities();\n    const filterFn = sieve(filter);\n    return ents.find(filterFn);\n  }\n\n  /**\n   * Return all entities for this resort/park\n   * @abstract\n   * @return {array<object>}\n   */\n  async _getEntities() {\n    throw new Error(`Database class ${this.constructor.name} missing _getEntities() function`);\n  }\n\n  /**\n   * Get an entity object from it's ID\n   * @param {string} entityId Entity ID\n   */\n  async getEntitiyById(entityId) {\n    return await this.findEntity({\n      id: `${entityId}`,\n    });\n  }\n}\n\nexport default Database;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/database.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 162,
    "kind": "variable",
    "name": "Databases",
    "memberof": "lib/parks/database.js",
    "static": true,
    "longname": "lib/parks/database.js~Databases",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/database.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 163,
    "kind": "class",
    "name": "Database",
    "memberof": "lib/parks/database.js",
    "static": true,
    "longname": "lib/parks/database.js~Database",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/database.js",
    "importStyle": "{Database}",
    "description": "A class that handles fetching and storing data for a resort/park",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "lib/configBase.js~ConfigBase"
    ]
  },
  {
    "__docId__": 164,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/database.js~Database#constructor",
    "access": "public",
    "description": "Construct a new Database object",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 165,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/parks/database.js~Database",
    "static": false,
    "longname": "lib/parks/database.js~Database#cache",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "member",
    "name": "http",
    "memberof": "lib/parks/database.js~Database",
    "static": false,
    "longname": "lib/parks/database.js~Database#http",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "log",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/database.js~Database#log",
    "access": "public",
    "description": "Pretty print log for this database",
    "lineNumber": 37,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": null
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "get",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/database.js~Database.get",
    "access": "public",
    "description": "Get singleton of this class type",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Options to pass to new instance.\nWill only be used if the instance doesn't already exist"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Database"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "init",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#init",
    "access": "public",
    "description": "Initialise this database object",
    "lineNumber": 58,
    "params": [],
    "return": null
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#_init",
    "access": "private",
    "description": "Internal init function, override this in child classes for functionality",
    "lineNumber": 67,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "getEntities",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#getEntities",
    "access": "public",
    "description": "Get entities from this database. Optionally filtering by some conditions",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "findEntity",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#findEntity",
    "access": "public",
    "description": "Find a single entity from this database",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "_getEntities",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#_getEntities",
    "access": "private",
    "description": "Return all entities for this resort/park",
    "lineNumber": 99,
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "abstract": true,
    "params": []
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "getEntitiyById",
    "memberof": "lib/parks/database.js~Database",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/database.js~Database#getEntitiyById",
    "access": "public",
    "description": "Get an entity object from it's ID",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "entityId",
        "description": "Entity ID"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "file",
    "name": "lib/parks/destination.js",
    "content": "import EventEmitter from 'events';\nimport objHash from 'object-hash';\nimport moment from 'moment-timezone';\n\nimport Cache from '../cache/scopedCache.js';\nimport {reusePromiseForever} from '../reusePromises.js';\nimport {entityType} from './parkTypes.js';\nimport {getLiveDataErrors} from './livedata.js';\nimport HTTP from './http.js';\n\nimport {parseConfig} from '../configBase.js';\nimport {validateEntitySchedule} from './scheduledata.js';\n\n/**\n * Return functions available on the supplied object as an array of strings\n * @param {object} obj\n * @return {Array<string>} array of function names\n */\nconst getMethods = (obj) => {\n  const properties = new Set();\n  let currentObj = obj;\n  do {\n    Object.getOwnPropertyNames(currentObj).map((item) => properties.add(item));\n  } while ((currentObj = Object.getPrototypeOf(currentObj)));\n  return [...properties.keys()].filter((item) => typeof obj[item] === 'function');\n};\n\n/**\n * Meta-programming commands\n * Functions can declare tags to add extra functionality to their behaviour.\n * This is a replacement for decorators until they actually exist.\n */\nconst metaCommands = {\n  // @cache|minutesToCache\n  cache: function(fnName, args) {\n    const originalFunction = this[fnName].bind(this);\n\n    this[fnName] = async (...originalFunctionArgs) => {\n      let funcCacheName = `metacache_${fnName}`;\n      if (originalFunctionArgs.length > 0) {\n        funcCacheName = `metacache_${fnName}_${originalFunctionArgs.map((x) => JSON.stringify(x)).join(',')}`;\n      }\n\n      // figure out cache time from args[0]\n      let cacheTime = 1000 * 60 * 5; // default to 5 minutes\n      if (args.length > 0) {\n        // look for units of time\n        const timeUnit = args[0].match(/^(\\d+)([mhd])$/);\n        if (timeUnit) {\n          const time = parseInt(timeUnit[1], 10);\n          const unit = timeUnit[2];\n          switch (unit) {\n            case 'm':\n              cacheTime = 1000 * 60 * time;\n              break;\n            case 'h':\n              cacheTime = 1000 * 60 * 60 * time;\n              break;\n            case 'd':\n              cacheTime = 1000 * 60 * 60 * 24 * time;\n              break;\n          }\n        } else {\n          // if no unit of time is supplied, assume minutes\n          cacheTime = parseInt(args[0], 10) * 1000 * 60;\n        }\n      }\n\n      // replace original function with a cache wrap\n      return this.cache.wrap(\n          // try and make a unique name based on our function name\n          //  to store in cache\n          funcCacheName,\n          // call original function if value not in cache\n          async () => {\n            return originalFunction(...originalFunctionArgs);\n          },\n          // @cache takes argument in minutes\n          parseInt(args[0], 10) * 1000 * 60,\n      );\n    };\n  },\n};\n\n/**\n * The base Destination object\n */\nexport class Destination extends EventEmitter {\n  /**\n   * Construct a new empty Destination object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    super();\n\n    // add class name to our $env options\n    options.configPrefixes = [this.constructor.name].concat(\n        options.configPrefixes || [],\n    );\n\n    // debug callback to list environment variables\n    if (options?.envCallback) {\n      const keys = Object.keys(options);\n      const prefix = this.constructor.name;\n      keys.map((x) => {\n        options?.envCallback(prefix, x);\n      });\n    }\n\n    // parse config from ENV by combining with options\n    const config = parseConfig(options);\n    this.config = config;\n\n    this._destinationEntityObject = null;\n\n    // create a new cache object for this destination\n    this.cache = new Cache(this.constructor.name, this.config.cacheVersion || 0);\n\n    this._allEntities = null;\n    this._allEntitiesLastStash = 0;\n\n    this.http = new HTTP();\n    if (this.config.useragent) {\n      this.http.useragent = this.config.useragent;\n    }\n\n    if (!this.config.timezone) {\n      throw new Error(`All destination objects must have a timezone! ${this.constructor.name}`);\n    }\n\n    // debug log all HTTP requests\n    this.http.injectForDomain({hostname: {$exists: true}}, (method, url) => {\n      this.log(method, url);\n    });\n\n    // get list of all class functions for some meta programming\n    const funcs = getMethods(this);\n    funcs.forEach((funcName) => {\n      // skip constructor\n      if (funcName === 'constructor') return;\n\n      // get function as a string\n      const funcStr = this[funcName].toString();\n      // match any lines that contain only a string starting with @\n      //  eg. '@cache()';\n      // TODO - match multiple times for complex meta functions\n      const match = /^\\s*(['\"`])\\s*@([^'\"`]+)\\1;?/mg.exec(funcStr);\n      if (match) {\n        const splits = match[2].split('|');\n        // look for matching meta function\n        const metaFn = metaCommands[splits[0]];\n        if (!metaFn) {\n          return;\n        }\n\n        // console.log(`Setting up ${splits[0]} for ${funcName}...`);\n\n        // call meta function\n        metaFn.call(this, funcName, splits.slice(1));\n      }\n    });\n  }\n\n  /**\n   * Debug log\n   * @param  {...any} args Message to debug log\n   */\n  log(...args) {\n    console.log(`[\\x1b[32m${this.constructor.name}\\x1b[0m]`, ...args);\n  }\n\n  /**\n   * Initialise the object. Will only be initialised once\n   */\n  async init() {\n    await reusePromiseForever(this, this._init);\n  }\n\n  /**\n   * Instance implementation of init, implement this function for a single-execution of init()\n   */\n  async _init() { }\n\n  /**\n   * Return the current time for this destination in its local timezone\n   * @return {moment}\n   */\n  getTimeNowMoment() {\n    return moment().tz(this.config.timezone);\n  }\n\n  /**\n   * Return the current time for this destination in its local timezone\n   * @return {string}\n   */\n  getTimeNow() {\n    return this.getTimeNowMoment().format();\n  }\n\n  /**\n   * Set local live data cache for an entity\n   * @param {string} id\n   * @param {object} data\n   * @param {object} [lock] Optional lock file to use for transactions\n   * @private\n   */\n  async setLiveCache(id, data, lock) {\n    const cache = lock ? lock : this.cache;\n    const cacheTime = 1000 * 60 * 60 * 24 * 30 * 6; // 6 months\n    await cache.set(`${id}_live`, data, cacheTime);\n    // generate hash and store separately\n    await cache.set(`${id}_livehash`, data ? objHash(data) : undefined, cacheTime);\n  }\n\n  /**\n   * Get the locally stored live data for an ID\n   * @param {string} id\n   * @param {object} [lock]\n   * @return {object}\n   */\n  async getLiveCache(id, lock) {\n    const cache = lock ? lock : this.cache;\n    return cache.get(`${id}_live`);\n  }\n\n  /**\n   * Get the hash of a stored live data of an entity\n   * @param {string} id\n   * @param {object} [lock] Optional lock file to use for transactions\n   * @private\n   */\n  async getLiveHash(id, lock) {\n    const cache = lock ? lock : this.cache;\n    return await cache.get(`${id}_livehash`);\n  }\n\n  /**\n   * Build a generic base entity object\n   * @param {object} data\n   * @return {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = {\n      timezone: this.config.timezone,\n    };\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    throw new Error('buildDestinationEntity() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    throw new Error('buildParkEntities() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    throw new Error('buildAttractionEntities() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    throw new Error('buildShowEntities() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    throw new Error('buildRestaurantEntities() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Get the Entity object for this destination\n   * @return {Object}\n   */\n  async getDestinationEntity() {\n    await this.init();\n\n    // TODO - cache this?\n    if (!this._destinationEntityObject) {\n      this._destinationEntityObject = await this.buildDestinationEntity();\n    }\n    return this._destinationEntityObject;\n  }\n\n  /**\n   * Get all entities belonging to this destination.\n   */\n  async getAllEntities() {\n    const minCacheTime = +new Date() - (1000 * 60 * 5); // refresh every 5 minutes\n    if (this._allEntities && this._allEntitiesLastStash > minCacheTime) {\n      return this._allEntities;\n    }\n\n    // TODO - cache each of these calls for some time\n    // TODO - promise reuse this function\n    const destination = await this.getDestinationEntity();\n\n    this._allEntities = [].concat(\n        destination,\n        (await this.buildParkEntities()).map((x) => {\n          return {\n            ...x,\n            _destinationId: destination._id,\n          };\n        }),\n        (await this.buildAttractionEntities()).map((x) => {\n          return {\n            ...x,\n            _destinationId: destination._id,\n          };\n        }),\n        (await this.buildShowEntities()).map((x) => {\n          return {\n            ...x,\n            _destinationId: destination._id,\n          };\n        }),\n        (await this.buildRestaurantEntities()).map((x) => {\n          return {\n            ...x,\n            _destinationId: destination._id,\n          };\n        }),\n    );\n\n    this._allEntitiesLastStash = +new Date();\n    return this._allEntities;\n  }\n\n  /**\n   * Get all park entities within this destination.\n   */\n  async getParkEntities() {\n    const entities = await this.getAllEntities();\n    return entities.filter((e) => e.entityType === entityType.park);\n  }\n\n  /**\n   * Get all destination entities within this destination.\n   */\n  async getDestinationEntities() {\n    const entities = await this.getAllEntities();\n    return entities.filter((e) => e.entityType === entityType.destination);\n  }\n\n  /**\n   * Get all attraction entities within this destination.\n   */\n  async getAttractionEntities() {\n    const entities = await this.getAllEntities();\n    return entities.filter((e) => e.entityType === entityType.attraction);\n  }\n\n  /**\n   * Get all show entities within this destination.\n   */\n  async getShowEntities() {\n    const entities = await this.getAllEntities();\n    return entities.filter((e) => e.entityType === entityType.show);\n  }\n\n  /**\n   * Get all restaurant entities within this destination.\n   */\n  async getRestaurantEntities() {\n    const entities = await this.getAllEntities();\n    return entities.filter((e) => e.entityType === entityType.restaurant);\n  }\n\n  /**\n   * Given an internal entity ID, return it's full entity object\n   * @param {string} id\n   * @return {object}\n   */\n  async getEntityFromId(id) {\n    const entities = await this.getAllEntities();\n    return entities.find((x) => x._id === id);\n  }\n\n  // TODO - live data API methods in destination\n\n  /**\n   * Update an entity with livedata\n   * @param {string} internalId\n   * @param {object} data\n   */\n  async updateEntityLiveData(internalId, data) {\n    // format incoming livedata to iron our any weird sorting inconsistency\n    //  sort showtimes by startTime\n    if (data?.showtimes) {\n      data.showtimes.sort((a, b) => {\n        if (!a.startTime || !b.startTime) return false;\n        return moment(a.startTime).unix() - moment(b.startTime).unix();\n      });\n    }\n\n    // stack up any emit events we want to send\n    //  we will build these up inside our database transaction,\n    //  but don't actually send them until we've released our lock\n    const events = [];\n\n    // get our entity doc\n    const entity = await this.getEntityFromId(internalId);\n    if (!entity) {\n      return;\n\n      this.emit('error', internalId, 'UNKNOWN_ENTITY_LIVEDATA', {\n        message: `Trying to assign live data update to unknown entity ${internalId}`,\n        data,\n      });\n      return;\n    }\n\n    // validate incoming data\n    const validationErrors = getLiveDataErrors(data);\n    if (validationErrors !== null) {\n      this.emit('error', internalId, 'INVALID_LIVEDATA', {\n        message: `Error validating incoming live data [${internalId}] ${JSON.stringify(data)}.\n\\t${validationErrors.map((x) => `${x.dataPath} ${x.message}`).join('\\n\\t')}`,\n        data,\n      });\n      return;\n    }\n\n    // lock our live data in a transaction to avoid weird conflicts\n    await this.cache.runTransaction(async (lock) => {\n      try {\n        // check live data hasn't changed from cache\n        const storedHash = await this.getLiveHash(internalId, lock);\n\n        if (storedHash) {\n          const newHash = data ? objHash(data) : undefined;\n          if (newHash === storedHash) {\n            // incoming data matches stored data! no change\n            return;\n          }\n        }\n\n        // TODO - get previous data and diff\n        // const existingData = await this.getLiveCache(internalId, lock);\n\n        // TODO - identify specific live data type changes\n        //  eg. broadcast \"queueupdate\" changes etc.\n\n        // always push a general \"liveupdate\" event\n        events.push(['liveupdate', internalId, data]);\n\n        // store locally\n        await this.setLiveCache(internalId, data, lock);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n\n    // emit all our events *outside* the database transaction\n    //  so we don't block database IO any longer than we need to\n    events.forEach((ev) => {\n      this.emit(...ev);\n    });\n  }\n\n  /**\n   * Build all live data for entities - implement this function in child class\n   */\n  async buildEntityLiveData() {\n    throw new Error('buildEntityLiveData() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Build all schedule data for entities - implement this function in child class\n   * Returns array of schedule objects\n   */\n  async buildEntityScheduleData() {\n    throw new Error('buildEntityScheduleData() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Get all live data for entities\n   */\n  async getEntityLiveData() {\n    await this.init();\n    const liveData = (await this.buildEntityLiveData()) || [];\n\n    // process all live data we generated\n    for (let liveDataIdx = 0; liveDataIdx < liveData.length; liveDataIdx++) {\n      const data = liveData[liveDataIdx];\n      try {\n        await this.updateEntityLiveData(data._id, data);\n      } catch (e) {\n        // if (!e instanceof EntityNotFound) {\n        console.error(`Failed to apply live data to ${data._id}`);\n        console.error(e);\n        // }\n        // 19411262;entityType=Attraction = Pop/Art Skyliner Line\n        // 19404062;entityType=Attraction = Hollywood Studios Skyliner Line\n        // 19404065;entityType=Attraction = Epcot Skyliner Line\n      }\n    }\n\n    return liveData;\n  }\n\n  /**\n   * Get all schedules for this destination's entites\n   * @return {Array<object>} Array of objects containing _id and schedules\n   */\n  async getEntitySchedules() {\n    await this.init();\n    const scheduleData = (await this.buildEntityScheduleData()) || [];\n\n    // validate schedule data\n    scheduleData.forEach((data, idx) => {\n      const errors = validateEntitySchedule(data);\n      if (errors) {\n        this.emit('error', data._id, 'INVALID_SCHEDULEDATA', {\n          message: `Destination returned invalid schedule data for ${data._id}`,\n          data: errors,\n        });\n        // clear out invalid schedule data\n        data.schedule = [];\n      } else {\n        // sort data by openingTime\n        data.schedule.sort((a, b) => {\n          return moment(a.openingTime).valueOf() - moment(b.openingTime).valueOf();\n        });\n      }\n    });\n\n    return scheduleData;\n  }\n\n  /**\n   * Clear the cache for a given meta function\n   * @private\n   * @param {string} functionName\n   * @param {Array<*>} args\n   */\n  async _clearFunctionCache(functionName, args = []) {\n    let funcCacheName = `metacache_${functionName}`;\n    if (args.length > 0) {\n      funcCacheName = `metacache_${functionName}_${args.map((x) => JSON.stringify(x)).join(',')}`;\n    }\n    await this.cache.set(funcCacheName, null, -1);\n  }\n\n  /**\n   * Helper function to call a function, passing in a date for each date x days in the future.\n   * First date will be current park date.\n   * @param {Function} func\n   * @param {Number} dates\n   */\n  async forEachUpcomingDate(func, dates = 30) {\n    const now = this.getTimeNowMoment();\n    const end = now.clone().add(dates, 'days');\n\n    const results = [];\n\n    for (; now.isSameOrBefore(end, 'day'); now.add(1, 'day')) {\n      const d = await func(now.clone());\n      if (d) {\n        results.push(d);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get the app version of an Android package ID\n   * Only returns a valid response for apps tracked in the appwatch tracker service\n   * @param {string} packageId\n   * @return {string|undefined}\n   */\n  async getAndroidAPPVersion(packageId) {\n    // cache 12 hours\n    '@cache|720';\n    const resp = await this.http(\n        'GET',\n        `https://appwatch.themeparks.wiki/latest/${packageId}`,\n        {},\n    );\n    return resp?.body?.version || undefined;\n  }\n}\n\nexport default Destination;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/destination.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 176,
    "kind": "function",
    "name": "getMethods",
    "memberof": "lib/parks/destination.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/destination.js~getMethods",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/destination.js",
    "importStyle": null,
    "description": "Return functions available on the supplied object as an array of strings",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "array of function names"
    },
    "ignore": true
  },
  {
    "__docId__": 177,
    "kind": "variable",
    "name": "metaCommands",
    "memberof": "lib/parks/destination.js",
    "static": true,
    "longname": "lib/parks/destination.js~metaCommands",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/destination.js",
    "importStyle": null,
    "description": "Meta-programming commands<br />Functions can declare tags to add extra functionality to their behaviour.<br />This is a replacement for decorators until they actually exist.",
    "lineNumber": 33,
    "type": {
      "types": [
        "{\"cache\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 178,
    "kind": "class",
    "name": "Destination",
    "memberof": "lib/parks/destination.js",
    "static": true,
    "longname": "lib/parks/destination.js~Destination",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/destination.js",
    "importStyle": "{Destination}",
    "description": "The base Destination object",
    "lineNumber": 88,
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 179,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#constructor",
    "access": "public",
    "description": "Construct a new empty Destination object",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 180,
    "kind": "member",
    "name": "config",
    "memberof": "lib/parks/destination.js~Destination",
    "static": false,
    "longname": "lib/parks/destination.js~Destination#config",
    "access": "public",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "member",
    "name": "_destinationEntityObject",
    "memberof": "lib/parks/destination.js~Destination",
    "static": false,
    "longname": "lib/parks/destination.js~Destination#_destinationEntityObject",
    "access": "private",
    "description": null,
    "lineNumber": 114,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/parks/destination.js~Destination",
    "static": false,
    "longname": "lib/parks/destination.js~Destination#cache",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "member",
    "name": "_allEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "static": false,
    "longname": "lib/parks/destination.js~Destination#_allEntities",
    "access": "private",
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "member",
    "name": "_allEntitiesLastStash",
    "memberof": "lib/parks/destination.js~Destination",
    "static": false,
    "longname": "lib/parks/destination.js~Destination#_allEntitiesLastStash",
    "access": "private",
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "member",
    "name": "http",
    "memberof": "lib/parks/destination.js~Destination",
    "static": false,
    "longname": "lib/parks/destination.js~Destination#http",
    "access": "public",
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "log",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#log",
    "access": "public",
    "description": "Debug log",
    "lineNumber": 168,
    "params": [
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Message to debug log"
      }
    ],
    "return": null
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "init",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#init",
    "access": "public",
    "description": "Initialise the object. Will only be initialised once",
    "lineNumber": 175,
    "params": [],
    "return": null
  },
  {
    "__docId__": 188,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#_init",
    "access": "private",
    "description": "Instance implementation of init, implement this function for a single-execution of init()",
    "lineNumber": 182,
    "params": [],
    "return": null
  },
  {
    "__docId__": 189,
    "kind": "method",
    "name": "getTimeNowMoment",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getTimeNowMoment",
    "access": "public",
    "description": "Return the current time for this destination in its local timezone",
    "lineNumber": 188,
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "getTimeNow",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getTimeNow",
    "access": "public",
    "description": "Return the current time for this destination in its local timezone",
    "lineNumber": 196,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "setLiveCache",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#setLiveCache",
    "access": "private",
    "description": "Set local live data cache for an entity",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "lock",
        "description": "Optional lock file to use for transactions"
      }
    ],
    "return": null
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "getLiveCache",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getLiveCache",
    "access": "public",
    "description": "Get the locally stored live data for an ID",
    "lineNumber": 221,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "lock",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "getLiveHash",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getLiveHash",
    "access": "private",
    "description": "Get the hash of a stored live data of an entity",
    "lineNumber": 232,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "lock",
        "description": "Optional lock file to use for transactions"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#buildBaseEntityObject",
    "access": "public",
    "description": "Build a generic base entity object",
    "lineNumber": 242,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 195,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 253,
    "params": [],
    "return": null
  },
  {
    "__docId__": 196,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 260,
    "params": [],
    "return": null
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 267,
    "params": [],
    "return": null
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 274,
    "params": [],
    "return": null
  },
  {
    "__docId__": 199,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 281,
    "params": [],
    "return": null
  },
  {
    "__docId__": 200,
    "kind": "method",
    "name": "getDestinationEntity",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getDestinationEntity",
    "access": "public",
    "description": "Get the Entity object for this destination",
    "lineNumber": 289,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "getAllEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getAllEntities",
    "access": "public",
    "description": "Get all entities belonging to this destination.",
    "lineNumber": 302,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "getParkEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getParkEntities",
    "access": "public",
    "description": "Get all park entities within this destination.",
    "lineNumber": 347,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "getDestinationEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getDestinationEntities",
    "access": "public",
    "description": "Get all destination entities within this destination.",
    "lineNumber": 355,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "getAttractionEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getAttractionEntities",
    "access": "public",
    "description": "Get all attraction entities within this destination.",
    "lineNumber": 363,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "getShowEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getShowEntities",
    "access": "public",
    "description": "Get all show entities within this destination.",
    "lineNumber": 371,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "getRestaurantEntities",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getRestaurantEntities",
    "access": "public",
    "description": "Get all restaurant entities within this destination.",
    "lineNumber": 379,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "getEntityFromId",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getEntityFromId",
    "access": "public",
    "description": "Given an internal entity ID, return it's full entity object",
    "lineNumber": 389,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "updateEntityLiveData",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#updateEntityLiveData",
    "access": "public",
    "description": "Update an entity with livedata",
    "lineNumber": 401,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "internalId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#buildEntityLiveData",
    "access": "public",
    "description": "Build all live data for entities - implement this function in child class",
    "lineNumber": 479,
    "params": [],
    "return": null
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#buildEntityScheduleData",
    "access": "public",
    "description": "Build all schedule data for entities - implement this function in child class<br />Returns array of schedule objects",
    "lineNumber": 487,
    "params": [],
    "return": null
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "getEntityLiveData",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getEntityLiveData",
    "access": "public",
    "description": "Get all live data for entities",
    "lineNumber": 494,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "getEntitySchedules",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getEntitySchedules",
    "access": "public",
    "description": "Get all schedules for this destination's entites",
    "lineNumber": 521,
    "return": {
      "nullable": null,
      "types": [
        "Array<object>"
      ],
      "spread": false,
      "description": "Array of objects containing _id and schedules"
    },
    "params": []
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "_clearFunctionCache",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#_clearFunctionCache",
    "access": "private",
    "description": "Clear the cache for a given meta function",
    "lineNumber": 552,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "functionName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array<*>"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "forEachUpcomingDate",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#forEachUpcomingDate",
    "access": "public",
    "description": "Helper function to call a function, passing in a date for each date x days in the future.<br />First date will be current park date.",
    "lineNumber": 566,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "dates",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "getAndroidAPPVersion",
    "memberof": "lib/parks/destination.js~Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/destination.js~Destination#getAndroidAPPVersion",
    "access": "public",
    "description": "Get the app version of an Android package ID<br />Only returns a valid response for apps tracked in the appwatch tracker service",
    "lineNumber": 588,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "packageId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string",
        "undefined"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 219,
    "kind": "file",
    "name": "lib/parks/efteling/efteling.js",
    "content": "import {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\nimport moment from 'moment-timezone';\nimport Destination from '../destination.js';\n\n/**\n * Efteling Park Object\n */\nexport class Efteling extends Destination {\n  /**\n   * Create a new Efteling Park object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Efteling';\n    options.timezone = options.timezone || 'Europe/Amsterdam';\n\n    options.apiKey = options.apiKey || '';\n    options.apiVersion = options.apiVersion || '';\n    options.appVersion = options.appVersion || '';\n\n    options.searchUrl = options.searchUrl || 'https://prd-search-acs.efteling.com/2013-01-01/search';\n    options.waitTimesUrl = options.waitTimesUrl || 'https://api.efteling.com/app/wis/';\n\n    // bump cache to invalidate the POI data that has been updated\n    options.cacheVersion = 1;\n\n    super(options);\n\n    if (!this.config.apiKey) throw new Error('Missing Efteling apiKey');\n    if (!this.config.apiVersion) throw new Error('Missing Efteling apiVersion');\n    if (!this.config.appVersion) throw new Error('Missing Efteling appVersion');\n\n    this.http.injectForDomain({\n      // match either of the API domains\n      $or: [\n        {\n          hostname: 'api.efteling.com',\n        },\n        {\n          hostname: 'prd-search-acs.efteling.com',\n        },\n      ],\n    }, (method, url, data, options) => {\n      // all requests from the app to any efteling subdomain should send these headers\n      options.headers['x-app-version'] = this.config.appVersion;\n      options.headers['x-app-name'] = 'Efteling';\n      options.headers['x-app-id'] = 'nl.efteling.android';\n      options.headers['x-app-platform'] = 'Android';\n      options.headers['x-app-language'] = 'en';\n      options.headers['x-app-timezone'] = this.config.timezone;\n      // override user-agent here, rather than class-wide\n      //  any other non-Efteling API requests can use the default user-agent\n      options.headers['user-agent'] = 'okhttp/4.4.0';\n      options.compressed = true;\n    });\n\n    this.http.injectForDomain({\n      // only use these headers for the main API domain\n      hostname: 'api.efteling.com',\n    }, (method, url, data, options) => {\n      // api.efteling.com requries an API key as well as the above headers\n      options.headers['x-api-key'] = this.config.apiKey;\n      options.headers['x-api-version'] = this.config.apiVersion;\n    });\n  }\n\n  /**\n   * Fetch POI data from Efteling API\n   * @return {array<object>}\n   */\n  async _fetchPOIData({language = en} = {}) {\n    // cache for 12 hours\n    '@cache|720';\n\n    // curl -H 'Host: prd-search-acs.efteling.com' -H 'user-agent: okhttp/4.4.0' -H 'x-app-version: v3.7.1' -H 'x-app-name: Efteling' -H 'x-app-id: nl.efteling.android' -H 'x-app-platform: Android' -H 'x-app-language: en' -H 'x-app-timezone: Europe/London' --compressed 'https://prd-search-acs.efteling.com/2013-01-01/search?q.parser=structured&size=1000&q=%28and%20%28phrase%20field%3Dlanguage%20%27en%27%29%29'\n    const fetchedPOIData = await this.http('GET', this.config.searchUrl, {\n      'size': 1000,\n      'q.parser': 'structured',\n      'q': `(and (phrase field=language \\'${language}\\'))`,\n    });\n\n    return fetchedPOIData?.body?.hits?.hit;\n  }\n\n  /**\n   * Get Efteling POI data\n   * This data contains general ride names, descriptions etc.\n   * Wait time data references this to get ride names\n   */\n  async getPOIData() {\n    '@cache|5';\n\n    // grab English data first\n    const data = await this._fetchPOIData({language: 'en'});\n    if (!data) {\n      throw new Error('Failed to fetch Efteling POI data [en]');\n    }\n\n    // also grab native language data and insert any missing entries\n    const nativeData = await this._fetchPOIData({language: 'nl'});\n    if (!nativeData) {\n      throw new Error('Failed to fetch Efteling POI data [nl]');\n    }\n\n    // merge the two arrays with English data replacing NL data\n    const mergedData = nativeData.map((nativeItem) => {\n      const englishItem = data.find((item) => item.fields.id === nativeItem.fields.id);\n      if (!englishItem) {\n        // if the native item is missing, add it to the end of the array\n        return nativeItem;\n      }\n\n      // if English version exists, use that one\n      return englishItem;\n    });\n\n    const poiData = {};\n    mergedData.forEach((hit) => {\n      // skip any entries that aren't shown in the app\n      if (hit.hide_in_app) return;\n\n      if (hit.fields) {\n        poiData[hit.fields.id] = {\n          id: hit.fields.id,\n          name: hit.fields.name,\n          type: hit.fields.category,\n          props: hit.fields.properties,\n        };\n\n        // hard-code station names so they can be distinct\n        if (hit.fields.id === 'stoomtreinr') {\n          poiData[hit.fields.id].name = poiData[hit.fields.id].name + ' - Oost';\n        }\n        if (hit.fields.id === 'stoomtreinm') {\n          poiData[hit.fields.id].name = poiData[hit.fields.id].name + ' - Marerijk';\n        }\n\n        // try to parse lat/long\n        //  edge-case: some rides have dud \"0.0,0.0\" location, ignore these\n        if (hit.fields.latlon && hit.fields.latlon !== '0.0,0.0') {\n          const match = /([0-9.]+),([0-9.]+)/.exec(hit.fields.latlon);\n          if (match) {\n            poiData[hit.fields.id].location = {\n              latitude: Number(match[1]),\n              longitude: Number(match[2]),\n            };\n          }\n        }\n\n        // check for any alternative versions of the ride\n        //  this is usually the single rider line, though one is a \"boatride\"\n        if (hit.fields.alternateid && hit.fields.alternatetype === 'singlerider') {\n          poiData[hit.fields.id].singleRiderId = hit.fields.alternateid;\n        }\n      }\n    });\n\n    return poiData;\n  }\n\n  /**\n   * Get calendar data for the given month and year\n   * @param {string} month\n   * @param {string} year\n   * @return {array<object>}\n   */\n  async getCalendarMonth(month, year) {\n    return await this.cache.wrap(`calendar_${year}_${month}`, async () => {\n      const data = await this.http(\n        'GET',\n        `https://www.efteling.com/service/cached/getpoiinfo/en/${year}/${month}`,\n        null,\n        {\n          headers: {\n            'X-Requested-With': 'XMLHttpRequest',\n            'referer': 'https://www.efteling.com/en/park/opening-hours?app=true',\n            'cookie': 'website#lang=en',\n          },\n          json: true,\n        },\n      );\n\n      // Efteling returns 400 once the month is in the past\n      if (data.statusCode === 400) {\n        return undefined;\n      }\n\n      if (!data?.body?.OpeningHours) throw new Error(`Unable to find opening hours for Efteling ${data.body}`);\n\n      return data.body;\n    }, 1000 * 60 * 60 * 12); // 12 hours\n  }\n\n  /**\n * Get restaurant operating hours from API\n * @param {string} day\n * @param {string} month\n * @param {string} year\n */\n  async getRestaurantOperatingHours(day, month, year) {\n    return await this.cache.wrap(`restaurant_${year}_${month}_${day}`, async () => {\n      const waitTimes = await this.http('GET', this.config.waitTimesUrl, {\n        language: 'en',\n      });\n\n      if (!waitTimes?.body?.AttractionInfo) {\n        throw new Error(`Unable to find restaurant operating hours for Efteling ${data.body}`);\n      }\n\n      return waitTimes.body;\n    }, 1000 * 60 * 60 * 12); // 12 hours\n  }\n\n  /**\n   * Return restaurant operating hours for the supplied date\n   * @param {moment} date\n   */\n  async _getRestaurantOperatingHoursForDate(date) {\n    const cal = await this.getRestaurantOperatingHours(date.format('D'), date.format('M'), date.format('YYYY'));\n\n    if (cal === undefined) return undefined;\n\n    const data = cal.AttractionInfo;\n\n    return data.map((entry) => {\n      if (entry.Type !== 'Horeca') return;\n\n      if (!entry.OpeningTimes || entry.OpeningTimes.length == 0) {\n        return {\n          restaurantID: entry.Id,\n          openingTime: 0,\n          closingTime: 0,\n          status: statusType.closed,\n        };\n      }\n\n      const openingTimes = entry.OpeningTimes;\n\n      return {\n        restaurantID: entry.Id,\n        openingTime: moment(openingTimes[0].HourFrom).format(),\n        closingTime: moment(openingTimes[0].HourTo).format(),\n        type: scheduleType.operating,\n      };\n    }).filter((x) => x !== undefined);\n  }\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data \n   * @returns {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    entity._id = data?.id || entity._id;\n    entity.name = data?.name || entity.name;\n\n    // add location (if found)\n    if (data?.location !== undefined) {\n      entity.location = {\n        longitude: data.location.longitude,\n        latitude: data.location.latitude,\n      };\n    }\n\n    // TODO - extra facet data\n    /*\n    // look for any other useful tags\n    // may get wet\n    await this.toggleAttractionTag(id, tagType.mayGetWet, p.props.indexOf('wet') >= 0);\n    // tag \"pregnant people should not ride\" attractions\n    await this.toggleAttractionTag(\n      id,\n      tagType.unsuitableForPregnantPeople,\n      p.props.indexOf('pregnantwomen') >= 0,\n    );\n\n    // single rider queue available?\n    await this.setAttractionTag(\n      id,\n      null,\n      tagType.singleRider,\n      !!p.singleRiderId,\n    );\n\n    // look for attraction minimum height\n    const minHeightProp = p.props.find((prop) => prop.indexOf('minimum') === 0);\n    if (minHeightProp !== undefined) {\n      const minHeightNumber = Number(minHeightProp.slice(7));\n      if (!isNaN(minHeightNumber)) {\n        await this.setAttractionTag(id, 'minimumHeight', tagType.minimumHeight, {\n          height: minHeightNumber,\n          unit: 'cm',\n        });\n      }\n    }*/\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    return {\n      ...this.buildBaseEntityObject({\n        name: \"Efteling Themepark Resort\",\n      }),\n      _id: 'eftelingresort',\n      slug: 'eftelingresort',\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    const destination = await this.buildDestinationEntity();\n    return [\n      {\n        ...this.buildBaseEntityObject({\n          name: this.config.name,\n        }),\n        _id: 'efteling',\n        _destinationId: destination._id,\n        _parentId: destination._id,\n        slug: 'efteling',\n        entityType: entityType.park,\n      },\n    ];\n  }\n\n  async _buildArrayOfEntitiesOfType(type, fields = {}) {\n    const destination = await this.buildDestinationEntity();\n    const poi = await this.getPOIData();\n\n    // some valid attraction types from the Efteling API:\n    // 'attraction', 'show', 'merchandise', 'restaurant', 'fairytale', 'facilities-toilets', 'facilities-generic', 'eventlocation', 'game'\n\n    const attrs = [];\n\n    const poiKeys = Object.keys(poi);\n    for (let i = 0; i < poiKeys.length; i++) {\n      const id = poiKeys[i];\n      const p = poi[id];\n\n      // if poi data matches our wanted types\n      if (p.type === type) {\n        const attr = {\n          ...fields,\n          ...this.buildBaseEntityObject(p),\n          _destinationId: destination._id,\n          // TODO - are all rides/shows inside the park?\n          _parkId: 'efteling',\n          _parentId: 'efteling',\n        };\n\n        attrs.push(attr);\n      }\n    }\n\n    return attrs;\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    return this._buildArrayOfEntitiesOfType('attraction', {\n      entityType: entityType.attraction,\n      attractionType: attractionType.ride,\n    });\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    return this._buildArrayOfEntitiesOfType('show', {\n      entityType: entityType.show,\n    });\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    // TODO\n    return [];\n  }\n\n  async _fetchWaitTimes() {\n    // cache 1 minute\n    '@cache|1';\n    return (await this.http('GET', this.config.waitTimesUrl, {\n      language: 'en',\n    })).body;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const poiData = await this.getPOIData();\n\n    // this function should return all the live data for all entities in this destination\n    const waitTimes = await this._fetchWaitTimes();\n\n    const attractions = waitTimes?.AttractionInfo;\n    if (!attractions) throw new Error('Efteling wait times response missing AttractionInfo');\n\n    const livedata = [];\n\n    // first, look for single-rider entries\n    const singleRiderData = [];\n    for (let i = 0; i < attractions.length; i++) {\n      const entry = attractions[i];\n      if (poiData[entry.Id] === undefined) {\n        // if we don't have POI data for this attraction, check for single rider IDs and update the main attraction\n        const singleRiderPOI = Object.keys(poiData).find((k) => {\n          return poiData[k].singleRiderId && poiData[k].singleRiderId === entry.Id;\n        });\n\n        if (singleRiderPOI !== undefined) {\n          // we have found a matching single-rider entry!\n          singleRiderData.push({\n            id: singleRiderPOI,\n            time: parseInt(entry.WaitingTime, 10),\n          });\n        }\n      }\n    }\n\n    for (let i = 0; i < attractions.length; i++) {\n      const entry = attractions[i];\n      if (entry.Type !== 'Attraction') continue;\n      if (poiData[entry.Id] === undefined) continue;\n\n      const live = {\n        _id: entry.Id,\n      };\n\n      let rideStatus = null;\n      const rideWaitTime = parseInt(entry.WaitingTime, 10);\n      const rideState = entry.State.toLowerCase();\n      // update ride with wait time data\n      if (rideState === 'storing' || rideState === 'tijdelijkbuitenbedrijf') {\n        // Ride down because of an interruption\n        rideStatus = statusType.down;\n      } else if (rideState === 'buitenbedrijf') {\n        // ride is closed \"for the day\"\n        rideStatus = statusType.closed;\n      } else if (rideState === 'inonderhoud') {\n        // Ride down because of maintenance/refurbishment\n        rideStatus = statusType.refurbishment;\n      } else if (rideState === 'gesloten' || rideState === '' || rideState === 'wachtrijgesloten' || rideState === 'nognietopen') {\n        // ride is \"closed\"\n        rideStatus = statusType.closed;\n      } else if (rideState === 'open') {\n        // Ride operating\n        rideStatus = statusType.operating;\n      }\n\n      if (rideStatus === null) {\n        this.emit('error', new Error(`Unknown Efteling rideStatus ${JSON.stringify(rideState)}`));\n        console.log('Unknown Efteling rideStatus', JSON.stringify(rideState));\n      }\n\n      live.status = rideStatus;\n      live.queue = {\n        [queueType.standBy]: {\n          waitTime: rideStatus == statusType.operating ? rideWaitTime : null,\n        },\n      };\n\n      // add any single rider data (if available)\n      const singleRider = singleRiderData.find((x) => x.id === entry.Id);\n      if (singleRider) {\n        live.queue[queueType.singleRider] = {\n          waitTime: rideStatus == statusType.operating ? singleRider.time : null,\n        };\n      }\n\n      livedata.push(live);\n    }\n\n    return livedata;\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    // get operating hours for next x months\n    const parkSchedule = [];\n\n    const now = this.getTimeNowMoment();\n    const monthsToFetch = 3;\n    const end = now.clone().add(monthsToFetch, 'months');\n    for (; now.isSameOrBefore(end, 'month'); now.add(1, 'month')) {\n      const calData = await this.getCalendarMonth(now.format('M'), now.format('YYYY'));\n      if (calData === undefined) continue;\n\n      calData.OpeningHours.forEach((x) => {\n        const date = moment.tz(x.Date, 'YYYY-MM-DD', this.config.timezone);\n        x.OpeningHours.sort((a, b) => a.Open - b.Open);\n        x.OpeningHours.forEach((d, idx) => {\n          const open = d.Open.split(':').map(Number);\n          const close = d.Close.split(':').map(Number);\n          parkSchedule.push({\n            date: date.format('YYYY-MM-DD'),\n            openingTime: date.clone().set('hour', open[0]).set('minute', open[1]).format(),\n            closingTime: date.clone().set('hour', close[0]).set('minute', close[1]).format(),\n            type: idx === 0 ? scheduleType.operating : scheduleType.informational,\n            description: idx === 0 ? undefined : 'Evening Hours',\n          });\n        });\n      });\n    }\n\n    return [\n      {\n        _id: 'efteling',\n        schedule: parkSchedule,\n      }\n    ];\n  }\n\n}\n\nexport default Efteling;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/efteling/efteling.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 220,
    "kind": "class",
    "name": "Efteling",
    "memberof": "lib/parks/efteling/efteling.js",
    "static": true,
    "longname": "lib/parks/efteling/efteling.js~Efteling",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/efteling/efteling.js",
    "importStyle": "{Efteling}",
    "description": "Efteling Park Object",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 221,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#constructor",
    "access": "public",
    "description": "Create a new Efteling Park object",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "_fetchPOIData",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_fetchPOIData",
    "access": "private",
    "description": "Fetch POI data from Efteling API",
    "lineNumber": 71,
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": [
      {
        "name": "objectPattern",
        "optional": true,
        "types": [
          "{\"language\": *}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ]
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "getPOIData",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#getPOIData",
    "access": "public",
    "description": "Get Efteling POI data<br />This data contains general ride names, descriptions etc.<br />Wait time data references this to get ride names",
    "lineNumber": 90,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "getCalendarMonth",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#getCalendarMonth",
    "access": "public",
    "description": "Get calendar data for the given month and year",
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "getRestaurantOperatingHours",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#getRestaurantOperatingHours",
    "access": "public",
    "description": "Get restaurant operating hours from API",
    "lineNumber": 200,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "day",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "month",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "year",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "_getRestaurantOperatingHoursForDate",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_getRestaurantOperatingHoursForDate",
    "access": "private",
    "description": "Return restaurant operating hours for the supplied date",
    "lineNumber": 218,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 254,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 306,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": string, \"slug\": string, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 320,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "_buildArrayOfEntitiesOfType",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_buildArrayOfEntitiesOfType",
    "access": "private",
    "description": null,
    "lineNumber": 336,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "fields",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 371,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 381,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 390,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "_fetchWaitTimes",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_fetchWaitTimes",
    "access": "private",
    "description": null,
    "lineNumber": 395,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 406,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 498,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 237,
    "kind": "file",
    "name": "lib/parks/entity.js",
    "content": "import ConfigBase from '../configBase.js';\nimport moment from 'moment-timezone';\nimport zlib from 'zlib';\nimport util from 'util';\nimport HTTP from './http.js';\n\nconst zDecompress = util.promisify(zlib.unzip);\nconst zCompress = util.promisify(zlib.deflate);\n\n/**\n * A super-class that Parks/Resorts/etc. inherit from.\n * Handles general logic for objects that are a place/entity.\n */\nexport class Entity extends ConfigBase {\n  /**\n   * Construct a new Entity\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    // offline mode, never request any data, rely on manually serialised data to run\n    options.offline = options.offline || false;\n\n    // generate a random Android user-agent if we aren't supplied one\n    options.useragent = options.useragent || null;\n\n    super(options);\n\n    if (!this.config.name) {\n      throw new Error(`Missing name for constructed Entity object ${this.constructor.name}`);\n    }\n\n    if (!this.config.timezone) {\n      throw new Error(`Missing timezone for constructed Entity object ${this.constructor.name}`);\n    }\n    if (moment.tz.names().indexOf(this.config.timezone) < 0) {\n      throw new Error(`Entity object ${this.constructor.name} gives an invalid timezone: ${this.config.timezone}`);\n    }\n\n    this.http = new HTTP();\n    if (this.config.useragent) {\n      this.http.useragent = this.config.useragent;\n    }\n\n    // debug log all HTTP requests\n    this.http.injectForDomain({hostname: {$exists: true}}, (method, url) => {\n      this.log(method, url);\n    });\n\n    // offline function data\n    this._offlineFunctions = [];\n    this._offlineData = {};\n    this._hasOfflineData = false;\n    this._offlinePromise = null;\n    this._offlinePromiseResolve = null;\n  }\n\n  /**\n   * Debug log\n   * @param  {...any} args Message to debug log\n   */\n  log(...args) {\n    console.log(`[\\x1b[32m${this.getUniqueID()}\\x1b[0m]`, ...args);\n  }\n\n  /**\n   * Get a globally unique ID for this entity\n   * @return {string}\n   */\n  getUniqueID() {\n    // by default, return the class name\n    return this.constructor.name;\n  }\n\n  /**\n   * Return the current time for this entity in its local timezone\n   * @return {moment}\n   */\n  getTimeNowMoment() {\n    return moment().tz(this.config.timezone);\n  }\n\n  /**\n   * Return the current time for this entity in its local timezone\n   * @return {string}\n   */\n  getTimeNow() {\n    return this.getTimeNowMoment().format();\n  }\n\n  /**\n   * Get entity's human-friendly name string\n   * @return {string}\n   */\n  get name() {\n    return this.config.name;\n  }\n\n  /**\n   * Is this object operating offline?\n   */\n  get offline() {\n    return !!this.config.offline;\n  }\n\n  /**\n   * Register a function on this entity for offline access\n   * @param {string} functionName\n   */\n  registerOfflineFunction(functionName) {\n    if (this[functionName] && typeof this[functionName] === 'function') {\n      if (this._offlineFunctions.indexOf(functionName) < 0) {\n        this._offlineFunctions.push(functionName);\n\n        // if we're in offline mode...\n        if (this.offline) {\n          // override function and restore from our data cache instead\n          this[functionName] = async () => {\n            await this.ensureHasOfflineData();\n\n            if (this._offlineData[functionName] !== undefined) {\n              return this._offlineData[functionName];\n            }\n            return undefined;\n          };\n        }\n      }\n    }\n  }\n\n  /**\n   * Called after loading serialised offline data\n   */\n  async _postOfflineLoad() {}\n\n  /**\n   * Serialise this entity\n   * @param {object} bundle Bundle to read/write from/to\n   * @param {boolean} saving Whether we are saving or loading during this serialise operation\n   * @param {object} [options]\n   * @param {number} [options.version=1] Version of the seialised data\n   * @param {boolean} [options.recursive=true] Recurse through attached entities?\n   */\n  async serialise(bundle = {}, saving = true, options = {\n    version: 1,\n    recursive: true,\n  }) {\n    if (saving) {\n      // === Saving ===\n      // default options\n      bundle.version = options.version;\n      bundle.ar = {\n        functions: {},\n        children: [],\n      };\n\n      // loop over all offline functions and store their data\n      for (let i=0; i<this._offlineFunctions.length; i++) {\n        const functionName = this._offlineFunctions[i];\n        bundle.ar.functions[functionName] = await this[functionName]();\n      }\n\n      // TODO - loop over child entities, call serialise on them, then store their bundle.ar in ours\n    } else {\n      // === Loading ===\n      // decompress/load the data\n      const bundleBuffer = await zDecompress(bundle);\n      bundle = JSON.parse(bundleBuffer.toString('utf8'));\n\n      const version = bundle.version || 0;\n      // check we understand this bundle version\n      if (version !== 1) {\n        throw new Error('Unable to load serialised bundle version', version);\n      }\n\n      // restore function data\n      this._offlineData = bundle.ar.functions;\n\n      // TODO - restore child entities\n    }\n\n    if (saving) {\n      // pack and gz to buffer\n      const bundleData = JSON.stringify(bundle);\n      return await zCompress(bundleData);\n    }\n\n    // after loading, run any postUpdate functions\n    this._postOfflineLoad();\n\n    this._hasOfflineData = true;\n\n    // check if any process if waiting for offline data to be ready\n    if (this._offlinePromiseResolve !== null) {\n      this._offlinePromiseResolve();\n      this._offlinePromiseResolve = null;\n      this._offlinePromise = null;\n    }\n  }\n\n  /**\n   * Await until offline data is present\n   */\n  async ensureHasOfflineData() {\n    if (this.offline && !this._hasOfflineData) {\n      if (this._offlinePromise === null) {\n        this._offlinePromise = new Promise((resolve) => {\n          this._offlinePromiseResolve = resolve;\n        });\n      }\n      return this._offlinePromise;\n    }\n  }\n\n  /**\n   * Register a new injection for a specific domain\n   * @param {object} filter Mongo-type query to use to match a URL\n   * @param {function} func Function to call with needle request to inject extra data into.\n   * Function will take arguments: (method, URL, data, options)\n   */\n  async injectForDomain(filter, func) {\n    this.http.injectForDomain(filter, func);\n  }\n}\n\nexport default Entity;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/entity.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 238,
    "kind": "variable",
    "name": "zDecompress",
    "memberof": "lib/parks/entity.js",
    "static": true,
    "longname": "lib/parks/entity.js~zDecompress",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/entity.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 239,
    "kind": "variable",
    "name": "zCompress",
    "memberof": "lib/parks/entity.js",
    "static": true,
    "longname": "lib/parks/entity.js~zCompress",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/entity.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 240,
    "kind": "class",
    "name": "Entity",
    "memberof": "lib/parks/entity.js",
    "static": true,
    "longname": "lib/parks/entity.js~Entity",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/entity.js",
    "importStyle": "{Entity}",
    "description": "A super-class that Parks/Resorts/etc. inherit from.<br />Handles general logic for objects that are a place/entity.",
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "lib/configBase.js~ConfigBase"
    ]
  },
  {
    "__docId__": 241,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#constructor",
    "access": "public",
    "description": "Construct a new Entity",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 242,
    "kind": "member",
    "name": "http",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#http",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 243,
    "kind": "member",
    "name": "_offlineFunctions",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_offlineFunctions",
    "access": "private",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "member",
    "name": "_offlineData",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_offlineData",
    "access": "private",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 245,
    "kind": "member",
    "name": "_hasOfflineData",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_hasOfflineData",
    "access": "private",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 246,
    "kind": "member",
    "name": "_offlinePromise",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_offlinePromise",
    "access": "private",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "member",
    "name": "_offlinePromiseResolve",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_offlinePromiseResolve",
    "access": "private",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "log",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#log",
    "access": "public",
    "description": "Debug log",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Message to debug log"
      }
    ],
    "return": null
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "getUniqueID",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#getUniqueID",
    "access": "public",
    "description": "Get a globally unique ID for this entity",
    "lineNumber": 69,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "getTimeNowMoment",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#getTimeNowMoment",
    "access": "public",
    "description": "Return the current time for this entity in its local timezone",
    "lineNumber": 78,
    "return": {
      "nullable": null,
      "types": [
        "moment"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "getTimeNow",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#getTimeNow",
    "access": "public",
    "description": "Return the current time for this entity in its local timezone",
    "lineNumber": 86,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 252,
    "kind": "get",
    "name": "name",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#name",
    "access": "public",
    "description": "Get entity's human-friendly name string",
    "lineNumber": 94,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 253,
    "kind": "get",
    "name": "offline",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#offline",
    "access": "public",
    "description": "Is this object operating offline?",
    "lineNumber": 101,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "registerOfflineFunction",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#registerOfflineFunction",
    "access": "public",
    "description": "Register a function on this entity for offline access",
    "lineNumber": 109,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "functionName",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 255,
    "kind": "member",
    "name": "[functionName]",
    "memberof": "lib/parks/entity.js~Entity",
    "static": false,
    "longname": "lib/parks/entity.js~Entity#[functionName]",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "_postOfflineLoad",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#_postOfflineLoad",
    "access": "private",
    "description": "Called after loading serialised offline data",
    "lineNumber": 133,
    "params": [],
    "return": null
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "serialise",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#serialise",
    "access": "public",
    "description": "Serialise this entity",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "bundle",
        "description": "Bundle to read/write from/to"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "saving",
        "description": "Whether we are saving or loading during this serialise operation"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "options.version",
        "description": "Version of the seialised data"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.recursive",
        "description": "Recurse through attached entities?"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "ensureHasOfflineData",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#ensureHasOfflineData",
    "access": "public",
    "description": "Await until offline data is present",
    "lineNumber": 203,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "injectForDomain",
    "memberof": "lib/parks/entity.js~Entity",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/entity.js~Entity#injectForDomain",
    "access": "public",
    "description": "Register a new injection for a specific domain",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "filter",
        "description": "Mongo-type query to use to match a URL"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "Function to call with needle request to inject extra data into.\nFunction will take arguments: (method, URL, data, options)"
      }
    ],
    "return": null
  },
  {
    "__docId__": 266,
    "kind": "file",
    "name": "lib/parks/europa/europapark.js",
    "content": "import EuropaParkDB from './europaparkdb.js';\nimport {statusType, queueType, scheduleType, returnTimeState, entityType, attractionType} from '../parkTypes.js';\nimport moment from 'moment-timezone';\nimport Destination from '../destination.js';\n\nexport class EuropaPark extends Destination {\n  constructor(options = {}) {\n    options.name = options.name || \"Europa-Park\";\n    options.timezone = options.timezone || 'Europe/Berlin';\n\n    options.parks = [\n      {\n        id: 493,\n        scope: 'europapark',\n      },\n      {\n        id: 494,\n        scope: 'rulantica',\n      },\n    ];\n\n    super(options);\n\n    if (!this.config.parks) throw new Error('Missing Europa Park Configs');\n  }\n\n  /**\n   * Get our resort database\n   */\n  get db() {\n    return EuropaParkDB.get();\n  }\n\n  static idToString(id) {\n    return `europa_${id}`;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    entity.name = data?.name;\n\n    // add any entity locations\n    if (data?.longitude && data?.latitude) {\n      entity.location = {\n        latitude: data.latitude,\n        longitude: data.longitude,\n      };\n    } else if (data?._src?.longitude && data?._src?.latitude) {\n      entity.location = {\n        latitude: data._src.latitude,\n        longitude: data._src.longitude,\n      };\n    }\n\n    if (data?.id) {\n      entity._id = `${data.id}`;\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this resort\n   */\n  async buildDestinationEntity() {\n    return {\n      ...this.buildBaseEntityObject({\n        name: this.config.name,\n      }),\n      _id: 'europapark',\n      slug: 'europa',\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this resort\n   */\n  async buildParkEntities() {\n    // find all our parks\n    const poiData = await this.db.getParkData();\n\n    const parks = poiData.filter((x) => {\n      return x.type === 'park';\n    });\n\n    const destination = await this.buildDestinationEntity();\n\n    return this.config.parks.map((parkConfig) => {\n      const park = parks.find((x) => x.id === parkConfig.id);\n      if (!park) return undefined;\n\n      return {\n        ...this.buildBaseEntityObject(park),\n        _id: `park_${park.id}`,\n        _destinationId: destination._id,\n        _parentId: destination._id,\n        entityType: entityType.park,\n        slug: parkConfig.scope,\n      };\n    }).filter((x) => !!x);\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    const attr = [];\n    const destination = await this.buildDestinationEntity();\n\n    for (let i = 0; i < this.config.parks.length; i++) {\n      const scope = this.config.parks[i].scope;\n      const parkId = `park_${this.config.parks[i].id}`;\n\n      // get attractions for each park scope\n      const attractions = await this.db.getEntities({\n        '_src.scopes': {\n          $elemMatch: {\n            $eq: scope,\n          },\n        },\n        entityType: {\n          $ne: 'SHOW',\n        },\n      });\n\n      attractions.filter((x) => {\n        // don't send + Pass entrances as separate entities\n        if (x?._src?.name && x._src.name.indexOf('+ Pass entrance') > 0) {\n          return false;\n        }\n        return true;\n      }).forEach((a) => {\n        // push all our attractions into a big array\n        attr.push({\n          ...this.buildBaseEntityObject(a),\n          _parentId: parkId,\n          _parkId: parkId,\n          _destinationId: destination._id,\n          entityType: entityType.attraction,\n          // TODO - detect other types\n          attractionType: attractionType.ride,\n        });\n      });\n    }\n\n    return attr;\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    const destination = await this.buildDestinationEntity();\n\n    const attrs = await this.db.getEntities({\n      entityType: 'SHOW',\n    });\n\n    const shows = [];\n\n    const parkId = `park_${this.config.parks[0].id}`;\n    attrs.forEach((a) => {\n      shows.push({\n        ...this.buildBaseEntityObject(a),\n        _parentId: parkId,\n        _parkId: parkId,\n        _destinationId: destination._id,\n        entityType: entityType.show,\n      });\n    });\n\n    return shows;\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    // TODO\n    return [];\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const attrs = await this.db.getEntities();\n\n    const codeToEntityId = attrs.filter((x) => {\n      return !!x._src.code;\n    }).reduce((acc, x) => {\n      if (x.id) {\n        acc[x._src.code] = x.id;\n      }\n      return acc;\n    }, {});\n\n    const waits = await this.db.getWaitingTimes();\n    const showtimes = await this.db.getShowTimes();\n\n    const livedata = [];\n\n    // first, extract out all the virtual queue data\n    const vQueueData = [];\n    for (let i = 0; i < waits.waitingtimes.length; i++) {\n      const wait = waits.waitingtimes[i];\n\n      const realRide = await this.db.findEntity({\n        '_src.vQueue.code': {\n          $eq: wait.code,\n        },\n      });\n\n      if (realRide !== undefined) {\n        // we found a \"ride\" that has a matching virtual queue\n        //  so this is a \"dummy\" ride that we want to inject back into the actual ride entity\n        let state = returnTimeState.available;\n        switch (wait.time) {\n          case 666:\n            state = returnTimeState.temporarilyFull;\n            break;\n          case 777:\n            state = returnTimeState.finished;\n            break;\n          case (wait.time <= 91):\n            state = returnTimeState.available;\n            break;\n        }\n\n        // store vqueue data so we can pull this when looping over the actual wait time data\n        const entityId = codeToEntityId[realRide._src.code];\n        if (entityId) {\n          vQueueData.push({\n            _id: `${entityId}`,\n            _ignoreCode: wait.code,\n            returnStart: wait.startAt,\n            returnEnd: wait.endAt,\n            state,\n          });\n        }\n      }\n    }\n\n    const getLiveDataEntry = (id) => {\n      // search livedata for existing entry with this ID\n      const existing = livedata.find((x) => x._id === id);\n      if (existing) {\n        return existing;\n      }\n\n      // create a new entry\n      const newEntry = {\n        _id: id,\n        status: statusType.operating,\n      };\n      livedata.push(newEntry);\n      return newEntry;\n    };\n\n    // now actually loop over the wait data\n    for (let i = 0; i < waits.waitingtimes.length; i++) {\n      const wait = waits.waitingtimes[i];\n\n      // first check if this is a virtual queue \"dummy\" entry, and ignore\n      if (vQueueData.find((x) => x._ignoreCode === wait.code)) {\n        continue;\n      }\n\n      // get entity Id from waittime code\n      const entityId = codeToEntityId[wait.code];\n      if (!entityId) continue;\n\n      const live = getLiveDataEntry(entityId);\n\n      // if time == 90, wait time is reported as 90+ in-app\n      // time == 91, virtual queue is open\n      // time == 999, down\n      // time == 222, closed refurb\n      // time == 333, closed\n      // time == 444, closed becaue weather\n      // time == 555, closed because ice\n      // time == 666, virtual queue is \"temporarily full\"\n      // time == 777, virtual queue is completely full\n      switch (wait.time) {\n        case 999:\n        case 444: // weather\n        case 555: // ice\n          live.status = statusType.down;\n          break;\n        case 222:\n          live.status = statusType.refurbishment;\n          break;\n        case 333:\n          live.status = statusType.closed;\n          break;\n      }\n\n      // stand-by wait time\n      if (!live.queue) live.queue = {};\n      live.queue[queueType.standBy] = {\n        waitTime: wait.time <= 90 ? wait.time : null,\n      };\n\n      // look for any virtual queue data\n      const vQ = vQueueData.find((x) => `${x._id}` === `${entityId}`);\n      if (vQ) {\n        live.queue[queueType.returnTime] = {\n          returnStart: vQ.returnStart,\n          returnEnd: vQ.returnEnd,\n          state: vQ.state,\n        };\n      }\n    }\n\n    // showtimes\n    showtimes.showtimes.forEach((show) => {\n      const live = getLiveDataEntry(`shows_${show.showId}`);\n\n      const showEnt = attrs.find((x) => x.id === `shows_${show.showId}`);\n      if (!showEnt) {\n        return;\n      }\n\n      live.showtimes = show.today.map((startTime) => {\n        // startTime is a time string\n        return {\n          startTime: moment(startTime).tz(this.config.timezone).format(),\n          endTime: moment(startTime).add(showEnt._src.duration || 0, 'minutes').tz(this.config.timezone).format(),\n          type: 'Performance',\n        };\n      });\n\n      // show status based on showtimes available\n      if (live.showtimes.length === 0) {\n        live.status = statusType.closed;\n      } else {\n        // if last show has ended, then mark as closed\n        const lastTime = live.showtimes.reduce((acc, x) => {\n          if (moment(x.endTime).isAfter(acc)) {\n            return moment(x.endTime);\n          }\n          return acc;\n        }, moment(live.showtimes[0].startTime));\n\n        const now = this.getTimeNowMoment();\n        if (now.isAfter(lastTime)) {\n          live.status = statusType.closed;\n        }\n      }\n    });\n\n    return livedata;\n  }\n\n  async _getCalendarForPark(parkConfig) {\n    const cal = await this.db.getCalendar();\n    const parkTimes = cal.seasons.filter(\n      // filter opening hours for actual opening times (ignore closed times)\n      // filter by scopes including our park Id\n      (x) => !x.closed && x.scopes.indexOf(parkConfig.scope) >= 0,\n    );\n\n    const times = [];\n\n    const buildDateString = (inDate, date) => {\n      return moment.tz(inDate, this.config.timezone).set({\n        year: date.year(),\n        month: date.month(),\n        date: date.date(),\n      }).format();\n    };\n\n    parkTimes.forEach((hoursRange) => {\n\n      const start = moment(hoursRange.startAt);\n      const end = moment(hoursRange.endAt);\n\n      for (let date = start.clone(); date.isSameOrBefore(end, 'day'); date.add(1, 'day')) {\n\n        times.push({\n          date: date.format('YYYY-MM-DD'),\n          openingTime: buildDateString(hoursRange.startAt, date),\n          closingTime: buildDateString(hoursRange.endAt, date),\n          type: scheduleType.operating,\n        });\n\n        // hotel extra hours\n        if (hoursRange.hotelStartAt && hoursRange.hotelEndAt) {\n          times.push({\n            date: date.format('YYYY-MM-DD'),\n            openingTime: buildDateString(hoursRange.hotelStartAt, date),\n            closingTime: buildDateString(hoursRange.hotelEndAt, date),\n            type: scheduleType.extraHours,\n            description: 'Open To Hotel Guests',\n          });\n        }\n      }\n    });\n\n    return {\n      _id: `park_${parkConfig.id}`,\n      schedule: times,\n    };\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    const scheds = [];\n    for (let i = 0; i < this.config.parks.length; i++) {\n      scheds.push(await this._getCalendarForPark(this.config.parks[i]));\n    }\n    return scheds;\n  }\n}\n\nexport default EuropaPark;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/europa/europapark.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 267,
    "kind": "class",
    "name": "EuropaPark",
    "memberof": "lib/parks/europa/europapark.js",
    "static": true,
    "longname": "lib/parks/europa/europapark.js~EuropaPark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/europa/europapark.js",
    "importStyle": "{EuropaPark}",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 268,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true
  },
  {
    "__docId__": 269,
    "kind": "get",
    "name": "db",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#db",
    "access": "public",
    "description": "Get our resort database",
    "lineNumber": 30,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "idToString",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/europa/europapark.js~EuropaPark.idToString",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "id",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#buildBaseEntityObject",
    "access": "public",
    "description": "",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this resort",
    "lineNumber": 69,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": string, \"slug\": string, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 273,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this resort",
    "lineNumber": 83,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 111,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 275,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 157,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 183,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 191,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 278,
    "kind": "method",
    "name": "_getCalendarForPark",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#_getCalendarForPark",
    "access": "private",
    "description": null,
    "lineNumber": 360,
    "undocument": true,
    "params": [
      {
        "name": "parkConfig",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"_id\": *, \"schedule\": *}"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/europa/europapark.js~EuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europapark.js~EuropaPark#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 416,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 280,
    "kind": "file",
    "name": "lib/parks/europa/europaparkdb.js",
    "content": "import Database from '../database.js';\nimport crypto from 'crypto';\nimport {URL} from 'url';\nimport {tagType, attractionType, entityType} from '../parkTypes.js';\nimport Blowfish from 'egoroof-blowfish';\n\nconst poiEntityTypes = [\n  'shows',\n  'pois',\n];\n\nconst entityTypeToAttractionType = {\n  'shows': entityType.show,\n  'pois': entityType.attraction,\n};\n\nconst subtypesToAllow = {\n  'pois': [\n    'attraction',\n  ],\n};\n\n/**\n * Europa Park Database Class\n */\nexport class DatabaseEuropaPark extends Database {\n  /**\n   * @inheritdoc\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.fbAppId = '';\n    options.fbApiKey = '';\n    options.fbProjectId = '';\n    options.apiBase = '';\n    options.encKey = '';\n    options.encIV = '';\n    options.authURL = '';\n    options.userKey = options.userKey || 'v3_live_android_exozet_api_username';\n    options.passKey = options.passKey || 'v3_live_android_exozet_api_password';\n    options.appVersion = options.appVersion || '10.1.0';\n\n    options.configPrefixes = ['EUROPAPARK'].concat(options.configPrefixes || []);\n\n    super(options);\n\n    if (!this.config.fbApiKey) throw new Error('Missing Europa Park Firebase API Key');\n    if (!this.config.fbAppId) throw new Error('Missing Europa Park Firebase App ID');\n    if (!this.config.fbProjectId) throw new Error('Missing Europa Park Firebase Project ID');\n    if (!this.config.apiBase) throw new Error('Missing Europa Park API Base');\n    if (!this.config.encKey) throw new Error('Missing Europa Park Encryption Key');\n    if (!this.config.encIV) throw new Error('Missing Europa Park Encryption IV');\n    if (!this.config.authURL) throw new Error('Missing Europa Park Token URL');\n\n    this.http.injectForDomain({\n      hostname: new URL(this.config.authURL).hostname,\n    }, async (method, url, data, options) => {\n      options.headers['user-agent'] = `EuropaParkApp/${this.config.appVersion} (Android)`;\n    });\n\n    this.http.injectForDomain({\n      hostname: new URL(this.config.apiBase).hostname,\n    }, async (method, url, data, options) => {\n      options.headers['user-agent'] = `EuropaParkApp/${this.config.appVersion} (Android)`;\n\n      const jwtToken = await this.getToken();\n      if (jwtToken === undefined) {\n        // refetch Firebase settings and try again\n        await this.cache.set('auth', undefined, -1);\n        const jwtTokenRetry = await this.getToken();\n        options.headers['jwtauthorization'] = `Bearer ${jwtTokenRetry}`;\n      } else {\n        options.headers['jwtauthorization'] = `Bearer ${jwtToken}`;\n      }\n    });\n\n    this.http.injectForDomainResponse({\n      hostname: new URL(this.config.apiBase).hostname,\n    }, async (response) => {\n      // if error code is unauthorised, clear out our JWT token\n      if (response.statusCode === 401) {\n        // wipe any existing token\n        await this.cache.set('access_token', undefined, -1);\n        // this will be regenerated next time injectForDomain is run\n        return undefined;\n      }\n\n      return response;\n    });\n\n    this.bf = new Blowfish(this.config.encKey, Blowfish.MODE.CBC, Blowfish.PADDING.PKCS5);\n    this.bf.setIv(this.config.encIV);\n  }\n\n  /**\n   * Get or generate a Firebase device ID\n   */\n  async getFirebaseID() {\n    return await this.cache.wrap('fid', async () => {\n      try {\n        const fidByteArray = crypto.randomBytes(17).toJSON().data;\n        fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\n        const b64String = Buffer.from(String.fromCharCode(...fidByteArray))\n          .toString('base64')\n          .replace(/\\+/g, '-')\n          .replace(/\\//g, '_');\n        const fid = b64String.substr(0, 22);\n        return /^[cdef][\\w-]{21}$/.test(fid) ? fid : '';\n      } catch (e) {\n        this.emit('error', e);\n        console.log(e);\n        return '';\n      }\n    }, 1000 * 60 * 60 * 24 * 8); // 8days\n  }\n\n  /**\n   * Get Europa Park config keys\n   */\n  async getConfig() {\n    return await this.cache.wrap('auth', async () => {\n      const fid = await this.getFirebaseID();\n\n      const resp = await this.http(\n        'POST',\n        `https://firebaseremoteconfig.googleapis.com/v1/projects/${this.config.fbProjectId}/namespaces/firebase:fetch`,\n        {\n          'appInstanceId': fid,\n          'appId': this.config.fbAppId,\n          'packageName': 'com.EuropaParkMackKG.EPGuide',\n          'languageCode': 'en_GB',\n        }, {\n        headers: {\n          'X-Goog-Api-Key': this.config.fbApiKey,\n        },\n      },\n      );\n\n      const decrypt = (str) => {\n        return this.bf.decode(Buffer.from(str, 'base64'), Blowfish.TYPE.STRING);\n      };\n\n      const ret = {};\n      Object.keys(resp.body.entries).forEach((key) => {\n        ret[key] = decrypt(resp.body.entries[key]);\n      });\n      return ret;\n    }, 1000 * 60 * 60 * 6); // 6 hours\n  }\n\n  /**\n   * Get our JWT Token\n   */\n  async getToken() {\n    let expiresIn = 1000 * 60 * 60 * 24; // default: 1 day\n    return await this.cache.wrap('access_token', async () => {\n      const config = await this.getConfig();\n      const resp = await this.http(\n        'POST',\n        this.config.authURL,\n        {\n          client_id: config[this.config.userKey],\n          client_secret: config[this.config.passKey],\n          grant_type: 'client_credentials',\n        },\n        {\n          json: true,\n        },\n      );\n\n      if (!resp || !resp.body) {\n        throw new Error('Failed to fetch credentials for Europa API');\n      }\n\n      expiresIn = resp.body.expires_in * 1000;\n      const token = resp.body.access_token;\n      return token;\n    }, () => {\n      return expiresIn;\n    });\n  }\n\n  /**\n   * Get static data for all park entities\n   */\n  async getParkData() {\n    return await this.cache.wrap('poi', async () => {\n      // get the last checksum we received\n      const checksum = (await this.cache.get('poi_checksum')) || 0;\n      const data = await this.http(\n        'GET',\n        `${this.config.apiBase}/api/v1/latest/en/live/${checksum}`,\n        undefined,\n        {\n          json: true,\n          ignoreErrors: true, // we want 404 errors\n        },\n      );\n\n      if (data.body?.error?.code === 404 && checksum > 0) {\n        // return old data, hasn't changed\n        return await this.cache.get('poi_store');\n      }\n\n      if (!data.body.package) return undefined;\n\n      // collapse sub fields into one array\n      const entities = [];\n      Object.keys(data.body.package.data).forEach((key) => {\n        data.body.package.data[key].forEach((x) => {\n          entities.push({\n            ...x,\n            entityType: key,\n          });\n        });\n      });\n\n      // store this data indefinitely, we'll only override it if the checksum changes\n      await this.cache.set('poi_store', entities, Number.MAX_SAFE_INTEGER);\n      await this.cache.set('poi_checksum', data.body.package.checksum);\n\n      return entities;\n    }, 1000 * 60 * 60 * 2); // check every 2 hours for updates\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _init() {\n\n  }\n\n  /**\n   * Get waiting time data from API\n   */\n  async getWaitingTimes() {\n    return this.cache.wrap('waittingtimes', async () => {\n      return (await this.http('GET', `${this.config.apiBase}/api/v1/waitingtimes`)).body;\n    }, 1000 * 60);\n  }\n\n  /**\n   * Get Europa Park calendar data\n   */\n  async getCalendar() {\n    return this.cache.wrap('seasons', async () => {\n      return (await this.http('GET', `${this.config.apiBase}/api/v1/seasons/en`)).body;\n    }, 1000 * 60 * 60 * 6);\n  }\n\n  /**\n   * Get Europa Park show times\n   */\n  async getShowTimes() {\n    return this.cache.wrap('showtimes', async () => {\n      // TODO - other languages? does this only include English performances?\n      return (await this.http('GET', `${this.config.apiBase}/api/v1/showtimes/en/live`)).body;\n    }, 1000 * 60 * 60 * 6);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getEntities() {\n    const poiData = await this.getParkData();\n\n    const ret = poiData.map((poi) => {\n      if (!poi.name) return undefined;\n\n      // which types do we want to return?\n      if (!poiEntityTypes.includes(poi.entityType)) return undefined;\n\n      // filter by subtypes, if we have any\n      const subTypes = subtypesToAllow[poi.entityType];\n      if (subTypes) {\n        if (!subTypes.includes(poi.type)) return undefined;\n      }\n\n      // TODO - ignore entities that are no longer valid\n      //  if (poi.validTo !== null) \n\n      // \"queueing\" entries are pretend entities for virtual queues\n      if (poi.queueing) return undefined;\n\n      // ignore queue map pointers\n      if (poi.name.indexOf('Queue - ') === 0) return undefined;\n\n      delete poi.versions;\n\n      // check for virtual queue\n      const nameLower = poi.name.toLowerCase();\n      const vQueueData = poiData.find((x) => {\n        return x.queueing && x.name.toLowerCase().indexOf(nameLower) > 0;\n      });\n      // virtual queue waitingtimes data\n      // code === vQueueData.code\n      // time can only ever be between 0-90, anything >90 is a special code\n      // if time == 90, wait time is reported as 90+ in-app\n      // time == 91, virtual queue is open\n      // time == 999, down\n      // time == 222, closed refurb\n      // time == 333, closed\n      // time == 444, closed becaue weather\n      // time == 555, closed because ice\n      // time == 666, virtual queue is \"temporarily full\"\n      // time == 777, virtual queue is completely full\n      // startAt/endAt - current virtual queue window\n\n      const tags = [];\n\n      tags.push({\n        key: 'location',\n        type: tagType.location,\n        value: {\n          longitude: poi.longitude,\n          latitude: poi.latitude,\n        },\n      });\n\n      if (poi.minHeight) {\n        tags.push({\n          key: 'minimumHeight',\n          type: tagType.minimumHeight,\n          value: {\n            unit: 'cm',\n            height: poi.minHeight,\n          },\n        });\n      }\n\n      if (poi.maxHeight) {\n        tags.push({\n          key: 'maximumHeight',\n          type: tagType.maximumHeight,\n          value: {\n            unit: 'cm',\n            height: poi.maxHeight,\n          },\n        });\n      }\n\n      return {\n        id: `${poi.entityType}_${poi.id}`,\n        name: poi.name,\n        type: entityTypeToAttractionType[poi.entityType] == entityType.attraction ? attractionType.ride : undefined,\n        entityType: entityTypeToAttractionType[poi.entityType] || entityType.attraction,\n        tags,\n        _src: {\n          ...poi,\n          vQueue: vQueueData,\n        },\n      };\n    }).filter((x) => x !== undefined);\n\n    return ret;\n  }\n}\n\nexport default DatabaseEuropaPark;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/europa/europaparkdb.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 281,
    "kind": "variable",
    "name": "poiEntityTypes",
    "memberof": "lib/parks/europa/europaparkdb.js",
    "static": true,
    "longname": "lib/parks/europa/europaparkdb.js~poiEntityTypes",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/europa/europaparkdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 282,
    "kind": "variable",
    "name": "entityTypeToAttractionType",
    "memberof": "lib/parks/europa/europaparkdb.js",
    "static": true,
    "longname": "lib/parks/europa/europaparkdb.js~entityTypeToAttractionType",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/europa/europaparkdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "{\"shows\": *, \"pois\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 283,
    "kind": "variable",
    "name": "subtypesToAllow",
    "memberof": "lib/parks/europa/europaparkdb.js",
    "static": true,
    "longname": "lib/parks/europa/europaparkdb.js~subtypesToAllow",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/europa/europaparkdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "{\"pois\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 284,
    "kind": "class",
    "name": "DatabaseEuropaPark",
    "memberof": "lib/parks/europa/europaparkdb.js",
    "static": true,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/europa/europaparkdb.js",
    "importStyle": "{DatabaseEuropaPark}",
    "description": "Europa Park Database Class",
    "lineNumber": 26,
    "interface": false,
    "extends": [
      "lib/parks/database.js~Database"
    ]
  },
  {
    "__docId__": 285,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 286,
    "kind": "member",
    "name": "bf",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#bf",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 287,
    "kind": "method",
    "name": "getFirebaseID",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getFirebaseID",
    "access": "public",
    "description": "Get or generate a Firebase device ID",
    "lineNumber": 98,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 288,
    "kind": "method",
    "name": "getConfig",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getConfig",
    "access": "public",
    "description": "Get Europa Park config keys",
    "lineNumber": 120,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "getToken",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getToken",
    "access": "public",
    "description": "Get our JWT Token",
    "lineNumber": 154,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 290,
    "kind": "method",
    "name": "getParkData",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getParkData",
    "access": "public",
    "description": "Get static data for all park entities",
    "lineNumber": 186,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#_init",
    "access": "private",
    "description": "",
    "lineNumber": 229,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "getWaitingTimes",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getWaitingTimes",
    "access": "public",
    "description": "Get waiting time data from API",
    "lineNumber": 236,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "method",
    "name": "getCalendar",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getCalendar",
    "access": "public",
    "description": "Get Europa Park calendar data",
    "lineNumber": 245,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 294,
    "kind": "method",
    "name": "getShowTimes",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#getShowTimes",
    "access": "public",
    "description": "Get Europa Park show times",
    "lineNumber": 254,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "method",
    "name": "_getEntities",
    "memberof": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/europa/europaparkdb.js~DatabaseEuropaPark#_getEntities",
    "access": "private",
    "description": "",
    "lineNumber": 264,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "file",
    "name": "lib/parks/herschend/herschendparks.js",
    "content": "import {Destination} from '../destination.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\nimport moment from 'moment-timezone';\n\nexport class HerschendDestination extends Destination {\n  constructor(options = {}) {\n    options.timezone = options.timezone || 'America/New_York';\n\n    // we have multiple Herschend parks, so we need to set the resortId\n    options.destinationId = options.destinationId || '';\n    // slug to use for this destination\n    options.destinationSlug = options.destinationSlug || '';\n\n    // base URL for live data API\n    options.apiBase = options.apiBase || '';\n\n    // base URL for the CRM API\n    options.crmBaseURL = options.crmBaseURL || '';\n    // auth credentials for accessing the CRM API\n    options.crmAuth = options.crmAuth || '';\n    // guid for this destination's calendar and POI data\n    options.crmGUID = options.crmGUID || '';\n    // categories for POI data\n    options.crmAttractionsId = options.crmAttractionsId || '';\n    options.crmDiningId = options.crmDiningId || '';\n    options.crmShowId = options.crmShowId || '';\n\n    // allow configuring all herschend parks with the HERSCHEND prefix env var\n    options.configPrefixes = options.configPrefixes || ['HERSCHEND'];\n\n    options.cacheVersion = options.cacheVersion || '1';\n\n    super(options);\n\n    if (!this.config.destinationId) throw new Error('Missing destinationId');\n    if (!this.config.destinationSlug) throw new Error('Missing destinationSlug');\n    if (!this.config.apiBase) throw new Error('HerschendDestination requires an apiBase');\n    if (!this.config.crmBaseURL) throw new Error('Missing crmBaseURL');\n    if (!this.config.crmAuth) throw new Error('Missing crmAuth');\n    if (!this.config.crmGUID) throw new Error('Missing crmGUID');\n    if (!this.config.crmAttractionsId) throw new Error('Missing crmAttractionsId');\n    if (!this.config.crmDiningId) throw new Error('Missing crmDiningId');\n    if (!this.config.crmShowId) throw new Error('Missing crmShowId');\n\n    this.config.parkId = this.config.parkId || `${this.config.destinationSlug}park`;\n\n    // inject into CRM API requests\n    const crmURLHostname = new URL(this.config.crmBaseURL).hostname;\n    this.http.injectForDomain({\n      hostname: crmURLHostname,\n    }, async (method, url, data, options) => {\n      // add our auth credentials to the request\n      options.headers = {\n        ...options.headers,\n        authorization: `Basic ${this.config.crmAuth}`,\n      };\n\n      options.json = true;\n    });\n  }\n\n  /**\n   * Get raw wait times data\n   */\n  async getWaitTimes() {\n    '@cache|1'; // cache for 1 minute\n    const resp = await this.http(`${this.config.apiBase}waitTimes/${this.config.destinationId}`);\n    return resp.body;\n  }\n\n  /**\n   * Get raw food wait times data\n   */\n  async getFoodWaitTimes() {\n    '@cache|1'; // cache for 1 minute\n    const resp = await this.http(`${this.config.apiBase}foodServiceWaitTimes/${this.config.destinationId}`);\n    return resp.body;\n  }\n\n  /**\n   * Get raw train times data\n   */\n  async getTrainTimes() {\n    '@cache|1'; // cache for 1 minute\n    const resp = await this.http(`${this.config.apiBase}trainServiceSchedules/${this.config.destinationId}`);\n    return resp.body;\n  }\n\n  /**\n   * Get raw attraction POI data\n   */\n  async getPOIData() {\n    // cache for 12 hours\n    '@cache|720';\n    const resp = await this.http(`${this.config.crmBaseURL}api/park/activitiesbypark/${this.config.crmGUID}`);\n    return resp.body;\n  }\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data \n   * @returns {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    if (data) {\n      entity._tags = [];\n\n      if (data.id) {\n        entity._id = data.id;\n      }\n\n      // geo location\n      if (data.mapLocation && data.mapLocation.latitude && data.mapLocation.longitude) {\n        if (!entity.location) entity.location = {};\n        entity.location.longitude = Number(data.mapLocation.longitude);\n        entity.location.latitude = Number(data.mapLocation.latitude);\n      }\n\n      if (data.longitudeForDirections) {\n        if (!entity.location) entity.location = {};\n        entity.location.longitude = Number(data.longitudeForDirections);\n      }\n      if (data.latitudeForDirections) {\n        if (!entity.location) entity.location = {};\n        entity.location.latitude = Number(data.latitudeForDirections);\n      }\n\n      // entity name\n      if (data.title) {\n        entity.name = data.title;\n      }\n\n      if (data.heightRequirement && data.heightRequirement.minHeight > 0) {\n        // convert from inches to cm\n        const minHeightInCm = Math.floor(Number(data.heightRequirement.minHeight) * 2.54);\n\n        entity._tags.push({\n          id: 'minimumHeight',\n          value: minHeightInCm,\n        });\n      }\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    const doc = {};\n    return {\n      ...this.buildBaseEntityObject(doc),\n      _id: this.config.destinationSlug,\n      slug: this.config.destinationSlug,\n      name: this.config.name,\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    return [\n      {\n        ...this.buildBaseEntityObject(null),\n        _id: this.config.parkId,\n        _destinationId: this.config.destinationSlug,\n        _parentId: this.config.destinationSlug,\n        name: this.config.name,\n        slug: this.config.parkId,\n        entityType: entityType.park,\n      }\n    ];\n  }\n\n  /**\n   * Helper function to filter POI data for a chosen category GUID\n   * @param {string} category \n   * @returns \n   */\n  async getPOIForCategory(category, filterSeasonal = true) {\n    const poiData = await this.getPOIData();\n\n    const now = this.getTimeNowMoment();\n\n    return poiData.activities.filter((x) => {\n      if (x.activityListId !== category) return false;\n\n      // check seasonality\n      if (filterSeasonal) {\n        if (x.seasonalStartDate) {\n          const startDate = moment(x.seasonalStartDate);\n          if (startDate.isAfter(now)) return false;\n        }\n        if (x.seasonalEndDate) {\n          const endDate = moment(x.seasonalEndDate);\n          if (endDate.isBefore(now)) return false;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    const attrs = await this.getPOIForCategory(this.config.crmAttractionsId, false);\n\n    return attrs.map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        entityType: entityType.attraction,\n        attractionType: attractionType.ride,\n        _destinationId: this.config.destinationSlug,\n        _parkId: this.config.parkId,\n        _parentId: this.config.parkId,\n      };\n    });\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    return [];\n\n    const attrs = await this.getPOIForCategory(this.config.crmShowId, true);\n\n    return attrs.map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        entityType: entityType.show,\n        _destinationId: this.config.destinationSlug,\n        _parkId: this.config.parkId,\n        _parentId: this.config.parkId,\n      };\n    });\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    const attrs = await this.getPOIForCategory(this.config.crmDiningId, false);\n\n    return attrs.map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        entityType: entityType.restaurant,\n        _destinationId: this.config.destinationSlug,\n        _parkId: this.config.parkId,\n        _parentId: this.config.parkId,\n      };\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    // get all the data we need\n    const liveData = await this.getWaitTimes();\n    const poiData = await this.getPOIData();\n\n    return liveData.map((x) => {\n      // find matching poiData for this live data\n      const rideId = `${x.rideId}`;\n      const poi = poiData.activities.find((y) => `${y.rideWaitTimeRideId}` === rideId);\n      if (!poi) return null;\n\n      const data = {\n        _id: poi.id,\n        status: statusType.closed,\n        queue: {},\n      };\n\n      if (x.operationStatus === 'CLOSED' || x.operationStatus === 'UNKNOWN') {\n        data.status = statusType.closed;\n      } else if (x.operationStatus === 'TEMPORARILY CLOSED') {\n        data.status = statusType.down;\n      } else if (x.waitTimeDisplay.includes('UNDER')) {\n        data.status = statusType.operating;\n        // Wait time is not defined if text says \"Under x minutes\" - we'll set the ride time to x\n        try {\n          data.queue[queueType.standBy] = {\n            waitTime: parseInt(x.waitTimeDisplay.split(' ')[1], 10),\n          };\n        } catch (e) {\n          // fallback if formatting fails\n          data.queue[queueType.standBy] = {\n            waitTime: parseInt(x.waitTime, 10) || 0,\n          };\n        }\n      } else if (x.waitTime) {\n        data.status = statusType.operating;\n        data.queue[queueType.standBy] = {\n          waitTime: parseInt(x.waitTime, 10) || 0,\n        };\n      }\n\n      return data;\n    }).filter((x) => !!x);\n  }\n\n  /**\n   * Fetch startdate and the following 4 days (total 5 days) of schedule data\n   * @param {string} startDate \n   * @returns \n   */\n  async fetchFiveDates(startDate) {\n    // cache for 12 hours\n    '@cache|720';\n    const resp = await this.http(`${this.config.crmBaseURL}api/park/dailyschedulebytime?parkids=${this.config.crmGUID}&date=${startDate}&days=5`);\n    return resp.body;\n  }\n\n  async fetchScheduleData(days = 90) {\n    // cache for 12 hours\n    '@cache|720';\n    const now = this.getTimeNowMoment();\n    const endDate = now.clone().add(days, 'days');\n    const datesToFetch = [];\n    while (now.isSameOrBefore(endDate, 'day')) {\n      datesToFetch.push(now.format('YYYY-MM-DD'));\n      now.add(5, 'day');\n    }\n\n    // fetch each date block\n    const data = [];\n    for (let i = 0; i < datesToFetch.length; i++) {\n      const resp = await this.fetchFiveDates(datesToFetch[i]);\n      data.push(...resp);\n    }\n\n    return data;\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    const parkHours = await this.fetchScheduleData();\n\n    return [\n      {\n        _id: this.config.parkId,\n        schedule: parkHours.map((x) => {\n          // step 1: extract park hours from schedule data\n          if (x?.parkHours) {\n            return x.parkHours.find((y) => {\n              // step 2: filter out park hours that don't match our park ID\n              return y.cmsKey === this.config.crmGUID;\n            });\n          }\n          return null;\n        }).filter((x) => {\n          // step 3: filter out nulls\n          return !!x && !!x?.from && !!x?.to;\n        }).map((x) => {\n          // step 4: convert to our format\n          const from = moment.tz(x.from, this.config.timezone);\n          const to = moment.tz(x.to, this.config.timezone);\n          return {\n            date: from.format('YYYY-MM-DD'),\n            type: \"OPERATING\",\n            openingTime: from.format(),\n            closingTime: to.format(),\n          };\n        }),\n      }\n    ];\n  }\n}\n\nexport class Dollywood extends HerschendDestination {\n  constructor(options = {}) {\n    options.timezone = \"America/New_York\";\n    options.name = \"Dollywood\";\n    options.destinationId = \"1\";\n    options.destinationSlug = \"dollywood\";\n    options.crmBaseURL = \"https://www.dollywood.com/\";\n\n    options.crmGUID = \"e98c4ecb-550e-4f14-af2c-13f3cab1abf5\";\n    options.crmAttractionsId = \"96822fdb-77e5-4054-9f37-70f379f997d8\";\n    options.crmDiningId = \"9d3de6ae-ebb1-4cb8-9423-bee864daef3c\";\n    options.crmShowId = \"b9acfd27-0545-4bb2-a6e8-072fda3b06dd\";\n\n    super(options);\n  }\n}\n\nexport class SilverDollarCity extends HerschendDestination {\n  constructor(options = {}) {\n    options.timezone = \"America/Chicago\";\n    options.name = \"Silver Dollar City\";\n    options.destinationId = \"2\";\n    options.destinationSlug = \"silverdollarcity\";\n    options.crmBaseURL = \"https://prodcms.silverdollarcity.com/\";\n    \n    options.crmGUID = \"fa775492-947e-4798-b9f4-3e99c419dbb5\";\n    options.crmAttractionsId = \"6cbebd47-facc-4c26-b1b2-4e0da4de0e6e\";\n    options.crmDiningId = \"31b3a1c6-93cc-4b93-b84e-bf512afe770c\";\n    options.crmShowId = \"58a4e3a3-c889-4130-93d1-5ba802442444\";\n\n    super(options);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/herschend/herschendparks.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 297,
    "kind": "class",
    "name": "HerschendDestination",
    "memberof": "lib/parks/herschend/herschendparks.js",
    "static": true,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/herschend/herschendparks.js",
    "importStyle": "{HerschendDestination}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 298,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true
  },
  {
    "__docId__": 299,
    "kind": "method",
    "name": "getWaitTimes",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#getWaitTimes",
    "access": "public",
    "description": "Get raw wait times data",
    "lineNumber": 65,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "method",
    "name": "getFoodWaitTimes",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#getFoodWaitTimes",
    "access": "public",
    "description": "Get raw food wait times data",
    "lineNumber": 74,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "method",
    "name": "getTrainTimes",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#getTrainTimes",
    "access": "public",
    "description": "Get raw train times data",
    "lineNumber": 83,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "method",
    "name": "getPOIData",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#getPOIData",
    "access": "public",
    "description": "Get raw attraction POI data",
    "lineNumber": 92,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 303,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 105,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 304,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 153,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": *, \"slug\": *, \"name\": *, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 167,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "getPOIForCategory",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#getPOIForCategory",
    "access": "public",
    "description": "Helper function to filter POI data for a chosen category GUID",
    "lineNumber": 186,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "category",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 213,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 231,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 250,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 267,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 311,
    "kind": "method",
    "name": "fetchFiveDates",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#fetchFiveDates",
    "access": "public",
    "description": "Fetch startdate and the following 4 days (total 5 days) of schedule data",
    "lineNumber": 317,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "startDate",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 312,
    "kind": "method",
    "name": "fetchScheduleData",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#fetchScheduleData",
    "access": "public",
    "description": null,
    "lineNumber": 324,
    "undocument": true,
    "params": [
      {
        "name": "days",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 90,
        "defaultValue": "90"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/herschend/herschendparks.js~HerschendDestination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~HerschendDestination#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 350,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 314,
    "kind": "class",
    "name": "Dollywood",
    "memberof": "lib/parks/herschend/herschendparks.js",
    "static": true,
    "longname": "lib/parks/herschend/herschendparks.js~Dollywood",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/herschend/herschendparks.js",
    "importStyle": "{Dollywood}",
    "description": null,
    "lineNumber": 384,
    "undocument": true,
    "interface": false,
    "extends": [
      "HerschendDestination"
    ]
  },
  {
    "__docId__": 315,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/herschend/herschendparks.js~Dollywood",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~Dollywood#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 385,
    "undocument": true
  },
  {
    "__docId__": 316,
    "kind": "class",
    "name": "SilverDollarCity",
    "memberof": "lib/parks/herschend/herschendparks.js",
    "static": true,
    "longname": "lib/parks/herschend/herschendparks.js~SilverDollarCity",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/herschend/herschendparks.js",
    "importStyle": "{SilverDollarCity}",
    "description": null,
    "lineNumber": 401,
    "undocument": true,
    "interface": false,
    "extends": [
      "HerschendDestination"
    ]
  },
  {
    "__docId__": 317,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/herschend/herschendparks.js~SilverDollarCity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/herschend/herschendparks.js~SilverDollarCity#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 402,
    "undocument": true
  },
  {
    "__docId__": 318,
    "kind": "file",
    "name": "lib/parks/hershey/hersheypark.js",
    "content": "import {Destination} from '../destination.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\nimport moment from 'moment';\n\nexport class Hersheypark extends Destination {\n  constructor(options = {}) {\n    options.timezone = options.timezone || 'America/New_York';\n    \n    options.apiKey = options.apiKey || '';\n    options.baseURL = options.baseURL || 'https://hpapp.hersheypa.com';\n    \n    super(options);\n\n    if (!this.config.apiKey) throw new Error('Missing apiKey');\n\n    // hook into the base API URL to add our api key\n    const baseURLHostname = new URL(this.config.baseURL).hostname;\n    this.http.injectForDomain({\n      hostname: baseURLHostname,\n    }, async (method, url, data, options) => {\n      options.headers = {\n        ...options.headers,\n        'x-api-key': this.config.apiKey,\n      };\n    });\n  }\n\n  /**\n   * Fetch the POI data for this destination\n   * @returns \n   */\n  async fetchPOIData() {\n    // cache for 1 day\n    '@cache|1d';\n    // fetch the park data from the API\n    const response = await this.http.get(`${this.config.baseURL}/v2/index`);\n    // return the park data\n    return response.body;\n  }\n\n  /**\n   * Fetch the live data for all entities in this destination\n   */\n  async fetchStatusData() {\n    '@cache|2m'; // cache for 2 minutes\n    const response = await this.http.get(`${this.config.baseURL}/v2/status`);\n    return response.body;\n  }\n\n  /**\n   * Get the main park POI data\n   */\n  async getParkPOIData() {\n    '@cache|6h'; // cache for 6 hours\n    const poi = await this.fetchPOIData();\n\n    const parkData = poi.explore.find((x) => x.isHersheyPark);\n    if (!parkData) {\n      throw new Error('Missing park data');\n    }\n\n    return parkData;\n  }\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data \n   * @returns {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    if (data) {\n      entity.name = data.name || undefined;\n\n      if (data.latitude && data.longitude) {\n        entity.location = {\n          latitude: data.latitude,\n          longitude: data.longitude,\n        };\n      }\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    return {\n      ...this.buildBaseEntityObject(null),\n      _id: 'hersheypark',\n      slug: 'hersheypark',\n      name: 'Hersheypark',\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    const parkData = await this.getParkPOIData();\n\n    return [\n      {\n        ...this.buildBaseEntityObject(parkData),\n        _id: 'hersheyparkthemepark',\n        _destinationId: 'hersheypark',\n        _parentId: 'hersheypark',\n        slug: 'hersheyparkthemepark',\n        entityType: entityType.park,\n      }\n    ];\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    const poi = await this.fetchPOIData();\n    const entities = [];\n    for(const ride of poi.rides) {\n      entities.push({\n        ...this.buildBaseEntityObject(ride),\n        _id: `rides_${ride.id}`,\n        _destinationId: 'hersheypark',\n        _parentId: 'hersheyparkthemepark',\n        _parkId: 'hersheyparkthemepark',\n        entityType: entityType.attraction,\n        attractionType: attractionType.ride,\n      });\n    }\n    return entities;\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    return [];\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    return [];\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const liveData = await this.fetchStatusData();\n\n    return liveData.map((x) => {\n      // only support live data for rides, update this to add support for other entities\n      if (x.type !== 'rides') {\n        return null;\n      }\n\n      const data = {\n        _id: `${x.type}_${x.id}`,\n        status: statusType.closed,\n      };\n\n      // statuses:\n      //  3: park closed\n      //  2: <unknown> (assumed down)\n      //  1: open\n\n      if (x.status === 2) {\n        data.status = statusType.down;\n      } else if (x.status === 1) {\n        data.status = statusType.operating;\n\n        if (data.wait !== null && data.wait !== undefined) {\n          data.queue = {\n            [queueType.standBy]: {\n              waitTime: data.wait,\n            },\n          };\n        }\n      }\n\n      return data;\n    }).filter((x) => !!x);\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    // find park ID so we can grab schedule from exploreHours\n    const parkData = await this.getParkPOIData();\n    const parkId = parkData.id;\n\n    const allPOIData = await this.fetchPOIData();\n\n    const schedule = [];\n    for(const date in allPOIData.exploreHours) {\n      const hours = allPOIData.exploreHours[date];\n      const parkHours = hours[parkId];\n      if (!parkHours) {\n        continue;\n      }\n\n      // parkHours is a string in the format: \"10:00 AM - 10:00 PM\"\n      const [start, end] = parkHours.split(' - ');\n      if (!start || !end) {\n        continue;\n      }\n\n      const startTime = moment.tz(`${date} ${start}`, 'YYYY-MM-DD h:mma', this.config.timezone);\n      const endTime = moment.tz(`${date} ${end}`, 'YYYY-MM-DD h:mma', this.config.timezone);\n\n      schedule.push({\n        date: date,\n        openingTime: startTime.format(),\n        closingTime: endTime.format(),\n        type: 'OPERATING',\n      });\n    }\n\n    return [\n      {\n        _id: 'hersheyparkthemepark',\n        schedule,\n      }\n    ];\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/hershey/hersheypark.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 319,
    "kind": "class",
    "name": "Hersheypark",
    "memberof": "lib/parks/hershey/hersheypark.js",
    "static": true,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/hershey/hersheypark.js",
    "importStyle": "{Hersheypark}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 320,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "fetchPOIData",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#fetchPOIData",
    "access": "public",
    "description": "Fetch the POI data for this destination",
    "lineNumber": 32,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 322,
    "kind": "method",
    "name": "fetchStatusData",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#fetchStatusData",
    "access": "public",
    "description": "Fetch the live data for all entities in this destination",
    "lineNumber": 44,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 323,
    "kind": "method",
    "name": "getParkPOIData",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#getParkPOIData",
    "access": "public",
    "description": "Get the main park POI data",
    "lineNumber": 53,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 71,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 325,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 91,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": string, \"slug\": string, \"name\": string, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 104,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 122,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 328,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 142,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 329,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 149,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 156,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/hershey/hersheypark.js~Hersheypark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/hershey/hersheypark.js~Hersheypark#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 198,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 332,
    "kind": "file",
    "name": "lib/parks/http.js",
    "content": "import HarWriter from '../har.js';\nimport randomUseragent from 'random-useragent';\nimport moment from 'moment-timezone';\nimport sift from 'sift';\nimport needle from 'needle';\nimport promiseRetry from 'promise-retry';\n\nlet overrideFunc = null;\n/**\n * Set an override function to use for HTTP requests\n * Accepts (method, URL, data, options)\n * @param {function} fn\n */\nexport function setOverrideFunction(fn) {\n  overrideFunc = fn;\n}\n\n/**\n * Generate a random Android user agent for making network requests\n * @return {string}\n */\nexport function generateRandomAndroidUseragent() {\n  return randomUseragent.getRandom((ua) => {\n    return (ua.osName === 'Android');\n  });\n}\n\n// start our har writer (if debugging)\nconst harWriter = process.env['THEMEPARKS_HAR'] ?\n  new HarWriter({filename: `${process.env['THEMEPARKS_HAR']}.har`}) :\n  null;\n\n/**\n   * Write a HTTP response to HAR file for debugging\n   * @param {*} method\n   * @param {*} url\n   * @param {*} data\n   * @param {*} options\n   * @param {*} resp\n   * @param {*} startTime\n   * @param {*} timeTaken\n   * @private\n   */\nasync function writeToHAR(method, url, data, options, resp, startTime, timeTaken) {\n  const objToArr = (obj) => {\n    return Object.keys(obj).map((header) => {\n      return {name: header, value: obj[header].toString()};\n    });\n  };\n\n  const entry = {\n    startedDateTime: startTime,\n    time: timeTaken,\n    request: {\n      method: method,\n      url: url,\n      httpVersion: `HTTP/${resp.httpVersion}`, // this is actually the response, TODO\n      cookies: [],\n      headers: objToArr(options.headers), // not the actual headers needle sends - TODO, how to get these?\n      queryString: method === 'GET' ? objToArr(data) : [], // TODO - parse from needle's .path\n      postData: {\n        mimeType: options.json ? 'application/json' : (options.headers['content-type'] || ''),\n        params: method !== 'GET' ? [] : [],\n        text: '',\n      },\n      headersSize: -1,\n      bodySize: -1,\n    },\n    response: {\n      status: resp.statusCode,\n      statusText: resp.statusMessage,\n      httpVersion: `HTTP/${resp.httpVersion}`,\n      cookies: [],\n      headers: objToArr(resp.headers),\n      content: {\n        size: resp.raw.length || -1,\n        mimeType: resp.headers['content-type'],\n        text: resp.raw.toString('base64'),\n        encoding: 'base64',\n      },\n      redirectURL: '',\n      headersSize: -1,\n      bodySize: -1,\n    },\n    cache: {},\n    timings: {\n      send: -1,\n      wait: -1,\n      receive: -1,\n    },\n  };\n  await harWriter.recordEntry(entry);\n}\n\n/**\n * HTTP helper with injection\n * @return {*}\n */\nexport const HTTP = (function() {\n  this._httpInjections = [];\n  this._httpResponseInjections = [];\n  this.useragent = generateRandomAndroidUseragent();\n\n  /**\n   * Helper function to make an HTTP request for this park\n   * Parks can automatically add in authentication headers etc. to requests sent to this function\n   * @param {string} method HTTP method to use (GET,POST,DELETE, etc)\n   * @param {string} url URL to request\n   * @param {object} [data] data to send. Will become querystring for GET, body for POST\n   * @param {object} [options = {}] Object containing needle-compatible HTTP options\n   */\n  const mainFunction = async (method, url, data, options = {}) => {\n    // default to GET if we only have one argument\n    if (url === undefined && data === undefined) {\n      url = method;\n      method = 'GET';\n    }\n\n    // always have a headers array\n    if (!options.headers) {\n      options.headers = {};\n    }\n\n    // default to accepting compressed data\n    options.compressed = options.compressed === undefined ? true : options.compressed;\n\n    // 10 seconds default timeout opening response\n    options.response_timeout = options.response_timeout || 10000;\n    // 30 seconds default timeout for reading data (for large data streams)\n    options.read_timeout = options.read_timeout || 30000;\n\n    // inject custom standard user agent (if we have one)\n    //  do this before any custom injections so parks can optionally override this for each domain\n    if (this.useragent && !options.headers['user-agent']) {\n      options.headers['user-agent'] = this.useragent;\n    }\n\n    if (!options.headers['user-agent'] && process.env.DEFAULT_USER_AGENT) {\n      // if no user-agent supplied, set a default one from the env\n      options.headers['user-agent'] = process.env.DEFAULT_USER_AGENT;\n    }\n\n    // check any hostname injections we have setup\n    const urlObj = new URL(url);\n    const urlFilter = {\n      protocol: urlObj.protocol,\n      host: urlObj.host,\n      hostname: urlObj.hostname,\n      pathname: urlObj.pathname,\n      search: urlObj.search,\n      hash: urlObj.hash,\n    };\n\n    // wrap our needle call in a retry\n    return await promiseRetry({\n      retries: options.retries === undefined ? 3 : options.retries,\n    }, async (retryFn) => {\n      // make sure we run initial injections on each retry\n      for (let injectionIDX = 0; injectionIDX < this._httpInjections.length; injectionIDX++) {\n        const injection = this._httpInjections[injectionIDX];\n\n        // check if the domain matches\n        if (injection.filter(urlFilter)) {\n          const injectionResp = await injection.func(method, url, data, options);\n          if (injectionResp) {\n            url = injectionResp.url || url;\n            method = injectionResp.method || method;\n            data = injectionResp.data || data;\n            options = injectionResp.options || options;\n          }\n        }\n      }\n\n      // record some stats for the optional HAR Writer\n      const startMs = +new Date();\n      const startTime = moment(startMs).toISOString();\n\n      // optionally override the HTTP function to use\n      const httpFunc = overrideFunc ? overrideFunc : needle;\n\n      return httpFunc(method, url, data, options).then(async (resp) => {\n        // intercept response to write to our .har file\n        if (harWriter) {\n          await writeToHAR(method, url, data, options, resp, startTime, (+new Date()) - startMs);\n        }\n\n        // call any response injections\n        for (let injectionIDX = 0; injectionIDX < this._httpResponseInjections.length; injectionIDX++) {\n          const injection = this._httpResponseInjections[injectionIDX];\n\n          // check if the domain matches\n          // (reuse urlFilter from the incoming injections)\n          if (injection.filter(urlFilter)) {\n            resp = await injection.func(resp);\n          }\n        }\n\n        // if our response if now undefined, retry our request\n        if (resp === undefined) {\n          return retryFn();\n        }\n\n        // if we got an error code, retry our request\n        if (!options.ignoreErrors && resp.statusCode >= 400) {\n          return retryFn();\n        }\n\n        // force response to JSON object if options.json is set\n        if (options.json && resp.body && typeof resp.body === 'string') {\n          try {\n            resp.body = JSON.parse(resp.body);\n          } catch (e) {\n            // ignore\n          }\n        }\n\n        return resp;\n      });\n    });\n  };\n\n  /**\n   * Register a new injection for a specific domain\n   * @param {object} filter Mongo-type query to use to match a URL\n   * @param {function} func Function to call with needle request to inject extra data into.\n   * Function will take arguments: (method, URL, data, options)\n   */\n  mainFunction.injectForDomain = (filter, func) => {\n    // add to our array of injections, this is processing by HTTP()\n    this._httpInjections.push({\n      filter: sift(filter),\n      func,\n    });\n  };\n\n  /**\n   * Register a new response injection for a specific domain\n   * @param {object} filter Mongo-type query to use to match a URL\n   * @param {function} func Function to call with needle response object to make changes\n   * Function will take arguments: (response)\n   * Function *must* return the response object back, or undefined if you want to force a retry\n   */\n  mainFunction.injectForDomainResponse = (filter, func) => {\n    this._httpResponseInjections.push({\n      filter: sift(filter),\n      func,\n    });\n  };\n\n  /**\n   * Helper function to make a GET request\n   */\n  mainFunction.get = (url, data, options) => {\n    return mainFunction('GET', url, data, options);\n  };\n\n  /**\n   * Helper function to make a POST request\n   */\n  mainFunction.post = (url, data, options) => {\n    return mainFunction('POST', url, data, options);\n  };\n\n  /**\n   * Helper function to make a PUT request\n   */\n  mainFunction.put = (url, data, options) => {\n    return mainFunction('PUT', url, data, options);\n  };\n\n  /**\n   * Helper function to make a DELETE request\n   */\n  mainFunction.delete = (url, data, options) => {\n    return mainFunction('DELETE', url, data, options);\n  };\n\n  /**\n   * Helper function to make a PATCH request\n   */\n  mainFunction.patch = (url, data, options) => {\n    return mainFunction('PATCH', url, data, options);\n  };\n\n  /**\n   * Helper function to make a HEAD request\n   */\n  mainFunction.head = (url, data, options) => {\n    return mainFunction('HEAD', url, data, options);\n  };\n\n  /**\n   * Helper function to make a OPTIONS request\n   */\n  mainFunction.options = (url, data, options) => {\n    return mainFunction('OPTIONS', url, data, options);\n  };\n\n  /**\n   * Helper function to make a TRACE request\n   */\n  mainFunction.trace = (url, data, options) => {\n    return mainFunction('TRACE', url, data, options);\n  };\n\n  return mainFunction;\n});\n\n\nexport default HTTP;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/http.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 333,
    "kind": "variable",
    "name": "overrideFunc",
    "memberof": "lib/parks/http.js",
    "static": true,
    "longname": "lib/parks/http.js~overrideFunc",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/http.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 334,
    "kind": "function",
    "name": "setOverrideFunction",
    "memberof": "lib/parks/http.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/http.js~setOverrideFunction",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/http.js",
    "importStyle": "{setOverrideFunction}",
    "description": "Set an override function to use for HTTP requests<br />Accepts (method, URL, data, options)",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 335,
    "kind": "function",
    "name": "generateRandomAndroidUseragent",
    "memberof": "lib/parks/http.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/http.js~generateRandomAndroidUseragent",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/http.js",
    "importStyle": "{generateRandomAndroidUseragent}",
    "description": "Generate a random Android user agent for making network requests",
    "lineNumber": 22,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 336,
    "kind": "variable",
    "name": "harWriter",
    "memberof": "lib/parks/http.js",
    "static": true,
    "longname": "lib/parks/http.js~harWriter",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/http.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 337,
    "kind": "function",
    "name": "writeToHAR",
    "memberof": "lib/parks/http.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/parks/http.js~writeToHAR",
    "access": "private",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/http.js",
    "importStyle": null,
    "description": "Write a HTTP response to HAR file for debugging",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "resp",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "startTime",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "timeTaken",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 338,
    "kind": "function",
    "name": "HTTP",
    "memberof": "lib/parks/http.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/http.js~HTTP",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/http.js",
    "importStyle": "{HTTP}",
    "description": "HTTP helper with injection",
    "lineNumber": 99,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 339,
    "kind": "file",
    "name": "lib/parks/liseberg/liseberg.js",
    "content": "import {Destination} from '../destination.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\nimport moment from 'moment-timezone';\n\nexport class Liseberg extends Destination {\n  constructor(options = {}) {\n    options.timezone = options.timezone || 'Europe/Stockholm';\n    options.resortId = options.resortId || 'liseberg';\n\n    options.baseURL = options.baseURL || '';\n\n    super(options);\n\n    if (!this.config.resortId) throw new Error('Missing resortId');\n    if (!this.config.baseURL) throw new Error('Missing baseURL');\n  }\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data \n   * @returns {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    if (data) {\n      if (data.id) {\n        entity._id = `${data.id}`;\n      }\n\n      if (data.title) {\n        entity.name = data.title;\n      }\n\n      if (data.coordinates && data.coordinates.longitude && data.coordinates.latitude) {\n        entity.location = {\n          longitude: data.coordinates.longitude,\n          latitude: data.coordinates.latitude,\n        };\n      }\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    return {\n      ...this.buildBaseEntityObject(null),\n      _id: 'liseberg',\n      slug: 'liseberg',\n      name: 'Liseberg',\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    return [\n      {\n        ...this.buildBaseEntityObject(null),\n        _id: 'lisebergpark',\n        _destinationId: 'liseberg',\n        _parentId: 'liseberg',\n        slug: 'lisebergpark',\n        name: 'Liseberg',\n        entityType: entityType.park,\n      }\n    ];\n  }\n\n  /**\n   * Fetch the attraction states from Liseberg API\n   */\n  async fetchAttractionStates() {\n    '@cache|1';\n    const resp = await this.http('GET', `${this.config.baseURL}app/attractions/`);\n    return resp.body;\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    const attractions = await this.fetchAttractionStates();\n\n    return attractions.filter((x) => {\n      return x?.type === 'attraction';\n    }).map((attraction) => {\n      return {\n        ...this.buildBaseEntityObject(attraction),\n        entityType: entityType.attraction,\n        attractionType: attractionType.ride,\n        _destinationId: 'liseberg',\n        _parentId: 'lisebergpark',\n        _parkId: 'lisebergpark',\n      };\n    });\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    return [];\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    return [];\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const attractions = await this.fetchAttractionStates();\n\n    return attractions.map((attraction) => {\n      const liveEntry = {\n        _id: `${attraction.id}`,\n      };\n\n      if (attraction.state) {\n        liveEntry.status = attraction.state.isOpen ? statusType.operating : statusType.closed;\n        liveEntry.queue = {\n          [queueType.standBy]: {\n            waitTime: attraction.state.maxWaitTime,\n          },\n        };\n      }\n\n      return liveEntry;\n    });\n  }\n\n  /**\n   * Fetch the calendar for a given date (and x days further)\n   * @param {string} dateString Date in YYYY-MM-DD format \n   * @param {number} [datesToFetch=30] Number of dates to fetch from the dateString date \n   * @returns \n   */\n  async fetchCalendarForDate(dateString, datesToFetch = 7) {\n    '@cache|720'; // cache for 12 hours\n    try {\n      const resp = await this.http('GET', `${this.config.baseURL}calendar/${dateString}/${datesToFetch}`, undefined, {\n        retries: 0,\n      });\n      return resp.body;\n    } catch (e) {\n      return [];\n    }\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    const now = this.getTimeNowMoment();\n    const end = now.clone().add(30, 'days');\n\n    // should be 7 or 30, but server crashes on random dates\n    //  so we use 1 so at least we catch all the dates that don't crash\n    const batchSize = 1;\n\n    // loop through each 7 day block and fetch the calendar data for the next 30 days\n    const calendarData = [];\n    for (let i = now.clone(); i.isBefore(end); i.add(batchSize, 'days')) {\n      const dateString = i.format('YYYY-MM-DD');\n      const calendar = await this.fetchCalendarForDate(dateString, batchSize);\n      calendarData.push(...calendar);\n    }\n\n    const times = [];\n\n    calendarData.forEach((entry) => {\n      if (entry.closed) return;\n      const dateString = entry.dateRaw.slice(0, 10);\n      const dateMoment = moment.tz(dateString, 'YYYY-MM-DD', this.config.timezone);\n\n      const open = dateMoment.clone().hours(Number(entry.openingHoursDetailed.from)).minutes(0).seconds(0).milliseconds(0);\n      const close = dateMoment.clone().hours(Number(entry.openingHoursDetailed.to)).minutes(0).seconds(0).milliseconds(0);\n\n      times.push({\n        date: dateString,\n        type: \"OPERATING\",\n        openingTime: open.format(),\n        closingTime: close.format(),\n      });\n\n      // if we have evening hours, add these too\n      if (entry.eveningEntranceFrom && entry.eveningEntranceFrom !== '00:00') {\n        if (entry.eveningEntranceFrom.indexOf(':') >= 0) {\n          const eveningOpen = dateMoment.clone().hours(Number(entry.eveningEntranceFrom.split(':')[0])).minutes(Number(entry.eveningEntranceFrom.split(':')[1])).seconds(0).milliseconds(0);\n          if (eveningOpen.isBefore(close) && eveningOpen.isAfter(open)) {\n            times.push({\n              date: dateString,\n              type: \"INFO\",\n              description: \"Evening Hours\",\n              openingTime: eveningOpen.format(),\n              closingTime: close.format(),\n            });\n          }\n        }\n      }\n    });\n\n    return [\n      {\n        _id: 'lisebergpark',\n        schedule: times,\n      }\n    ];\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/liseberg/liseberg.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 340,
    "kind": "class",
    "name": "Liseberg",
    "memberof": "lib/parks/liseberg/liseberg.js",
    "static": true,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/liseberg/liseberg.js",
    "importStyle": "{Liseberg}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 341,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 50,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": string, \"slug\": string, \"name\": string, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 344,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 63,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "method",
    "name": "fetchAttractionStates",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#fetchAttractionStates",
    "access": "public",
    "description": "Fetch the attraction states from Liseberg API",
    "lineNumber": 80,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 346,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 89,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 109,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 348,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 116,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 349,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 123,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 350,
    "kind": "method",
    "name": "fetchCalendarForDate",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#fetchCalendarForDate",
    "access": "public",
    "description": "Fetch the calendar for a given date (and x days further)",
    "lineNumber": 150,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dateString",
        "description": "Date in YYYY-MM-DD format"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "30",
        "defaultRaw": 30,
        "name": "datesToFetch",
        "description": "Number of dates to fetch from the dateString date"
      }
    ],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 351,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/liseberg/liseberg.js~Liseberg",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/liseberg/liseberg.js~Liseberg#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 167,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 352,
    "kind": "file",
    "name": "lib/parks/livedata.js",
    "content": "import Ajv from 'ajv';\nconst ajv = new Ajv();\n\nimport {queueType, returnTimeState, statusType, boardingGroupState} from './parkTypes.js';\n\n// queue schema, can be applied to various entity types\nconst queueSchema = {\n  type: 'object',\n  properties: {\n    [queueType.standBy]: {\n      type: 'object',\n      properties: {\n        waitTime: {\n          type: ['integer', 'null'],\n          minimum: 0,\n        },\n      },\n      required: ['waitTime'],\n    },\n    // single rider is pretty much identical to standby\n    [queueType.singleRider]: {\n      type: 'object',\n      properties: {\n        waitTime: {\n          type: ['integer', 'null'],\n          minimum: 0,\n        },\n      },\n      required: ['waitTime'],\n    },\n    [queueType.returnTime]: {\n      type: 'object',\n      properties: {\n        returnStart: {\n          // TODO - replace with regexed time? timestamp?\n          type: ['string', 'null'],\n        },\n        returnEnd: {\n          type: ['string', 'null'],\n        },\n        state: {\n          type: 'string',\n          enum: Object.values(returnTimeState),\n        },\n      },\n      required: ['returnStart', 'returnEnd', 'state'],\n    },\n    [queueType.boardingGroup]: {\n      type: 'object',\n      properties: {\n        allocationStatus: {\n          type: 'string',\n          enum: Object.values(boardingGroupState),\n        },\n        currentGroupStart: {\n          type: ['string', 'integer', 'null'],\n        },\n        currentGroupEnd: {\n          type: ['string', 'integer', 'null'],\n        },\n        nextAllocationTime: {\n          type: ['string', 'null'],\n        },\n        estimatedWait: {\n          type: ['integer', 'null'],\n        },\n      },\n    },\n  },\n};\n\n// showtimes schema, an array of show start times\nconst showtimesSchema = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      startTime: {\n        type: ['string', 'null'],\n        format: 'date-time',\n      },\n      endTime: {\n        type: ['string', 'null'],\n        format: 'date-time',\n      },\n      // freeform text to describe this schedule entry\n      type: {\n        type: 'string',\n      },\n    },\n    required: ['startTime'],\n  },\n};\n\nconst statusSchema = {\n  type: 'string',\n  enum: Object.values(statusType),\n};\n\n// if any of these keys are present in livedata, we must run the schema validation against it\nconst schemas = {\n  status: statusSchema,\n  showtimes: showtimesSchema,\n  queue: queueSchema,\n  operatinghours: showtimesSchema, // TODO - uppercamel?\n};\n\n/**\n * Given an entity doc, and a live data object - validate the live data\n * @param {object} liveData\n * @return {Array<string>} Array of errors, of null if passes validation\n */\nexport function getLiveDataErrors(liveData) {\n  if (liveData === undefined) return null;\n\n  // find all keys that need validating\n  const keys = Object.keys(schemas).filter((key) => {\n    return !!liveData[key];\n  });\n\n  const errors = [];\n\n  // test each schema-driven key and build an array of any errors\n  keys.forEach((key) => {\n    const validator = ajv.compile(schemas[key]);\n    if (!validator(liveData[key])) {\n      errors.push(...validator.errors);\n    }\n  });\n\n  if (errors.length > 0) {\n    return errors;\n  }\n  return null;\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/livedata.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 353,
    "kind": "variable",
    "name": "ajv",
    "memberof": "lib/parks/livedata.js",
    "static": true,
    "longname": "lib/parks/livedata.js~ajv",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/livedata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 354,
    "kind": "variable",
    "name": "queueSchema",
    "memberof": "lib/parks/livedata.js",
    "static": true,
    "longname": "lib/parks/livedata.js~queueSchema",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/livedata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "{\"type\": string, \"properties\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 355,
    "kind": "variable",
    "name": "showtimesSchema",
    "memberof": "lib/parks/livedata.js",
    "static": true,
    "longname": "lib/parks/livedata.js~showtimesSchema",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/livedata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "type": {
      "types": [
        "{\"type\": string, \"items\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 356,
    "kind": "variable",
    "name": "statusSchema",
    "memberof": "lib/parks/livedata.js",
    "static": true,
    "longname": "lib/parks/livedata.js~statusSchema",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/livedata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "{\"type\": string, \"enum\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 357,
    "kind": "variable",
    "name": "schemas",
    "memberof": "lib/parks/livedata.js",
    "static": true,
    "longname": "lib/parks/livedata.js~schemas",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/livedata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "type": {
      "types": [
        "{\"status\": *, \"showtimes\": *, \"queue\": *, \"operatinghours\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 358,
    "kind": "function",
    "name": "getLiveDataErrors",
    "memberof": "lib/parks/livedata.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/livedata.js~getLiveDataErrors",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/livedata.js",
    "importStyle": "{getLiveDataErrors}",
    "description": "Given an entity doc, and a live data object - validate the live data",
    "lineNumber": 113,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "liveData",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "Array of errors, of null if passes validation"
    }
  },
  {
    "__docId__": 359,
    "kind": "file",
    "name": "lib/parks/parcasterix/parcasterix.js",
    "content": "import { Destination } from '../destination.js';\nimport { attractionType, statusType, queueType, tagType, scheduleType, entityType } from '../parkTypes.js';\nimport moment from 'moment-timezone';\n\nconst queries = {\n  getConfiguration: {\n    \"query\": \"query getConfiguration($language: String!) {\\n  configuration(localeFilters: {locale: $language}) {\\n    parkIsOpen\\n    parkOpeningTime\\n    parkClosingTime\\n    parkText\\n    parkInfoBanner\\n    parkLatitude\\n    parkLongitude\\n    parkRadiusMeters\\n    welcomeImage\\n    mapColorShow\\n    mapColorRestaurant\\n    minimumVersionIos\\n    minimumVersionAndroid\\n    cloudinaryProxyUrl\\n    enableMapDirections\\n    enableBillet\\n    enableFavoris\\n    __typename\\n  }\\n  locales {\\n    iso\\n    label\\n    __typename\\n  }\\n}\\n\"\n  },\n  getAttractions: {\n    \"query\": \"query getAttractions($language: String!) {\\n  openAttractions(localeFilters: {locale: $language}, orderBy: [{field: TITLE, order: ASC}]) {\\n    id\\n    drupalId\\n    title\\n    slug\\n    summary\\n    description\\n    experience {\\n      id\\n      drupalId\\n      label\\n      color\\n      __typename\\n    }\\n    mapId\\n    latitude\\n    longitude\\n    features {\\n      id\\n      label\\n      value\\n      icon\\n      __typename\\n    }\\n    headerV1\\n    thumbnailV1\\n    headerV2\\n    thumbnailV2\\n    sliders {\\n      picture\\n      order\\n      __typename\\n    }\\n    minAge\\n    order\\n    isNew\\n    isBest\\n    hasQueuingCut\\n    hasQueuingCutFear\\n    hasPicturePoint\\n    blocks\\n    labels\\n    __typename\\n  }\\n}\\n\",\n  },\n  spectacles: {\n    \"query\": \"query spectacles($language: String!) {\\n  openShows(localeFilters: {locale: $language}, orderBy: [{field: TITLE, order: ASC}]) {\\n    id\\n    drupalId\\n    title\\n    slug\\n    summary\\n    description\\n    mapId\\n    latitude\\n    longitude\\n    features {\\n      label\\n      value\\n      icon\\n      __typename\\n    }\\n    closingTimes {\\n      startAt\\n      endAt\\n      timezone\\n      __typename\\n    }\\n    headerV1\\n    thumbnailV1\\n    headerV2\\n    thumbnailV2\\n    sliders {\\n      picture\\n      order\\n      __typename\\n    }\\n    minAge\\n    order\\n    isNew\\n    isBest\\n    schedules\\n    scheduleIsFrom\\n    blocks\\n    labels\\n    __typename\\n  }\\n}\\n\",\n  },\n  attractionLatency: {\n    \"query\": \"query attractionLatency {\\n  attractionLatency {\\n    drupalId\\n    latency\\n    closingTime\\n    __typename\\n  }\\n}\\n\"\n  },\n  restaurants: {\n    \"query\": \"query restaurants($language: String!) {\\n  restaurants(localeFilters: {locale: $language}, orderBy: [{field: TITLE, order: ASC}]) {\\n    id\\n    drupalId\\n    title\\n    slug\\n    type\\n    kind\\n    kindDrupalId\\n    theme\\n    themeDrupalId\\n    universe\\n    mealType\\n    withTerrace\\n    summary\\n    description\\n    header\\n    sliders {\\n      picture\\n      order\\n      __typename\\n    }\\n    mapId\\n    latitude\\n    longitude\\n    menuUrl\\n    mobileUrl\\n    related {\\n      id\\n      __typename\\n    }\\n    blocks\\n    labels\\n    __typename\\n  }\\n}\\n\",\n  },\n  getCalendar: {\n    \"query\": \"query getCalendar {\\n  calendar {\\n    day\\n    times\\n    type\\n    __typename\\n  }\\n}\\n\",\n  },\n}\n\nexport class ParcAsterix extends Destination {\n  constructor(options = {}) {\n    options.timezone = options.timezone || 'Europe/Paris';\n\n    options.apiBase = options.apiBase || '';\n    options.language = options.language || 'en';\n\n    // bump cache version when we need to wipe our cached query state\n    options.cacheVersion = options.cacheVersion || 2;\n\n    super(options);\n\n    if (!this.config.apiBase) throw new Error('Missing apiBase');\n  }\n\n  /**\n   * Make a graphql query against the API using a query hash\n   * @param {string} operationName \n   * @param {string} queryHash \n   * @returns \n   */\n  async makeCachedQuery(operationName, queryHash) {\n    const query = {\n      operationName,\n      variables: {\n        language: this.config.language,\n      },\n    };\n\n    if (queries[operationName]) {\n      for (const k in queries[operationName]) {\n        query[k] = queries[operationName][k];\n      }\n    } else {\n      query.extensions = {\n        persistedQuery: {\n          version: 1,\n          sha256Hash: queryHash,\n        }\n      };\n    }\n\n    const resp = (await this.http(\n      'GET',\n      `${this.config.apiBase}graphql`,\n      query,\n    )).body;\n\n    if (resp?.errors) {\n      if (resp.errors[0] && resp.errors[0].message) {\n        throw new Error(`makeCachedQuery ${operationName} error: ${resp.errors[0].message}`);\n      }\n      throw new Error(`makeCachedQuery ${operationName} error: ${JSON.stringify(resp.errors)}`);\n    }\n\n    return resp;\n  }\n\n  /**\n   * Get some key resort data\n   */\n  async getResortData() {\n    // cache for 6 hours\n    '@cache|360';\n    return this.makeCachedQuery('getConfiguration', '765d8930f5d5a09ca39affd57e43630246b2fb683331e18938d5b2dba7cb8e8a');\n  }\n\n  /**\n   * Get raw attraction data\n   */\n  async getAttractionData() {\n    // cache for 6 hours\n    '@cache|360';\n    return this.makeCachedQuery('getAttractions', '5609363783d826ec6c460caa620e3ca28e651897febf6753159836ab72d8139b');\n  }\n\n  /**\n   * Get raw wait time data\n   */\n  async getWaitTimeData() {\n    '@cache|1';\n    return this.makeCachedQuery('attractionLatency', '41154df6dc22d5444dcfa749b69f3f177a3736031b0ed675c1730e7c7dfc9894');\n  }\n\n  /**\n   * Get raw calendar data\n   */\n  async getCalendarData() {\n    // cache for 6 hours\n    '@cache|360';\n    return this.makeCachedQuery('getCalendar', '4981b5364f50dce42cfc579b6e5cbe144f8ef12e6a5d1a6c2e8681c99545f39e');\n  }\n\n  /**\n   * Get raw restaurant data\n   */\n  async getRestaurantData() {\n    // cache for 6 hours\n    '@cache|360';\n    return this.makeCachedQuery('restaurants', '857561404b9f5c69e651d74e0f5c0403f5bd3bd02491a0958d11d60bd8526cc9');\n  }\n\n  /**\n   * Get raw show data\n   */\n  async getShowData() {\n    // cache for 6 hours\n    '@cache|360';\n    return this.makeCachedQuery('spectacles', 'a3a067a0edbfb3666228d5d966d5933b1572e271b4c7f2858ce1758a2490227e');\n  }\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data \n   * @returns {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    if (data) {\n      entity.name = data.title || undefined;\n\n      entity._id = data.drupalId;\n\n      if (data.latitude && data.longitude) {\n        entity.location = {\n          latitude: data.latitude,\n          longitude: data.longitude,\n        };\n      }\n\n      entity.fastPass = !!data.hasQueuingCut;\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    return {\n      ...this.buildBaseEntityObject(),\n      _id: 'parcasterix',\n      slug: 'parcasterix', // all destinations must have a unique slug\n      name: 'Parc Asterix',\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    const parkData = await this.getResortData();\n\n    return [\n      {\n        ...this.buildBaseEntityObject(null),\n        _id: 'parcasterixpark',\n        _destinationId: 'parcasterix',\n        _parentId: 'parcasterix',\n        slug: 'ParcAsterixPark',\n        name: 'Parc Asterix',\n        entityType: entityType.park,\n        location: {\n          longitude: parkData.data.configuration.longitude,\n          latitude: parkData.data.configuration.latitude,\n        },\n      }\n    ];\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    const attrs = await this.getAttractionData();\n\n    return attrs.data.openAttractions.filter((x) => {\n      return x.__typename === 'Attraction';\n    }).map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        entityType: entityType.attraction,\n        attractionType: attractionType.ride,\n        _destinationId: 'parcasterix',\n        _parentId: 'parcasterixpark',\n        _parkId: 'parcasterixpark',\n      };\n    }).filter((x) => {\n      return !!x && x._id;\n    });\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    const attrs = await this.getShowData();\n\n    return [];\n\n    // TODO - format shows when app returns some data\n    return attrs.data.openShows.map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        entityType: entityType.show,\n        _destinationId: 'parcasterix',\n        _parentId: 'parcasterixpark',\n        _parkId: 'parcasterixpark',\n      };\n    }).filter((x) => {\n      return !!x && x._id;\n    });\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    const attrs = await this.getRestaurantData();\n\n    return attrs.data.restaurants.filter((x) => {\n      return x.__typename === 'Restaurant';\n    }).map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        entityType: entityType.restaurant,\n        _destinationId: 'parcasterix',\n        _parentId: 'parcasterixpark',\n        _parkId: 'parcasterixpark',\n      };\n    }).filter((x) => {\n      return !!x && x._id;\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const waitTimes = await this.getWaitTimeData();\n\n    return waitTimes.data.attractionLatency.map((x) => {\n      const data = {\n        _id: x.drupalId,\n      };\n\n      data.status = statusType.operating;\n\n      if (x.latency === 'FERME') {\n        data.status = statusType.closed;\n      } else if (x.latency !== 'OUVERT') {\n        data.queue = {\n          [queueType.standBy]: {\n            waitTime: null,\n          }\n        };\n\n        if (x.latency !== null) {\n          if (x.latency.match(/^\\d+$/)) {\n            data.queue[queueType.standBy].waitTime = parseInt(x.latency, 10);\n          } else {\n            // TODO - report error in parsing latency, unknown string!\n            // assume closed\n            data.status = statusType.closed;\n          }\n        }\n      }\n\n      return data;\n    });\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    const calendarData = await this.getCalendarData();\n\n    const dates = [];\n    const matchHours = /(\\d+)h - (\\d+)h/;\n    calendarData.data.calendar.forEach((x) => {\n      x.times.split(' et ').forEach((times) => {\n        const match = matchHours.exec(times);\n        if (match) {\n          const date = moment.tz(x.day, 'YYYY-MM-DD', this.config.timezone);\n          date.set('minute', 0).set('hour', 0).set('second', 0).set('millisecond', 0);\n          dates.push({\n            date: x.day,\n            type: \"OPERATING\",\n            openingTime: date.clone().set('hour', parseInt(match[1], 10)).format(),\n            closingTime: date.clone().set('hour', parseInt(match[2], 10)).format(),\n          });\n        }\n      });\n    });\n\n    return [\n      {\n        _id: 'parcasterixpark',\n        schedule: dates,\n      },\n    ];\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/parcasterix/parcasterix.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 360,
    "kind": "variable",
    "name": "queries",
    "memberof": "lib/parks/parcasterix/parcasterix.js",
    "static": true,
    "longname": "lib/parks/parcasterix/parcasterix.js~queries",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/parcasterix/parcasterix.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "{\"getConfiguration\": *, \"getAttractions\": *, \"spectacles\": *, \"attractionLatency\": *, \"restaurants\": *, \"getCalendar\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 361,
    "kind": "class",
    "name": "ParcAsterix",
    "memberof": "lib/parks/parcasterix/parcasterix.js",
    "static": true,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parcasterix/parcasterix.js",
    "importStyle": "{ParcAsterix}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 362,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true
  },
  {
    "__docId__": 363,
    "kind": "method",
    "name": "makeCachedQuery",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#makeCachedQuery",
    "access": "public",
    "description": "Make a graphql query against the API using a query hash",
    "lineNumber": 47,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "operationName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "queryHash",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 364,
    "kind": "method",
    "name": "getResortData",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#getResortData",
    "access": "public",
    "description": "Get some key resort data",
    "lineNumber": 87,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "getAttractionData",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#getAttractionData",
    "access": "public",
    "description": "Get raw attraction data",
    "lineNumber": 96,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 366,
    "kind": "method",
    "name": "getWaitTimeData",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#getWaitTimeData",
    "access": "public",
    "description": "Get raw wait time data",
    "lineNumber": 105,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "getCalendarData",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#getCalendarData",
    "access": "public",
    "description": "Get raw calendar data",
    "lineNumber": 113,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 368,
    "kind": "method",
    "name": "getRestaurantData",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#getRestaurantData",
    "access": "public",
    "description": "Get raw restaurant data",
    "lineNumber": 122,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 369,
    "kind": "method",
    "name": "getShowData",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#getShowData",
    "access": "public",
    "description": "Get raw show data",
    "lineNumber": 131,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 370,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 143,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 371,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 167,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": string, \"slug\": string, \"name\": string, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 372,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 180,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 373,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 203,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 374,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 225,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 375,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 247,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 376,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 268,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 377,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/parcasterix/parcasterix.js~ParcAsterix",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/parcasterix/parcasterix.js~ParcAsterix#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 307,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 378,
    "kind": "file",
    "name": "lib/parks/park.js",
    "content": "import promiseRetry from 'promise-retry';\nimport Entity from './entity.js';\nimport moment from 'moment-timezone';\nimport Cache from '../cache/scopedCache.js';\nimport * as tags from './tags.js';\nimport {reusePromise, reusePromiseForever} from '../reusePromises.js';\nimport {queueType, returnTimeState} from './parkTypes.js';\n\n// quick helper function to wait x milliseconds as a Promise\nconst delay = (milliseconds) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n};\n\n/**\n * Base Park Object\n * @class\n */\nexport class Park extends Entity {\n  /**\n   * Create a new park object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    // how often to wait between updates to run another update\n    options.updateInterval = 1000 * 60 * 5; // 5 minutes\n    // disable auto-update for this object\n    //  set this if the update is being handled by an external system\n    options.disableParkUpdate = false;\n\n    super(options);\n\n    // create a new cache object for this park\n    this.cache = new Cache(this.constructor.name, this.config.cacheVersion || 0);\n\n    this.initialised = false;\n    this.hasRunPostInit = false;\n    this.hasRunUpdate = false;\n    this._pendingTags = {};\n\n    this._attractions = [];\n\n    // track the park's current date\n    //  we'll fire an event whenever this changes\n    this._currentDate = null;\n\n    // make attractions and calendar functions work offline\n    this.registerOfflineFunction('getAttractions');\n    this.registerOfflineFunction('getCalendar');\n  }\n\n  /**\n   * Call this to shutdown the park object.\n   * This is an async call, so wait until it has resolved to continue.\n   */\n  async shutdown() {\n    // disable any park updates\n    this.config.disableParkUpdate = true;\n  }\n\n  /**\n   * Get a globally unique ID for this park\n   * @return {string}\n   */\n  getParkUniqueID() {\n    return this.getUniqueID();\n  }\n\n  /**\n   * Get Park Attractions\n   */\n  async getAttractions() {\n    await this.ensureReady();\n\n    return this._attractions;\n  }\n\n  /**\n   * Setup the park for use\n   * Call to ensure the object has been initialised before accessing data\n   */\n  async init() {\n    // skip init if we're offline\n    if (this.offline) {\n      this.initialised = true;\n      this.hasRunUpdate = true;\n      return;\n    }\n\n    await reusePromiseForever(this, this._runInit);\n    if (!this.hasRunPostInit) {\n      this.hasRunPostInit = true;\n      await this._postInit();\n    }\n  }\n\n  /**\n   * @inheritdocs\n   */\n  async _postOfflineLoad() {\n    await this.postUpdate();\n  }\n\n  /**\n   * Run all the internal stages of the init process\n   * @private\n   */\n  async _runInit() {\n    try {\n      await this._init();\n      this.initialised = true;\n\n      if (!this.config.disableParkUpdate && !this.offline) {\n        // start an update loop\n\n        // use a separate function so we can quickly loop back around\n        const scheduleUpdate = async () => {\n          // pause for our updateInterval time\n          await delay(this.config.updateInterval);\n\n          // if our udpates get disabled during our timer, then skip and exit our\n          if (this.config.disableParkUpdate) return;\n\n          // wait for Promise to resolve, grab any catches, then continue anyway\n          this.update().then().catch().then(() => {\n            if (this.config.disableParkUpdate) return;\n\n            // schedule another update\n            setImmediate(scheduleUpdate.bind(this));\n          });\n        };\n\n        // start the first loop timer\n        scheduleUpdate();\n      }\n    } catch (e) {\n      console.error('Error initialising park', e);\n    }\n  }\n\n  /**\n   * Awaits until park is initalised and has run at least one update.\n   * @return {Promise}\n   */\n  async ensureReady() {\n    await this.init();\n\n    if (!this.hasRunUpdate) {\n      await this.update();\n    }\n\n    await this.ensureHasOfflineData();\n  }\n\n  /**\n   * Cache an attraction\n   * @param {string} attractionID ID of the attraction to be cached\n   */\n  async cacheAttractionObject(attractionID) {\n    // find our attraction\n    //  don't call the standard \"find\" function, as this will also create the object\n    //  we don't want to actually create ths attraction if it doesn't exist, just ignore it\n    const uniqueAttractionID = `${this.getParkUniqueID()}_${attractionID}`;\n    const attraction = this._attractions.find((attr) => attr.id == uniqueAttractionID);\n    if (attraction !== undefined) {\n      await this.cache.set(uniqueAttractionID, attraction, Number.MAX_SAFE_INTEGER);\n    }\n  }\n\n  /**\n   * Build an object representing an attraction from sourced data\n   * This object should not contain any \"state\" data, just static information about the attraction\n   * @param {string} attractionID Unique Attraction ID\n   * @return {object} Object containing at least 'name'.\n   * Also accepts 'type', which is an {@link attractionType}\n   */\n  async _buildAttractionObject(attractionID) {\n    throw new Error('Missing _buildAttractionObject Implementation', this.constructor.name);\n  }\n\n  /**\n   * Get the attraction object for a given ID (skips all generation/safety checks etc,)\n   * @param {string} attractionID\n   * @return {object}\n   * @private\n   */\n  _getAttractionByIDInternal(attractionID) {\n    // search our existing store for this attraction\n    const attraction = this._attractions.find((attr) => attr.rideId == attractionID);\n    if (attraction) {\n      return attraction;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get data about a attraction from its ID\n   * @param {string} attractionID Unique Attraction ID\n   * @return {object} The attraction object for the given ID, or undefined\n   */\n  async findAttractionByID(attractionID) {\n    // wrap our actual function so multiple calls will return the same object\n    return await reusePromise(this, this._findAttractionByID, `${attractionID}`);\n  }\n\n  /**\n   * Get data about a attraction from its ID\n   * @param {string} attractionID Unique Attraction ID\n   * @return {object} The attraction object for the given ID, or undefined\n   * @private\n   */\n  async _findAttractionByID(attractionID) {\n    // search our existing store for this attraction\n    const attraction = this._getAttractionByIDInternal(attractionID);\n    if (attraction) {\n      return attraction;\n    }\n\n    // build a unique attraction ID by prefixing the park's unique ID\n    const uniqueAttractionID = `${this.getParkUniqueID()}_${attractionID}`;\n\n    // attraction wasn't found, try and add one to our store\n    const newAttraction = {\n      id: uniqueAttractionID,\n      // TODO - rename to attractionID\n      rideId: attractionID, // unique attraction ID without the park prefix\n      name: undefined,\n      type: null,\n      status: {\n        status: null,\n        lastUpdated: null,\n        lastChanged: null,\n      },\n      queue: {},\n      tags: [],\n    };\n\n    // list of fields we want to accept from the park class\n    //  we don't want the park to add random fields to our attraction object\n    //  park-specific data should be added using \"tags\" instead, so our object structure is the same for all parks\n    const fieldsToCopyFromParkClass = [\n      'name',\n      'type', // TODO - rename this to attractionType, or some other morphing type based on entityType\n      'entityType', // TODO - validate incoming types\n    ];\n\n    // restore stored live attraction data from a cache\n    //  restore from cache *before* we build the actual attraction data\n    //  this will allow the park API to fill in any out-of-date fields with live data\n    const cachedAttraction = await this.cache.get(uniqueAttractionID);\n    if (cachedAttraction !== undefined) {\n      Object.keys(cachedAttraction).forEach((key) => {\n        // TODO - do we need to do anyhting special here for sub-fields?\n        if (key === 'tags') {\n          // TODO - re-validate tags\n        }\n        newAttraction[key] = cachedAttraction[key];\n      });\n    }\n\n    // ask the park implementation to supply us with some basic attraction information (name, type, etc.)\n    //  we'll then inject this into our attraction object, assuming it returns successfully\n    try {\n      const builtAttractionObject = {\n        // clone the object, to ensure we don't mess with the original\n        ...(await this._buildAttractionObject(attractionID)),\n      };\n      if (builtAttractionObject !== undefined && !!builtAttractionObject.name) {\n        // clear out any _src data (if present)\n        delete builtAttractionObject._src;\n\n        // add to our attractions array once we've got a valid attraction (not undefined) from child class\n        this._attractions.push(newAttraction);\n\n        // copy fields we're interested in into our new attraction object\n        fieldsToCopyFromParkClass.forEach((key) => {\n          if (builtAttractionObject[key] !== undefined) {\n            newAttraction[key] = builtAttractionObject[key];\n          }\n        });\n\n        const tags = (this._pendingTags[attractionID] || []).concat(builtAttractionObject.tags || []);\n        delete this._pendingTags[attractionID];\n\n        // we also manually accept the \"tags\" field\n        //  add each tag to the attraction after it's added to our object above\n        await Promise.allSettled(tags.map((tag) => {\n          return this.setAttractionTag(attractionID, tag.key, tag.type, tag.value);\n        }));\n\n        // cache attraction object so it can be restored quickly on future app intialisations\n        await this.cacheAttractionObject(attractionID);\n\n        return newAttraction;\n      }\n    } catch (e) {\n      this.emit('error', e);\n      console.error('Error building attraction object:', e);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Remove a tag from a given attraction ID\n   * @param {string} attractionID\n   * @param {string} key\n   * @param {tagType} type\n   */\n  async removeAttractionTag(attractionID, key, type) {\n    const attraction = await this._getAttractionByIDInternal(attractionID);\n    if (!attraction) return;\n\n    const existingTag = attraction.tags.findIndex((t) => t.key === key && t.type === type);\n    if (existingTag >= 0) {\n      attraction.tags.splice(existingTag, 1);\n      await this.cacheAttractionObject(attractionID);\n    }\n  }\n\n  /**\n   * Set a toggle tag for an attraction.\n   * This is different from more complex tags that expect a data structure.\n   * Use this for tags that don't have any actual value, but are just present. Eg. FastPass as a feature.\n   * @param {string} attractionID\n   * @param {tagType} type\n   * @param {boolean} value\n   */\n  async toggleAttractionTag(attractionID, type, value) {\n    return await this.setAttractionTag(attractionID, null, type, value);\n  }\n\n  /**\n   * Set an attraction tag\n   * Used for metadata on rides, such as location, thrill level, fastpass availability etc.\n   * @param {string|object} attractionID Attraction ID to update (or the actual object)\n   * @param {string} key Tag key to set\n   * @param {tagType} type Tag type to use\n   * @param {*} value Tag value to set\n   * @return {boolean} True if tag was stored successfully\n   */\n  async setAttractionTag(attractionID, key, type, value) {\n    // validate tag value\n    const newTag = tags.getValidTagObject(key, type, value);\n    if (newTag === undefined) {\n      return false;\n    }\n\n    // different path for simple tags that are being removed\n    if (tags.isSimpleTagType(type) && !value) {\n      // if value is false, remove the key\n      return await this.removeAttractionTag(attractionID, newTag.key, type);\n    }\n\n    // find attraction and apply tag to it\n    const attraction = await this._getAttractionByIDInternal(attractionID);\n    if (attraction) {\n      const existingTag = attraction.tags.findIndex((t) => t.key === newTag.key && t.type === newTag.type);\n      if (existingTag < 0) {\n        // push our new tag onto our attraction\n        attraction.tags.push(newTag);\n      } else {\n        // update existing tag entry\n        attraction.tags[existingTag] = newTag;\n      }\n      await this.cacheAttractionObject(attractionID);\n      return true;\n    } else {\n      // attraction isn't valid. Push to our pending array to process when/if it does become valid\n      this._pendingTags[attractionID] = [{key, type, value}].concat(\n          this._pendingTags[attractionID] || [],\n      );\n    }\n\n    return false;\n  }\n\n  /**\n   * Update an attraction state\n   * @param {string} attractionID Unique Attraction ID\n   * @param {statusType} status New Attraction state\n   */\n  async updateAttractionState(attractionID, status) {\n    if (attractionID === undefined) return;\n\n    const existingRide = await this.findAttractionByID(attractionID);\n    if (existingRide) {\n      // if we found a matching attraction, update its \"state\" property with our new data\n      const now = this.getTimeNow();\n\n      // last updated is always kept up-to-date, regardless of whether the data changed\n      existingRide.status.lastUpdated = now;\n\n      // only update \"lastChanged\" if the status has changed\n      const previousStatus = existingRide.status.status;\n      if (previousStatus !== status || existingRide.status.lastChanged === null) {\n        existingRide.status.status = status;\n        existingRide.status.lastChanged = now;\n\n        // broadcast updated ride event\n        //  try to make sure we have updated everything before we fire this event\n        this.emit('attractionStatus', existingRide, previousStatus);\n      }\n\n      // write updated attraction data to cache\n      await this.cacheAttractionObject(attractionID);\n    }\n  }\n\n  /**\n   * Update the queue status for an attraction\n   * @param {string} attractionID Attraction ID to update\n   * @param {number|object} queueValue Updated Wait Time in minutes, or null if wait time doesn't exist or isn't valid.\n   * Set waitTime to undefined to remove this queue type from the attraction.\n   * BoardingGroup and ReturnTime types expect an object containing queue details instead of a number\n   * @param {queueType} type Type of queue to update (standup, virtual, fastpass etc.)\n   */\n  async updateAttractionQueue(attractionID, queueValue = undefined, type = type.standBy) {\n    if (attractionID === undefined) return;\n\n    const existingRide = await this.findAttractionByID(attractionID);\n    if (existingRide) {\n      if (!existingRide.queue) {\n        existingRide.queue = {};\n      }\n\n      // edge-case, if we supply undefined, the queue has been removed\n      //  (or never existed and we're just double-checking it's not present)\n      if (queueValue === undefined) {\n        if (existingRide.queue[type] !== undefined) {\n          const previousWaitTime = existingRide.queue[type].waitTime;\n          delete existingRide.queue[type];\n\n          // fire event anyway, the queue has technically been updated (it's just not present at all now)\n          this.emit('attractionQueue', existingRide, type, previousWaitTime);\n\n          await this.cacheAttractionObject(attractionID);\n        }\n\n        // don't continue operations, early exit here\n        return;\n      }\n\n      if (!existingRide.queue[type]) {\n        existingRide.queue[type] = {\n          lastUpdated: null,\n          lastChanged: null,\n        };\n\n        if (type === queueType.standBy) {\n          // default standby state\n          existingRide.queue[type].waitTime = null;\n        } else if (type === queueType.returnTime) {\n          // default return time state\n          existingRide.queue[type].returnStart = null;\n          existingRide.queue[type].returnEnd = null;\n          existingRide.queue[type].state = null;\n        }\n      }\n\n      const queueData = existingRide.queue[type];\n\n      const now = this.getTimeNow();\n\n      if (type == queueType.standBy || type == queueType.singleRider) {\n        // wait times must be a positive number (in minutes)\n        //  if wait time is unknown (because it is not tracker or there is some issue), waitTime should be null\n        const newWaitTime = (isNaN(queueValue) || queueValue < 0) ? null : queueValue;\n        const previousWaitTime = queueData.waitTime;\n\n        // store last updated time\n        queueData.lastUpdated = now;\n\n        if (newWaitTime !== previousWaitTime || queueData.lastChanged === null) {\n          queueData.waitTime = newWaitTime;\n          queueData.lastChanged = now;\n\n          // broadcast updated ride event\n          //  try to make sure we have updated everything before we fire this event\n          this.emit('attractionQueue', existingRide, type, previousWaitTime);\n        }\n      } else if (type == queueType.returnTime) {\n        // handle \"return time\" style queue updates\n        // validate incoming data\n        if (\n          queueValue?.returnStart === undefined ||\n          queueValue?.returnEnd === undefined ||\n          // state can be null for \"unknown\" states\n          (queueValue?.state !== null && Object.values(returnTimeState).indexOf(queueValue?.state) < 0)\n        ) {\n          this.emit(\n              'error',\n              new Error(`Invalid return time object used ${JSON.stringify(queueValue)} (${attractionID})`),\n          );\n          return;\n        }\n\n        // make sure we're moment formatted strings\n        queueValue.returnStart = queueValue.returnStart === null ? null :\n          moment.tz(queueValue.returnStart, this.config.timezone).format();\n        queueValue.returnEnd = queueValue.returnEnd === null ? null :\n          moment.tz(queueValue.returnEnd, this.config.timezone).format();\n\n        const originalReturnTime = {\n          returnStart: queueData?.returnStart,\n          returnEnd: queueData?.returnEnd,\n          state: queueData?.state,\n        };\n\n        // mark data as \"updated\", even if it hasn't changed\n        queueData.lastUpdated = now;\n\n        if (\n          queueValue.returnStart != originalReturnTime.returnStart ||\n          queueValue.returnEnd != originalReturnTime.returnEnd ||\n          queueValue.state != originalReturnTime.state\n        ) {\n          // return time has changed!\n          queueData.returnStart = queueValue.returnStart;\n          queueData.returnEnd = queueValue.returnEnd;\n          queueData.state = queueValue.state;\n          queueData.lastChanged = now;\n\n          // broadcast updated ride event\n          this.emit('attractionQueue', existingRide, type, originalReturnTime);\n        }\n      } else if (type == queueType.boardingGroup) {\n        // TODO - handle baording group style queues\n        return;\n      }\n\n      // write updated attraction data to cache\n      await this.cacheAttractionObject(attractionID);\n    }\n  }\n\n  /**\n   * Called after each successful update, handle any clean-up or extra work here\n   * @private\n   */\n  async postUpdate() {\n    // check if our date has changed\n    await this._checkDate();\n  }\n\n  /**\n   * Update this park\n   * This is automatically called for you unless disableParkUpdate is set to false\n   */\n  async update() {\n    return reusePromise(this, this._runUpdate);\n  }\n\n  /**\n   * Internal method to actually run our update\n   * @private\n   */\n  async _runUpdate() {\n    // wait and catch the update Promise\n    try {\n    // start the _update call in a retry loop\n      await promiseRetry({\n        retries: 5,\n      }, (retryFn) => {\n        return this._update().catch(retryFn);\n      });\n    } catch (e) {\n      // emit error and print to screen\n      console.error('Error running _update()', e);\n      this.emit('error', e);\n      return;\n    }\n\n    this.hasRunUpdate = true;\n\n    try {\n      await this.postUpdate();\n    } catch (e) {\n      console.error('Error running postUpdate()', e);\n      this.emit('error', e);\n    }\n  }\n\n  /**\n   * Called when the park's date changes\n   * Eg. when passing midnight in the park's local timezone\n   *  or if late opening hours finish the morning after (eg. open until 2am, will be called just after 2am)\n   * @param {string} newDate Current Park Date\n   * @param {string} oldDate The previous date for this park before the update (can be null if park just initialised)\n   * @abstract\n   */\n  async _dateRefresh(newDate, oldDate) {}\n\n  /**\n   * Check if the park's \"active date\" has changed\n   */\n  async _checkDate() {\n    const todaysDate = await this.getActiveParkDate();\n    if (this._currentDate !== todaysDate) {\n      // store the previous date and update the current date immediately\n      //  this makes sure the park object is in the correct state before firing the newDate events\n      const originalDate = this._currentDate;\n      this._currentDate = todaysDate;\n\n      // broadcast event when the park's day changes\n      //  we can use this to update ride schedules etc.\n      await this._dateRefresh(todaysDate, originalDate);\n      this.emit('newDate', todaysDate, originalDate);\n    }\n  }\n\n  /**\n   * Internal function\n   * Called by init() to initialise the object\n   * @private\n   * @abstract\n   */\n  async _init() {\n    // implementation should be setup in child classes\n    throw new Error('_init() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Internal function\n   * Called by init() to initialise the object\n   * @private\n   * @abstract\n   */\n  async _postInit() {\n    // implementation should be setup in child classes\n  }\n\n  /**\n   * Update function the park object calls on interval to update internal state\n   * @private\n   * @abstract\n   */\n  async _update() {\n    // implementation should be setup in child classes\n    throw new Error('_update() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Given a moment date, return an array of opening hours for this park, or undefined\n   * Each entry should contain openingTime, closingTime, and type (of scheduleType)\n   * @param {moment} date\n   * @private\n   * @abstract\n   */\n  async _getOperatingHoursForDate(date) {\n    // implementation should be setup in child classes\n    throw new Error('_getOperatingHoursForDate() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Get the operating hours for the supplied date\n   * Will return undefined if the park API cannot return data for this date\n   *  (park is closed, too far in future, too far in past, etc.)\n   * @param {moment} date A momentjs object\n   * @return {object}\n   */\n  async getOperatingHoursForDate(date) {\n    // cache each calendar date to avoid recalculating it all the time\n    return this.cache.wrap(`calendar_${date.format('YYYY-MM-DD')}`, async () => {\n      return await this._getOperatingHoursForDate(date);\n    }, 1000 * 60 * 60 * 6); // cache for 6 hours\n  }\n\n  /**\n   * Given a moment date, return an array of opening hours for the restaurants in this park, or undefined\n   * Ech entry should contain openingTime closingTime\n   * @param {moment} date\n   */\n  async _getRestaurantOperatingHoursForDate(date) {\n    // implementation should be setup in child classes\n    throw new Error('_getRestaurantOperatingHoursForDate() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Get the restaurant operating hours for the supplied date\n   * @param {moment} date\n   */\n  async getRestaurantOperatingHoursForDate(date) {\n    return this.cache.wrap(`restaurant_${date.format('YYYY-MM-DD')}`, async () => {\n      return await this._getRestaurantOperatingHoursForDate(date);\n    }, 1000 * 60 * 60 * 6); // cache for 6 hours\n  }\n\n  /**\n   * Get Operating Calendar for this park\n   * @return{object} Object keyed to dates in YYYY-MM-DD format.\n   * Each date entry will contain an array of operating hours.\n   */\n  async getCalendar() {\n    try {\n      // make sure the park is initialised before continuing\n      await this.init();\n\n      // populate from yesterday onwards (if the API even gives us yesterday)\n      //  try to catch weird edge-cases where we're just past midnight but the park is still open\n      const yesterday = this.getTimeNowMoment().subtract(1, 'days');\n      // populate forward up to 60 days\n      const endFillDate = yesterday.clone().add(60 + 1, 'days');\n\n      const now = this.getTimeNowMoment();\n\n      const dates = {};\n      // get calendar by looping over each date\n      for (let date = yesterday; date.isSameOrBefore(endFillDate); date.add(1, 'day')) {\n        const hours = await this.getOperatingHoursForDate(date);\n        if (hours !== undefined) {\n          if (!Array.isArray(hours)) {\n            this.emit(\n                'error',\n                new Error(\n                    // eslint-disable-next-line max-len\n                    `Hours for ${this.name} date ${date.format('YYYY-MM-DD')} returned invalid non-Array ${JSON.stringify(hours)}`,\n                ),\n            );\n            continue;\n          }\n          // ignore if we're not within the operating hours AND the date is in the past\n          //  this will strip out yesterday once we've left that day's opening hours\n          const isInsideAnyDateHours = hours.find((h) => {\n            return now.isBetween(h.openingTime, h.closingTime);\n          });\n          if (now.isAfter(date, 'day') && isInsideAnyDateHours === undefined) {\n            continue;\n          }\n          dates[date.format('YYYY-MM-DD')] = hours;\n        }\n      }\n\n      return dates;\n    } catch (err) {\n      console.error('Error getting calendar', err);\n      this.emit('error', err);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Return the number of milliseconds until the next time the park is open.\n   * Will return 0 if park is already open.\n   * @return{number} Milliseconds until the park is open\n   */\n  async getNextOpeningTime() {\n    const calendar = await this.getCalendar();\n    const now = this.getTimeNowMoment();\n\n    const dates = Object.keys(calendar);\n    const nextOpeningTime = dates.reduce((p, date) => {\n      return Math.min(p, calendar[date].reduce((p2, time) => {\n        const msUntilOpening = moment(time.openingTime).diff(now);\n        // if the opening time is in the past, is the closing time in the future?\n        if (msUntilOpening <= 0) {\n          if (moment(time.closingTime).diff(now) > 0) {\n            return 0;\n          } else {\n            // otherwise this entire time block is in the past, ignore it\n            return p2;\n          }\n        }\n        return Math.min(p2, msUntilOpening);\n      }, Number.MAX_SAFE_INTEGER));\n    }, Number.MAX_SAFE_INTEGER);\n\n    return nextOpeningTime === Number.MAX_SAFE_INTEGER ? null : nextOpeningTime;\n  }\n\n  /**\n   * Return the number of milliseconds until closing time. Or 0 if already closed.\n   * @return {number}\n   */\n  async getNextClosingTime() {\n    const today = await this.getCalendarForToday();\n    if (today !== undefined) {\n      const now = this.getTimeNowMoment();\n      const closingTime = today.reduce((p, hours) => {\n        if (!now.isBetween(hours.openingTime, hours.closingTime)) {\n          return 0;\n        }\n\n        return Math.max(moment(hours.closingTime).diff(now), p);\n      }, 0);\n\n      return closingTime;\n    }\n    return 0;\n  }\n\n  /**\n   * Return the time until the park is open.\n   * @return{momentDuration} Time until park opens as a Moment Duration.\n   * Zero if already open, or null if unable to find time\n   */\n  async getNextOpeningTimeMomentDuration() {\n    const ms = await this.getNextOpeningTime();\n\n    if (ms === null) return null;\n    return moment.duration(ms, 'milliseconds');\n  }\n\n  /**\n   * Get the current park date, taking into consideration park hours past midnight etc.\n   * Eg. if the park is open past midnight, return yesterday's date.\n   * @return{moment} Park's \"active date\" as a Moment object\n   */\n  async getActiveParkDateMoment() {\n    const calendar = await this.getCalendar();\n\n    const nowInPark = moment(this.getTimeNow()).tz(this.config.timezone);\n    // check yesterday, today, and tomorrow to find any park hours that we're currently in\n    //  (including any extra hours etc.)\n    //  we will fall-back to the current date if none of these match\n    const isInParkHours = [\n      nowInPark.clone().add(-1, 'day'),\n      nowInPark,\n      nowInPark.clone().add(1, 'day'),\n    ].map((date) => {\n      // build array of our park calendar entries\n      return {\n        date,\n        data: calendar[date.format('YYYY-MM-DD')],\n      };\n    }).filter((parkHours) => {\n      // filter out any park hours that doesn't include the current time\n      if (!parkHours.data) return false;\n      const isInAnyParkHours = parkHours.data.find((hours) => {\n        return (nowInPark.isBetween(moment(hours.openingTime), moment(hours.closingTime)));\n      });\n      return !!isInAnyParkHours;\n    });\n\n    if (isInParkHours.length === 0) {\n      // just return today's calendar\n      return nowInPark;\n    }\n    // otherwise return the hours that we currently match\n    return isInParkHours[0].date;\n  }\n\n  /**\n   * Get the current park date, taking into consideration park hours past midnight etc.\n   * Eg. if the park is open past midnight, return yesterday's date.\n   * @return{string} Date in YYYY-MM-DD format\n   */\n  async getActiveParkDate() {\n    return (await this.getActiveParkDateMoment()).format('YYYY-MM-DD');\n  }\n\n  /**\n   * Get the park opening hours for today\n   */\n  async getCalendarForToday() {\n    const todaysDate = await this.getActiveParkDate();\n    const calendar = await this.getCalendar();\n    return calendar[todaysDate];\n  }\n\n  /**\n   * Get the park opening hours for tomorrow\n   */\n  async getCalendarForTomorrow() {\n    const todaysDate = await this.getActiveParkDate();\n    const tomorrow = moment(todaysDate, 'YYYY-MM-DD').add(1, 'day');\n    const calendar = await this.getCalendar();\n    return calendar[tomorrow.format('YYYY-MM-DD')];\n  }\n}\n\nexport default Park;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/park.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 379,
    "kind": "function",
    "name": "delay",
    "memberof": "lib/parks/park.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/park.js~delay",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/park.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "milliseconds",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 380,
    "kind": "class",
    "name": "Park",
    "memberof": "lib/parks/park.js",
    "static": true,
    "longname": "lib/parks/park.js~Park",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/park.js",
    "importStyle": "{Park}",
    "description": "Base Park Object",
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "lib/parks/entity.js~Entity"
    ]
  },
  {
    "__docId__": 381,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/park.js~Park#constructor",
    "access": "public",
    "description": "Create a new park object",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 382,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#cache",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 383,
    "kind": "member",
    "name": "initialised",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#initialised",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 384,
    "kind": "member",
    "name": "hasRunPostInit",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#hasRunPostInit",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 385,
    "kind": "member",
    "name": "hasRunUpdate",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#hasRunUpdate",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 386,
    "kind": "member",
    "name": "_pendingTags",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#_pendingTags",
    "access": "private",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 387,
    "kind": "member",
    "name": "_attractions",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#_attractions",
    "access": "private",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 388,
    "kind": "member",
    "name": "_currentDate",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#_currentDate",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "method",
    "name": "shutdown",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#shutdown",
    "access": "public",
    "description": "Call this to shutdown the park object.<br />This is an async call, so wait until it has resolved to continue.",
    "lineNumber": 57,
    "params": [],
    "return": null
  },
  {
    "__docId__": 390,
    "kind": "method",
    "name": "getParkUniqueID",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/park.js~Park#getParkUniqueID",
    "access": "public",
    "description": "Get a globally unique ID for this park",
    "lineNumber": 66,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 391,
    "kind": "method",
    "name": "getAttractions",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getAttractions",
    "access": "public",
    "description": "Get Park Attractions",
    "lineNumber": 73,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 392,
    "kind": "method",
    "name": "init",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#init",
    "access": "public",
    "description": "Setup the park for use<br />Call to ensure the object has been initialised before accessing data",
    "lineNumber": 83,
    "params": [],
    "return": null
  },
  {
    "__docId__": 396,
    "kind": "method",
    "name": "_postOfflineLoad",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_postOfflineLoad",
    "access": "private",
    "description": "",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@inheritdocs",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 397,
    "kind": "method",
    "name": "_runInit",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_runInit",
    "access": "private",
    "description": "Run all the internal stages of the init process",
    "lineNumber": 109,
    "params": [],
    "return": null
  },
  {
    "__docId__": 399,
    "kind": "method",
    "name": "ensureReady",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#ensureReady",
    "access": "public",
    "description": "Awaits until park is initalised and has run at least one update.",
    "lineNumber": 146,
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 400,
    "kind": "method",
    "name": "cacheAttractionObject",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#cacheAttractionObject",
    "access": "public",
    "description": "Cache an attraction",
    "lineNumber": 160,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "ID of the attraction to be cached"
      }
    ],
    "return": null
  },
  {
    "__docId__": 401,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_buildAttractionObject",
    "access": "private",
    "description": "Build an object representing an attraction from sourced data<br />This object should not contain any \"state\" data, just static information about the attraction",
    "lineNumber": 178,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Object containing at least 'name'.\nAlso accepts 'type', which is an {@link attractionType}"
    }
  },
  {
    "__docId__": 402,
    "kind": "method",
    "name": "_getAttractionByIDInternal",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/park.js~Park#_getAttractionByIDInternal",
    "access": "private",
    "description": "Get the attraction object for a given ID (skips all generation/safety checks etc,)",
    "lineNumber": 188,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 403,
    "kind": "method",
    "name": "findAttractionByID",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#findAttractionByID",
    "access": "public",
    "description": "Get data about a attraction from its ID",
    "lineNumber": 202,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The attraction object for the given ID, or undefined"
    }
  },
  {
    "__docId__": 404,
    "kind": "method",
    "name": "_findAttractionByID",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_findAttractionByID",
    "access": "private",
    "description": "Get data about a attraction from its ID",
    "lineNumber": 213,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The attraction object for the given ID, or undefined"
    }
  },
  {
    "__docId__": 405,
    "kind": "method",
    "name": "removeAttractionTag",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#removeAttractionTag",
    "access": "public",
    "description": "Remove a tag from a given attraction ID",
    "lineNumber": 311,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 406,
    "kind": "method",
    "name": "toggleAttractionTag",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#toggleAttractionTag",
    "access": "public",
    "description": "Set a toggle tag for an attraction.<br />This is different from more complex tags that expect a data structure.<br />Use this for tags that don't have any actual value, but are just present. Eg. FastPass as a feature.",
    "lineNumber": 330,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 407,
    "kind": "method",
    "name": "setAttractionTag",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#setAttractionTag",
    "access": "public",
    "description": "Set an attraction tag<br />Used for metadata on rides, such as location, thrill level, fastpass availability etc.",
    "lineNumber": 343,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Attraction ID to update (or the actual object)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Tag key to set"
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "Tag type to use"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Tag value to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if tag was stored successfully"
    }
  },
  {
    "__docId__": 408,
    "kind": "method",
    "name": "updateAttractionState",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#updateAttractionState",
    "access": "public",
    "description": "Update an attraction state",
    "lineNumber": 384,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      },
      {
        "nullable": null,
        "types": [
          "statusType"
        ],
        "spread": false,
        "optional": false,
        "name": "status",
        "description": "New Attraction state"
      }
    ],
    "return": null
  },
  {
    "__docId__": 409,
    "kind": "method",
    "name": "updateAttractionQueue",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#updateAttractionQueue",
    "access": "public",
    "description": "Update the queue status for an attraction",
    "lineNumber": 419,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Attraction ID to update"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "queueValue",
        "description": "Updated Wait Time in minutes, or null if wait time doesn't exist or isn't valid.\nSet waitTime to undefined to remove this queue type from the attraction.\nBoardingGroup and ReturnTime types expect an object containing queue details instead of a number"
      },
      {
        "nullable": null,
        "types": [
          "queueType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "Type of queue to update (standup, virtual, fastpass etc.)"
      }
    ],
    "return": null
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "postUpdate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#postUpdate",
    "access": "private",
    "description": "Called after each successful update, handle any clean-up or extra work here",
    "lineNumber": 542,
    "params": [],
    "return": null
  },
  {
    "__docId__": 411,
    "kind": "method",
    "name": "update",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#update",
    "access": "public",
    "description": "Update this park<br />This is automatically called for you unless disableParkUpdate is set to false",
    "lineNumber": 551,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 412,
    "kind": "method",
    "name": "_runUpdate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_runUpdate",
    "access": "private",
    "description": "Internal method to actually run our update",
    "lineNumber": 559,
    "params": [],
    "return": null
  },
  {
    "__docId__": 414,
    "kind": "method",
    "name": "_dateRefresh",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_dateRefresh",
    "access": "private",
    "description": "Called when the park's date changes<br />Eg. when passing midnight in the park's local timezone<br /> or if late opening hours finish the morning after (eg. open until 2am, will be called just after 2am)",
    "lineNumber": 593,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "newDate",
        "description": "Current Park Date"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "oldDate",
        "description": "The previous date for this park before the update (can be null if park just initialised)"
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 415,
    "kind": "method",
    "name": "_checkDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_checkDate",
    "access": "private",
    "description": "Check if the park's \"active date\" has changed",
    "lineNumber": 598,
    "params": [],
    "return": null
  },
  {
    "__docId__": 417,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_init",
    "access": "private",
    "description": "Internal function<br />Called by init() to initialise the object",
    "lineNumber": 619,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 418,
    "kind": "method",
    "name": "_postInit",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_postInit",
    "access": "private",
    "description": "Internal function<br />Called by init() to initialise the object",
    "lineNumber": 630,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 419,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_update",
    "access": "private",
    "description": "Update function the park object calls on interval to update internal state",
    "lineNumber": 639,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 420,
    "kind": "method",
    "name": "_getOperatingHoursForDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_getOperatingHoursForDate",
    "access": "private",
    "description": "Given a moment date, return an array of opening hours for this park, or undefined<br />Each entry should contain openingTime, closingTime, and type (of scheduleType)",
    "lineNumber": 651,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 421,
    "kind": "method",
    "name": "getOperatingHoursForDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getOperatingHoursForDate",
    "access": "public",
    "description": "Get the operating hours for the supplied date<br />Will return undefined if the park API cannot return data for this date<br /> (park is closed, too far in future, too far in past, etc.)",
    "lineNumber": 663,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "A momentjs object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 422,
    "kind": "method",
    "name": "_getRestaurantOperatingHoursForDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_getRestaurantOperatingHoursForDate",
    "access": "private",
    "description": "Given a moment date, return an array of opening hours for the restaurants in this park, or undefined<br />Ech entry should contain openingTime closingTime",
    "lineNumber": 675,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 423,
    "kind": "method",
    "name": "getRestaurantOperatingHoursForDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getRestaurantOperatingHoursForDate",
    "access": "public",
    "description": "Get the restaurant operating hours for the supplied date",
    "lineNumber": 684,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 424,
    "kind": "method",
    "name": "getCalendar",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getCalendar",
    "access": "public",
    "description": "Get Operating Calendar for this park<br />@return{object} Object keyed to dates in YYYY-MM-DD format.<br />Each date entry will contain an array of operating hours.",
    "lineNumber": 695,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 425,
    "kind": "method",
    "name": "getNextOpeningTime",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getNextOpeningTime",
    "access": "public",
    "description": "Return the number of milliseconds until the next time the park is open.<br />Will return 0 if park is already open.<br />@return{number} Milliseconds until the park is open",
    "lineNumber": 749,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 426,
    "kind": "method",
    "name": "getNextClosingTime",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getNextClosingTime",
    "access": "public",
    "description": "Return the number of milliseconds until closing time. Or 0 if already closed.",
    "lineNumber": 777,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 427,
    "kind": "method",
    "name": "getNextOpeningTimeMomentDuration",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getNextOpeningTimeMomentDuration",
    "access": "public",
    "description": "Return the time until the park is open.<br />@return{momentDuration} Time until park opens as a Moment Duration.<br />Zero if already open, or null if unable to find time",
    "lineNumber": 799,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 428,
    "kind": "method",
    "name": "getActiveParkDateMoment",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getActiveParkDateMoment",
    "access": "public",
    "description": "Get the current park date, taking into consideration park hours past midnight etc.<br />Eg. if the park is open past midnight, return yesterday's date.<br />@return{moment} Park's \"active date\" as a Moment object",
    "lineNumber": 811,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 429,
    "kind": "method",
    "name": "getActiveParkDate",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getActiveParkDate",
    "access": "public",
    "description": "Get the current park date, taking into consideration park hours past midnight etc.<br />Eg. if the park is open past midnight, return yesterday's date.<br />@return{string} Date in YYYY-MM-DD format",
    "lineNumber": 850,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 430,
    "kind": "method",
    "name": "getCalendarForToday",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getCalendarForToday",
    "access": "public",
    "description": "Get the park opening hours for today",
    "lineNumber": 857,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 431,
    "kind": "method",
    "name": "getCalendarForTomorrow",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getCalendarForTomorrow",
    "access": "public",
    "description": "Get the park opening hours for tomorrow",
    "lineNumber": 866,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 432,
    "kind": "file",
    "name": "lib/parks/parkTypes.js",
    "content": "\n/**\n * Possible types of queue\n * @enum\n */\nexport const queueType = Object.freeze({\n  // your standard \"stand-by queueing\"\n  standBy: 'STANDBY',\n  // identical to standby, but one guest at a time\n  singleRider: 'SINGLE_RIDER',\n  // virtual queue or \"classic\" paper fast-pass style system\n  //  can reserve a spot for a later time\n  returnTime: 'RETURN_TIME',\n  // special type, \"boarding group\"\n  //  guests reserve a slot to enter the attracion, but the time is not known\n  //  \"boarding groups\" are called in sequence when capacity allows\n  // eg. Rise of the Resistance at Disney\n  boardingGroup: 'BOARDING_GROUP',\n  // upcharge type, \"paid return time\"\n  //  example: Shanghai Disneyland or Disneyland Paris\n  //  guests can pay to get a faster return time\n  paidReturnTime: 'PAID_RETURN_TIME',\n});\n\n/**\n * Possible types of state for a return time queue\n * @enum\n */\nexport const returnTimeState = Object.freeze({\n  // there are places still available\n  available: 'AVAILABLE',\n  // more slots will be available later\n  temporarilyFull: 'TEMP_FULL',\n  // all slots have been reserved for the day\n  finished: 'FINISHED',\n});\n\n/**\n * Possible types for boarding groups\n * @enum\n */\nexport const boardingGroupState = Object.freeze({\n  // new boarding groups are available\n  available: 'AVAILABLE',\n  // boarding group allocations are not currently available, but may be later\n  paused: 'PAUSED',\n  // boarding groups currently not open\n  closed: 'CLOSED',\n});\n\n/**\n * Status an attraction can be in (Operating, Down, etc.)\n * @enum\n */\nexport const statusType = Object.freeze({\n  operating: 'OPERATING',\n  down: 'DOWN',\n  closed: 'CLOSED',\n  refurbishment: 'REFURBISHMENT',\n});\n\n/**\n * Entity types\n * @enum\n */\nexport const entityType = Object.freeze({\n  destination: 'DESTINATION',\n  park: 'PARK',\n  attraction: 'ATTRACTION',\n  restaurant: 'RESTAURANT',\n  hotel: 'HOTEL',\n  show: 'SHOW',\n});\n\n/**\n * All known attraction types (ride, show, etc.)\n * @enum\n */\nexport const attractionType = Object.freeze({\n  unknown: 'UNKNOWN',\n  ride: 'RIDE',\n  show: 'SHOW',\n  transport: 'TRANSPORT',\n  parade: 'PARADE',\n  meetAndGreet: 'MEET_AND_GREET',\n  // TODO - water pool areas? what do we call these?\n  other: 'OTHER',\n});\n\n/**\n * All possible schedule types\n * @enum\n */\nexport const scheduleType = Object.freeze({\n  operating: 'OPERATING', // normal park operating hours\n  ticketed: 'TICKETED_EVENT', // ticketed event. Halloween Horror nights etc.\n  private: 'PRIVATE_EVENT',\n  extraHours: 'EXTRA_HOURS', // \"extra magic hours\", \"early park admission\", etc.\n  informational: 'INFO', // some non-operating hours, listed for information (eg. \"You can now park hop\")\n});\n\n/**\n * All possible Tag types for attractions\n * @enum\n */\nexport const tagType = Object.freeze({\n  location: 'LOCATION',\n  fastPass: 'FASTPASS',\n  mayGetWet: 'MAY_GET_WET',\n  unsuitableForPregnantPeople: 'UNSUITABLE_PREGNANT',\n  minimumHeight: 'MINIMUM_HEIGHT',\n  maximumHeight: 'MAXIMUM_HEIGHT',\n  onRidePhoto: 'ONRIDE_PHOTO',\n  singleRider: 'SINGLE_RIDER',\n  childSwap: 'CHILD_SWAP',\n});\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/parkTypes.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 433,
    "kind": "variable",
    "name": "queueType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~queueType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{queueType}",
    "description": "Possible types of queue",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 434,
    "kind": "variable",
    "name": "returnTimeState",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~returnTimeState",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{returnTimeState}",
    "description": "Possible types of state for a return time queue",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 435,
    "kind": "variable",
    "name": "boardingGroupState",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~boardingGroupState",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{boardingGroupState}",
    "description": "Possible types for boarding groups",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 436,
    "kind": "variable",
    "name": "statusType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~statusType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{statusType}",
    "description": "Status an attraction can be in (Operating, Down, etc.)",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 437,
    "kind": "variable",
    "name": "entityType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~entityType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{entityType}",
    "description": "Entity types",
    "lineNumber": 66,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 438,
    "kind": "variable",
    "name": "attractionType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~attractionType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{attractionType}",
    "description": "All known attraction types (ride, show, etc.)",
    "lineNumber": 79,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 439,
    "kind": "variable",
    "name": "scheduleType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~scheduleType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{scheduleType}",
    "description": "All possible schedule types",
    "lineNumber": 94,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 440,
    "kind": "variable",
    "name": "tagType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~tagType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/parkTypes.js",
    "importStyle": "{tagType}",
    "description": "All possible Tag types for attractions",
    "lineNumber": 106,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 441,
    "kind": "file",
    "name": "lib/parks/phantasialand/phantasialand.js",
    "content": "import {Destination} from '../destination.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\n\nimport {v4 as uuidv4} from 'uuid';\n\nimport sift from 'sift';\nimport moment from 'moment-timezone';\n\nimport cheerio from 'cheerio';\n\nexport class Phantasialand extends Destination {\n  constructor(options = {}) {\n    options.timezone = options.timezone || 'Europe/Berlin';\n\n    options.apiBase = options.apiBase || '';\n\n    super(options);\n\n    if (!this.config.apiBase) throw new Error('Missing API Base URL (apiBase)');\n\n    const baseURLHostname = new URL(this.config.apiBase).hostname;\n\n    this.http.useragent = 'okhttp/3.12.1';\n\n    this.http.injectForDomain({\n      hostname: baseURLHostname,\n    }, async (method, url, data, options) => {\n      const isLoginRequest = url.indexOf('app-users') >= 0;\n      if (!isLoginRequest && method === 'GET') {\n        // fetch our cached access token\n        data.access_token = await this.fetchAccessToken();\n      }\n    });\n\n    // similarly, we can also inject into HTTP responses\n    //  if we detect an unauthorised response, we can unset our local auth tokens so they are refetched\n    this.http.injectForDomainResponse({\n      hostname: baseURLHostname,\n    }, async (response) => {\n      // look for 401 HTTP code (unauthorised)\n      if (response.statusCode === 401) {\n        // clear our access token on unauthorised responses\n        await this._clearFunctionCache('fetchAccessToken');\n        return undefined;\n      }\n\n      // otherwise, return the actual response\n      return response;\n    });\n  }\n\n  /**\n   * Create or fetch existing user for app login\n   */\n  async createUser() {\n    '@cache|481801'; // cache 11 months\n\n    // generate login\n    const username = `${uuidv4()}@android.com`;\n    const password = uuidv4();\n\n    // create our user\n    const userCreationResp = await this.http(\n      'POST',\n      `${this.config.apiBase}app-users`,\n      {\n        \"email\": username,\n        \"language\": \"en\",\n        \"password\": password,\n        \"platform\": \"android\"\n      },\n      {\n        json: true,\n      },\n    );\n\n    if (userCreationResp.body.email !== username) {\n      return undefined;\n    }\n\n    return {\n      \"email\": username,\n      \"password\": password,\n    };\n  }\n\n  /**\n   * Fetch cached access token, or fetch new one if expired\n   * @returns {string}\n   */\n  async fetchAccessToken() {\n    '@cache|481801'; // cache 11 months\n\n    // create user\n    const user = await this.createUser();\n    if (user === undefined) {\n      return undefined;\n    }\n\n    // login and get access token\n    const accessTokenResp = await this.http(\n      'POST',\n      `${this.config.apiBase}app-users/login`,\n      {\n        \"email\": user.email,\n        \"password\": user.password,\n        \"ttl\": 31556926, // 1 year, matching app behaviour\n      },\n      {\n        json: true,\n      },\n    );\n\n    this.log('Got new access token', accessTokenResp?.body?.id);\n\n    // return our new access token\n    return accessTokenResp?.body?.id;\n  }\n\n  /**\n   * Get the POI data objects from the API\n   * @returns {Array<Object>}\n   */\n  async getPOIData() {\n    '@cache|360'; // cache 6 hours\n    const POI = await this.http(\n      'GET',\n      `${this.config.apiBase}pois`,\n      {\n        'filter[where][seasons][like]': '%',\n        compact: true,\n      },\n    );\n\n    return POI.body;\n  }\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data \n   * @returns {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = super.buildBaseEntityObject(data);\n\n    if (data) {\n      if (data.adminOnly) return undefined;\n\n      // not on the map, ignore\n      if (!data.poiNumber) {\n        return undefined;\n      }\n\n      // if has no seasons, ignore\n      if (!data.seasons || data.seasons.length === 0) {\n        return undefined;\n      }\n\n      if (data.id !== undefined) {\n        entity._id = `${data.id}`;\n      }\n\n      // entity name\n      entity.name = data.title?.en || data._title?.en || data.title?.de || data._title?.de || undefined;\n\n      // entity location\n      const location = data.entrance?.world || data._entrance?.world;\n      if (location) {\n        entity.location = {\n          longitude: location.lng,\n          latitude: location.lat,\n        };\n      }\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    return {\n      ...this.buildBaseEntityObject(null),\n      _id: 'phantasialanddest',\n      slug: 'phantasialand', // all destinations must have a unique slug\n      name: 'Phantasialand',\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    return [\n      {\n        ...this.buildBaseEntityObject(null),\n        _id: 'phantasialand',\n        _destinationId: 'phantasialanddest',\n        _parentId: 'phantasialanddest',\n        slug: 'phantasialandpark',\n        name: 'Phantasialand',\n        entityType: entityType.park,\n      }\n    ];\n  }\n\n  async _buildEntitiesFromCategory(filter, extraFields = {}) {\n    const entities = await this.getPOIData();\n\n    return entities.filter(sift(filter)).map((x) => {\n      const ent = this.buildBaseEntityObject(x);\n      if (!ent) return undefined;\n      return {\n        ...ent,\n        _destinationId: 'phantasialanddest',\n        _parentId: 'phantasialand',\n        _parkId: 'phantasialand',\n        ...extraFields,\n      };\n    }).filter((x) => !!x);\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    return await this._buildEntitiesFromCategory({\n      category: 'ATTRACTIONS',\n    }, {\n      entityType: entityType.attraction,\n      attractionType: attractionType.ride,\n    });\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    return await this._buildEntitiesFromCategory({\n      category: {\n        $or: ['SHOWS', 'THE_SIX_DRAGONS', 'THEATER'],\n      },\n    }, {\n      entityType: entityType.show,\n    });\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    return await this._buildEntitiesFromCategory({\n      category: {\n        $or: ['RESTAURANTS_AND_SNACKS', 'PHANTASIALAND_HOTELS_RESTAURANTS'],\n      },\n      tags: {\n        $elemMatch: 'RESTAURANT',\n      },\n    }, {\n      entityType: entityType.restaurant,\n    });\n  }\n\n  /**\n   * Get a random lat/lon position within this destination\n   */\n  getRandomLocation() {\n    return {\n      longitude: 6.878342628 + (Math.random() * (6.877570152 - 6.878342628)),\n      latitude: 50.800659529 + (Math.random() * (50.799683077 - 50.800659529)),\n    };\n  }\n\n  /**\n   * Fetch live data from API\n   */\n  async fetchLiveData() {\n    '@cache|1'; // cache 1 minute\n    const randomLoc = this.getRandomLocation();\n\n    const waitData = await this.http('GET',\n      `${this.config.apiBase}signage-snapshots`,\n      {\n        loc: `${randomLoc.latitude.toFixed(14)},${randomLoc.longitude.toFixed(14)}`,\n      },\n    );\n\n    return waitData?.body;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const liveData = await this.fetchLiveData();\n\n    return liveData.map((x) => {\n      const liveData = {\n        _id: `${x.poiId}`,\n        status: statusType.operating,\n      };\n\n      if (x.showTimes !== null) {\n        liveData.status = x.showTimes.length > 0 ? statusType.operating : statusType.closed;\n        liveData.showtimes = x.showTimes.map((x) => {\n          return {\n            type: \"Performance Time\",\n            startTime: moment.tz(x, \"YYYY-MM-DD HH:mm:ss\", this.config.timezone).format(),\n            // return null for endTime as we don't have a show length available\n            endTime: null,\n          };\n        });\n      }\n\n      if (x.waitTime !== null) {\n        liveData.status = x.open ? statusType.operating : statusType.closed;\n        liveData.queue = {\n          [queueType.standBy]: {\n            waitTime: x.waitTime,\n          },\n        };\n      }\n\n      return liveData;\n    }).filter((x) => !!x);\n  }\n\n  /**\n   * Fetch calendar HTML data\n   */\n  async fetchCalendarData() {\n    '@cache|120';\n    const html = await this.http('GET', 'https://www.phantasialand.de/en/theme-park/opening-hours/');\n    return html.body;\n  }\n\n  /**\n   * Parse calendar data JSON from webpage\n   */\n  async getCalendarJSON() {\n    const data = await this.fetchCalendarData();\n    if (!data) return null;\n\n    try {\n      const $ = cheerio.load(data);\n      const json = $('.phl-date-picker');\n      const jsonData = JSON.parse(json.attr('data-calendar'));\n      return jsonData;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    const calendarData = await this.getCalendarJSON();\n\n    if (!calendarData) return [];\n\n    const parkSchedule = [];\n\n    const hoursRegex = /([0-9]{1,2}):([0-9]{2}).*\\s([0-9]{1,2}):([0-9]{2})/;\n\n    calendarData.forEach((x) => {\n      // skip closed entries\n      if (x.title_en === 'Closed') return;\n\n      if (!x.days_selected) return;\n\n      const openingTimes = hoursRegex.exec(x.title);\n      if (openingTimes) {\n        const openingTime = moment.tz(`${openingTimes[1]}:${openingTimes[2]}`, 'HH:mm', this.config.timezone);\n        const closingTime = moment.tz(`${openingTimes[3]}:${openingTimes[4]}`, 'HH:mm', this.config.timezone);\n\n        x.days_selected.forEach((day) => {\n          parkSchedule.push({\n            \"date\": day,\n            \"type\": \"OPERATING\",\n            \"openingTime\": moment.tz(`${day} ${openingTime.format('HH:mm')}`, 'YYYY-MM-DD HH:mm', this.config.timezone).format(),\n            \"closingTime\": moment.tz(`${day} ${closingTime.format('HH:mm')}`, 'YYYY-MM-DD HH:mm', this.config.timezone).format(),\n          });\n        });\n      }\n    });\n\n    return [\n      {\n        _id: 'phantasialand',\n        schedule: parkSchedule,\n      },\n    ];\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/phantasialand/phantasialand.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 442,
    "kind": "class",
    "name": "Phantasialand",
    "memberof": "lib/parks/phantasialand/phantasialand.js",
    "static": true,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/phantasialand/phantasialand.js",
    "importStyle": "{Phantasialand}",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 443,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true
  },
  {
    "__docId__": 444,
    "kind": "method",
    "name": "createUser",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#createUser",
    "access": "public",
    "description": "Create or fetch existing user for app login",
    "lineNumber": 55,
    "params": [],
    "return": {
      "types": [
        "{\"email\": *, \"password\": *}"
      ]
    }
  },
  {
    "__docId__": 445,
    "kind": "method",
    "name": "fetchAccessToken",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#fetchAccessToken",
    "access": "public",
    "description": "Fetch cached access token, or fetch new one if expired",
    "lineNumber": 91,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 446,
    "kind": "method",
    "name": "getPOIData",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#getPOIData",
    "access": "public",
    "description": "Get the POI data objects from the API",
    "lineNumber": 124,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Array<Object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<Object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 447,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 144,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 448,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 183,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": string, \"slug\": string, \"name\": string, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 449,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 196,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 450,
    "kind": "method",
    "name": "_buildEntitiesFromCategory",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#_buildEntitiesFromCategory",
    "access": "private",
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "params": [
      {
        "name": "filter",
        "types": [
          "*"
        ]
      },
      {
        "name": "extraFields",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 451,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 229,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 452,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 241,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 453,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 254,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 454,
    "kind": "method",
    "name": "getRandomLocation",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#getRandomLocation",
    "access": "public",
    "description": "Get a random lat/lon position within this destination",
    "lineNumber": 270,
    "params": [],
    "return": {
      "types": [
        "{\"longitude\": *, \"latitude\": *}"
      ]
    }
  },
  {
    "__docId__": 455,
    "kind": "method",
    "name": "fetchLiveData",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#fetchLiveData",
    "access": "public",
    "description": "Fetch live data from API",
    "lineNumber": 280,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 456,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 297,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 457,
    "kind": "method",
    "name": "fetchCalendarData",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#fetchCalendarData",
    "access": "public",
    "description": "Fetch calendar HTML data",
    "lineNumber": 334,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 458,
    "kind": "method",
    "name": "getCalendarJSON",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#getCalendarJSON",
    "access": "public",
    "description": "Parse calendar data JSON from webpage",
    "lineNumber": 343,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 459,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/phantasialand/phantasialand.js~Phantasialand",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/phantasialand/phantasialand.js~Phantasialand#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 362,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 460,
    "kind": "file",
    "name": "lib/parks/plopsaland/plopsa.js",
    "content": "import {Destination} from '../destination.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\nimport {URL} from 'url';\nimport moment from 'moment-timezone';\n\nclass PlopsaBase extends Destination {\n  constructor(options = {}) {\n    options.timezone = options.timezone || 'Europe/Brussels';\n\n    options.clientId = options.clientId || '';\n    options.clientSecret = options.clientSecret || '';\n    options.baseURL = options.baseURL || '';\n    options.baseLang = options.baseLang || '';\n    options.destinationSlug = options.destinationSlug || '';\n    options.parkSlug = options.parkSlug || '';\n\n    options.configPrefixes = ['PLOPSA'];\n\n    super(options);\n\n    if (!this.config.clientId) throw new Error('Missing clientId');\n    if (!this.config.clientSecret) throw new Error('Missing clientSecret');\n    if (!this.config.baseURL) throw new Error('Missing baseURL');\n    if (!this.config.destinationSlug) throw new Error('Missing destinationSlug');\n    if (!this.config.parkSlug) throw new Error('Missing parkSlug');\n\n    const baseURLHostname = new URL(this.config.baseURL).hostname;\n    this.http.injectForDomain({\n      hostname: baseURLHostname,\n    }, async (method, url, data, options) => {\n      // all our requests are JSON based\n      options.json = true;\n\n      // don't inject into the auth request\n      if (options?.authRequest) {\n        return;\n      }\n\n      const authToken = await this.getAuthToken();\n      if (!authToken) {\n        throw new Error('Could not get auth token');\n      }\n\n      // add access token to the request\n      const urlObj = new URL(url);\n      if (!urlObj.searchParams.has('access_token')) {\n        urlObj.searchParams.set('access_token', authToken);\n      }\n\n      return {\n        url: urlObj.toString(),\n      }\n    });\n  }\n\n  /**\n   * Get the auth token for our API\n   */\n  async getAuthToken() {\n    const cacheKey = `${this.config.destinationSlug}-auth-token`;\n\n    const authToken = await this.cache.get(cacheKey);\n    if (authToken) {\n      return authToken;\n    }\n\n    const resp = await this.http('POST', `${this.config.baseURL}${this.config.baseLang}/api/v1.0/token/000`, {\n      clientId: this.config.clientId,\n      clientSecret: this.config.clientSecret,\n    }, {\n      authRequest: true,\n      json: true,\n    });\n\n    if (!resp.body.accessToken) {\n      throw new Error('Could not get auth token');\n    }\n\n    // expire 1 minute before the token expires\n    const ttl = resp.body.expiresOn - Math.floor(+new Date() / 1000) - 60;\n    await this.cache.set(cacheKey, resp.body.accessToken, ttl * 1000);\n\n    console.log('Got auth token', resp.body.accessToken);\n\n    return resp.body.accessToken;\n  }\n\n  /**\n   * Get raw wait time data\n   */\n  async getWaitData() {\n    '@cache|1'; // cache for 1 minute\n    const resp = await this.http('GET', `${this.config.baseURL}${this.config.baseLang}/api/v1.0/waitingTime/${this.config.destinationSlug}/attraction`);\n    return resp.body;\n  }\n\n  /**\n   * Get raw attraction POI data\n   */\n  async getAttractionData() {\n    '@cache|720'; // cache for 12 hours\n    const resp = await this.http('GET', `${this.config.baseURL}${this.config.baseLang}/api/v1.0/details/all/${this.config.destinationSlug}/attraction`);\n    return resp.body;\n  }\n\n  /**\n   * Get raw dining POI data\n   */\n  async getDiningData() {\n    '@cache|720'; // cache for 12 hours\n    const resp = await this.http('GET', `${this.config.baseURL}${this.config.baseLang}/api/v1.0/details/all/${this.config.destinationSlug}/page`);\n    return resp.body;\n  }\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data \n   * @returns {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    if (data) {\n      if (data.id) {\n        entity._id = `${data.id}`;\n      }\n\n      if (data.name) {\n        entity.name = data.name;\n      }\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    const doc = {};\n    return {\n      ...this.buildBaseEntityObject(doc),\n      _id: this.config.destinationSlug,\n      slug: this.config.destinationSlug, // all destinations must have a unique slug\n      name: this.config.name,\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    return [\n      {\n        ...this.buildBaseEntityObject(null),\n        _id: this.config.parkSlug,\n        _destinationId: this.config.destinationSlug,\n        _parentId: this.config.destinationSlug,\n        slug: this.config.parkSlug,\n        name: this.config.name,\n        entityType: entityType.park,\n      }\n    ];\n  }\n\n  /**\n   * Merge data from multiple locales into a single object\n   * Priorities languages in order\n   */\n  mergeLocaleData(obj, key, compFn = null) {\n    const langs = [this.config.baseLang, 'en'];\n\n    if (!compFn) {\n      compFn = (baseObj, baseKey, existingResults) => {\n        return (x, key) => {\n          return baseObj.uniqueID === x.uniqueID;\n        };\n      };\n    }\n\n    const result = [];\n    for (const lang of langs) {\n      const data = obj[lang] ? obj[lang][key] : null;\n      if (data) {\n        const keys = Object.keys(data);\n        for (const key of keys) {\n          const ent = data[key];\n          const comp = compFn(ent, key, result);\n          const existingResult = result.find((entry) => {\n            return comp(entry, entry.key);\n          });\n          if (!existingResult) {\n            result.push({\n              ...ent,\n              key: key,\n            });\n          } else if (lang === 'en') {\n            // take name from 'en' where possible\n            if (ent.name) {\n              existingResult.name = ent.name;\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    const attractions = await this.getAttractionData();\n    const data = this.mergeLocaleData(attractions, 'attraction');\n\n    return data.map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        entityType: entityType.attraction,\n        attractionType: attractionType.ride,\n        _destinationId: this.config.destinationSlug,\n        _parentId: this.config.parkSlug,\n        _parkId: this.config.parkSlug,\n      };\n    });\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    return [];\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    const restaurants = await this.getDiningData();\n    const data = this.mergeLocaleData(restaurants, 'food');\n\n    return data.map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        entityType: entityType.restaurant,\n        _destinationId: this.config.destinationSlug,\n        _parentId: this.config.parkSlug,\n        _parkId: this.config.parkSlug,\n      };\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const liveData = await this.getWaitData();\n\n    if (!liveData || !liveData[this.config.baseLang]) return [];\n\n    // console.log(liveData);\n    return liveData[this.config.baseLang].map((x) => {\n      const data = {\n        _id: x.id,\n        status: statusType.closed,\n      };\n\n      if (x.showWaitingTime) {\n        data.status = statusType.operating;\n        const waitTime = parseInt(x.currentWaitingTime, 10);\n        if (!isNaN(waitTime)) {\n          data.queue = {\n            [queueType.standBy]: {\n              waitTime: waitTime,\n            },\n          };\n        }\n      }\n\n      return data;\n    }).filter((x) => !!x);\n  }\n\n  /**\n   * Fetch raw calendar data\n   */\n  async fetchCalendarData() {\n    // cache 12 hours\n    '@cache|720';\n    const resp = await this.http('GET', `${this.config.baseURL}${this.config.baseLang}/api/v1.0/calendar/${this.config.destinationSlug}`);\n    return resp.body;\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    const scheduleData = await this.fetchCalendarData();\n\n    const data = this.mergeLocaleData(scheduleData, 'months', (baseObj, baseKey) => {\n      return (x) => {\n        return x.key === baseKey;\n      };\n    }).reduce((arr, x) => {\n      arr.push(...Object.keys(x.openOn).map((key) => {\n        return {\n          ...x.openOn[key],\n          date: key,\n        };\n      }));\n      return arr;\n    }, []);\n\n    const hourRegex = /([0-9]{1,2})[:\\.]([0-9]{2}) - ([0-9]{1,2})[:\\.]([0-9]{2})/;\n\n    return [\n      {\n        _id: this.config.parkSlug,\n        schedule: data.map((x) => {\n          if (!x) return null;\n\n          const match = hourRegex.exec(x.label);\n          if (!match) return null;\n\n          const date = x.date.substring(0, 10);\n          const dateObj = moment.tz(date, 'YYYY-MM-DD', this.config.timezone);\n\n          const openHours = dateObj.clone().hours(Number(match[1])).minutes(Number(match[2]));\n          const closeHours = dateObj.clone().hours(Number(match[3])).minutes(Number(match[4]));\n\n          return {\n            date,\n            type: 'OPERATING',\n            openingTime: openHours.format(),\n            closingTime: closeHours.format(),\n          };\n        }).filter((x) => !!x),\n      }\n    ];\n  }\n}\n\nexport class Plopsaland extends PlopsaBase {\n  constructor(config = {}) {\n    config.destinationSlug = 'plopsaland-de-panne';\n    config.parkSlug = 'plopsaland';\n    config.baseURL = 'https://www.plopsalanddepanne.be/';\n    config.baseLang = 'nl';\n    config.name = 'Plopsaland De Panne';\n\n    super(config);\n  }\n}\n\nexport class HolidayPark extends PlopsaBase {\n  constructor(config = {}) {\n    config.destinationSlug = 'holiday-park';\n    config.parkSlug = 'holidaypark';\n    config.baseURL = 'https://www.holidaypark.de/';\n    config.baseLang = 'de';\n    config.name = 'Holiday Park';\n\n    super(config);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/plopsaland/plopsa.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 461,
    "kind": "class",
    "name": "PlopsaBase",
    "memberof": "lib/parks/plopsaland/plopsa.js",
    "static": true,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/plopsaland/plopsa.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ],
    "ignore": true
  },
  {
    "__docId__": 462,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 7,
    "undocument": true
  },
  {
    "__docId__": 463,
    "kind": "method",
    "name": "getAuthToken",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#getAuthToken",
    "access": "public",
    "description": "Get the auth token for our API",
    "lineNumber": 59,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 464,
    "kind": "method",
    "name": "getWaitData",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#getWaitData",
    "access": "public",
    "description": "Get raw wait time data",
    "lineNumber": 91,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 465,
    "kind": "method",
    "name": "getAttractionData",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#getAttractionData",
    "access": "public",
    "description": "Get raw attraction POI data",
    "lineNumber": 100,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 466,
    "kind": "method",
    "name": "getDiningData",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#getDiningData",
    "access": "public",
    "description": "Get raw dining POI data",
    "lineNumber": 109,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 467,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 121,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 468,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 140,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": *, \"slug\": *, \"name\": *, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 469,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 154,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 470,
    "kind": "method",
    "name": "mergeLocaleData",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#mergeLocaleData",
    "access": "public",
    "description": "Merge data from multiple locales into a single object<br />Priorities languages in order",
    "lineNumber": 172,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "compFn",
        "optional": true,
        "types": [
          "undefined"
        ],
        "defaultValue": "undefined"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 471,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 215,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 472,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 234,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 473,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 241,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 474,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 259,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 475,
    "kind": "method",
    "name": "fetchCalendarData",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#fetchCalendarData",
    "access": "public",
    "description": "Fetch raw calendar data",
    "lineNumber": 290,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 476,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/plopsaland/plopsa.js~PlopsaBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~PlopsaBase#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 302,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 477,
    "kind": "class",
    "name": "Plopsaland",
    "memberof": "lib/parks/plopsaland/plopsa.js",
    "static": true,
    "longname": "lib/parks/plopsaland/plopsa.js~Plopsaland",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/plopsaland/plopsa.js",
    "importStyle": "{Plopsaland}",
    "description": null,
    "lineNumber": 348,
    "undocument": true,
    "interface": false,
    "extends": [
      "PlopsaBase"
    ]
  },
  {
    "__docId__": 478,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/plopsaland/plopsa.js~Plopsaland",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~Plopsaland#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 349,
    "undocument": true
  },
  {
    "__docId__": 479,
    "kind": "class",
    "name": "HolidayPark",
    "memberof": "lib/parks/plopsaland/plopsa.js",
    "static": true,
    "longname": "lib/parks/plopsaland/plopsa.js~HolidayPark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/plopsaland/plopsa.js",
    "importStyle": "{HolidayPark}",
    "description": null,
    "lineNumber": 360,
    "undocument": true,
    "interface": false,
    "extends": [
      "PlopsaBase"
    ]
  },
  {
    "__docId__": 480,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/plopsaland/plopsa.js~HolidayPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/plopsaland/plopsa.js~HolidayPark#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 361,
    "undocument": true
  },
  {
    "__docId__": 481,
    "kind": "file",
    "name": "lib/parks/scheduledata.js",
    "content": "import Ajv from 'ajv';\nimport {scheduleType} from './parkTypes.js';\nconst ajv = new Ajv();\n\nconst scheduleSchema = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      date: {\n        type: 'string',\n        // validate date format YYYY-MM-DD\n        format: 'date',\n      },\n      type: {\n        type: 'string',\n        // limited to ENUM types scheduleType\n        values: Object.values(scheduleType),\n      },\n      description: {\n        type: 'string',\n      },\n      openingTime: {\n        type: 'string',\n        format: 'date-time',\n      },\n      closingTime: {\n        type: 'string',\n        format: 'date-time',\n      },\n    },\n    required: ['date', 'type', 'openingTime', 'closingTime'],\n  },\n};\n\n/**\n * Validate a schedula data object. Containing _id and a schedule array of schedules\n * @param {object} scheduleData\n * @return {array<string>} Array of errors, or null if successful\n */\nexport function validateEntitySchedule(scheduleData) {\n  const errors = [];\n  if (!scheduleData._id) {\n    errors.push('scheduleData missing _id field');\n  }\n  if (!scheduleData.schedule) {\n    errors.push('scheduleData missing schedule field');\n  }\n  if (errors.length > 0) return errors;\n\n  const validator = ajv.compile(scheduleSchema);\n  if (!validator(scheduleData.schedule)) {\n    return validator.errors;\n  }\n  return null;\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/scheduledata.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 482,
    "kind": "variable",
    "name": "ajv",
    "memberof": "lib/parks/scheduledata.js",
    "static": true,
    "longname": "lib/parks/scheduledata.js~ajv",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/scheduledata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 483,
    "kind": "variable",
    "name": "scheduleSchema",
    "memberof": "lib/parks/scheduledata.js",
    "static": true,
    "longname": "lib/parks/scheduledata.js~scheduleSchema",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/scheduledata.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "{\"type\": string, \"items\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 484,
    "kind": "function",
    "name": "validateEntitySchedule",
    "memberof": "lib/parks/scheduledata.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/scheduledata.js~validateEntitySchedule",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/scheduledata.js",
    "importStyle": "{validateEntitySchedule}",
    "description": "Validate a schedula data object. Containing _id and a schedule array of schedules",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "scheduleData",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<string>"
      ],
      "spread": false,
      "description": "Array of errors, or null if successful"
    }
  },
  {
    "__docId__": 485,
    "kind": "file",
    "name": "lib/parks/sieve.js",
    "content": "import mingo from 'mingo';\n\n/**\n * Build a mongo-style filter function\n * @param {object} conf\n * @return {function}\n */\nexport function Sieve(conf = {}) {\n  const query = new mingo.Query(conf);\n  return (x) => query.test(x);\n}\n\nexport default Sieve;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/sieve.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 486,
    "kind": "function",
    "name": "Sieve",
    "memberof": "lib/parks/sieve.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/sieve.js~Sieve",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/sieve.js",
    "importStyle": "{Sieve}",
    "description": "Build a mongo-style filter function",
    "lineNumber": 8,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "conf",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 487,
    "kind": "file",
    "name": "lib/parks/tags.js",
    "content": "// this file handles storing different tag types\n\nimport {tagType} from './parkTypes.js';\n\n/**\n * Validate a rider height tag. Used for min/max heights\n * @param {string} key\n * @param {*} data\n * @return {boolean}\n */\nconst riderHeightValidate = (key, data) => {\n  if (!validateObjectContainsOnlyGivenKeys(data, ['height', 'unit'])) {\n    return false;\n  }\n\n  const validUnits = ['cm', 'in'];\n  if (validUnits.indexOf(data.unit) < 0) {\n    return false;\n  }\n\n  return !isNaN(data.height) && data.height >= 0;\n};\n\n/**\n * Simple tags that don't have a value entry.\n * Instead, these tags are either present or not.\n */\nconst simpleTags = {\n  [tagType.fastPass]: true,\n  [tagType.mayGetWet]: true,\n  [tagType.unsuitableForPregnantPeople]: true,\n  [tagType.onRidePhoto]: true,\n  [tagType.singleRider]: true,\n  [tagType.childSwap]: true,\n};\n\n/**\n * Each tag type must have a validator function to confirm the incoming tag value is correct\n */\nconst validators = {\n  // Location tags\n  [tagType.location]: (key, data) => {\n    // make sure we have our longitude and latitude keys\n    if (!validateObjectContainsOnlyGivenKeys(data, ['longitude', 'latitude'])) {\n      return false;\n    }\n\n    // make sure our keys are valid numbers\n    if (isNaN(data.longitude) || isNaN(data.latitude)) {\n      return false;\n    }\n\n    return true;\n  },\n  // minimum height allowed to ride\n  //  must contain \"height\" as a number, and a \"unit\" which can be 'cm' (centimeters) or 'in' (inches)\n  [tagType.minimumHeight]: riderHeightValidate,\n  // maximum height allowed to ride\n  //  must contain \"height\" as a number, and a \"unit\" which can be 'cm' (centimeters) or 'in' (inches)\n  [tagType.maximumHeight]: riderHeightValidate,\n};\n\n\n/**\n * Given an object, validate that it only contains the given keys\n * Will return false if the object is missing any keys, or has additional keys not listed\n * @param {object} data\n * @param {array<string>} keys\n * @return {boolean}\n */\nfunction validateObjectContainsOnlyGivenKeys(data, keys) {\n  // make sure our input is an object\n  if (typeof data !== 'object' || data === null) return false;\n\n  // make sure our incoming keys is an array\n  keys = [].concat(keys);\n\n  // get the keys of our incoming object\n  const dataKeys = Object.keys(data);\n  // early bail if we have a different number of keys\n  if (dataKeys.length !== keys.length) return false;\n\n  // filter all our keys against our data key\n  // TODO - this may get slow for large objects, look to optimise\n  const matchingKeys = keys.filter((key) => {\n    return dataKeys.indexOf(key) >= 0;\n  });\n  // if our filtered keys is still the same length, we have all the keys we want\n  return (matchingKeys.length === dataKeys.length);\n}\n\n/**\n * Is the supplied tag type supported?\n * @param {tagType} type\n * @return {boolean}\n */\nexport function isValidTagType(type) {\n  return validators[type] !== undefined || simpleTags[type] !== undefined;\n}\n\n/**\n * Is the given type a \"simple tag\" (one with no actual value)\n * @param {tagType} type\n * @return {boolean}\n */\nexport function isSimpleTagType(type) {\n  return simpleTags[type] !== undefined;\n}\n\n/**\n * Validate a tag value based on its type\n * @param {string} key Tag name - some tags must have a valid name\n * @param {tagType} type The type for this tag entry\n * @param {*} value The tag data to validate matches this tag format's data structure\n * @return {boolean}\n */\nexport function isValidTag(key, type, value) {\n  if (!isValidTagType(type)) {\n    return false;\n  }\n\n  // simple tags don't need to run a validator\n  if (isSimpleTagType(type)) {\n    return true;\n  }\n\n  if (key === undefined) return false;\n\n  // run tag validator to confirm we are a valid tag\n  const validator = validators[type];\n  return (validator(key, value));\n}\n\n/**\n * Given a tag key, type, and value - parse, validate, and return the full expected tag object\n * @param {string} key Tag name - some tags must have a valid name\n * @param {tagType} type The type for this tag entry\n * @param {*} value The tag data to validate matches this tag format's data structure\n * @return {object} The tag object to use, or undefined if it isn't valid\n */\nexport function getValidTagObject(key, type, value) {\n  if (!isValidTag(key, type, value)) {\n    return undefined;\n  }\n\n  // return data structure based on tag type\n  if (isSimpleTagType(type)) {\n    return {\n      type,\n    };\n  } else {\n    return {\n      key,\n      value,\n      type,\n    };\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/tags.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 488,
    "kind": "function",
    "name": "riderHeightValidate",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~riderHeightValidate",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Validate a rider height tag. Used for min/max heights",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 489,
    "kind": "variable",
    "name": "simpleTags",
    "memberof": "lib/parks/tags.js",
    "static": true,
    "longname": "lib/parks/tags.js~simpleTags",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Simple tags that don't have a value entry.<br />Instead, these tags are either present or not.",
    "lineNumber": 28,
    "type": {
      "types": [
        "{\"undefined\": boolean}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 490,
    "kind": "variable",
    "name": "validators",
    "memberof": "lib/parks/tags.js",
    "static": true,
    "longname": "lib/parks/tags.js~validators",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Each tag type must have a validator function to confirm the incoming tag value is correct",
    "lineNumber": 40,
    "type": {
      "types": [
        "{\"undefined\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 491,
    "kind": "function",
    "name": "validateObjectContainsOnlyGivenKeys",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~validateObjectContainsOnlyGivenKeys",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Given an object, validate that it only contains the given keys<br />Will return false if the object is missing any keys, or has additional keys not listed",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 492,
    "kind": "function",
    "name": "isValidTagType",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~isValidTagType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": "{isValidTagType}",
    "description": "Is the supplied tag type supported?",
    "lineNumber": 97,
    "params": [
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 493,
    "kind": "function",
    "name": "isSimpleTagType",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~isSimpleTagType",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": "{isSimpleTagType}",
    "description": "Is the given type a \"simple tag\" (one with no actual value)",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 494,
    "kind": "function",
    "name": "isValidTag",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~isValidTag",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": "{isValidTag}",
    "description": "Validate a tag value based on its type",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Tag name - some tags must have a valid name"
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type for this tag entry"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The tag data to validate matches this tag format's data structure"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 495,
    "kind": "function",
    "name": "getValidTagObject",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~getValidTagObject",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tags.js",
    "importStyle": "{getValidTagObject}",
    "description": "Given a tag key, type, and value - parse, validate, and return the full expected tag object",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Tag name - some tags must have a valid name"
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type for this tag entry"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The tag data to validate matches this tag format's data structure"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The tag object to use, or undefined if it isn't valid"
    }
  },
  {
    "__docId__": 496,
    "kind": "file",
    "name": "lib/parks/tdr/tokyodisneyresort.js",
    "content": "import {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\nimport moment from 'moment-timezone';\nimport Destination from '../destination.js';\nimport sift from 'sift';\n\nconst parkData = {\n  tdl: {\n    name: 'Tokyo Disneyland',\n    slug: 'tokyodisneyland',\n  },\n  tds: {\n    name: 'Tokyo DisneySea',\n    slug: 'tokyodisneysea',\n  },\n};\n\n/**\n * TokyoDisneyResortPark Object\n */\nexport class TokyoDisneyResort extends Destination {\n  /**\n   * Create a new TokyoDisneyResortPark object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Tokyo Disney Resort';\n    options.timezone = options.timezone || 'Asia/Tokyo';\n\n    options.apiKey = options.apiKey || '';\n    options.apiAuth = options.apiAuth || '';\n    options.apiOS = options.apiOS || '';\n    options.apiBase = options.apiBase || '';\n    options.apiVersion = options.apiVersion || '';\n    options.parkIds = options.parkIds || ['tdl', 'tds'];\n\n    // any custom environment variable prefixes we want to use for this park (optional)\n    options.configPrefixes = ['TDR'].concat(options.configPrefixes || []);\n\n    super(options);\n\n    if (!this.config.apiKey) throw new Error('Missing TDR apiKey');\n    if (!this.config.apiAuth) throw new Error('Missing TDR apiAuth');\n    if (!this.config.apiOS) throw new Error('Missing TDR apiOS');\n    if (!this.config.apiBase) throw new Error('Missing TDR apiBase');\n    if (!this.config.apiVersion) throw new Error('Missing TDR apiVersion');\n    if (!this.config.parkIds) throw new Error('Missing TDR parkIds');\n\n    // some convenience strings\n    // TODO\n    // this.config.parkIdLower = this.config.parkId.toLowerCase();\n    // this.config.parkIdUpper = this.config.parkId.toUpperCase();\n\n    this.http.injectForDomain({\n      hostname: new URL(this.config.apiBase).hostname,\n    }, async (method, url, data, options) => {\n      const appVersion = (await this.fetchLatestVersion()) || this.config.apiVersion;\n\n      options.headers['user-agent'] = `TokyoDisneyResortApp/${appVersion} Android/${this.config.apiOS}`;\n      options.headers['x-api-key'] = this.config.apiKey;\n      options.headers['X-PORTAL-LANGUAGE'] = 'en-US';\n      options.headers['X-PORTAL-OS-VERSION'] = `Android ${this.config.apiOS}`;\n      options.headers['X-PORTAL-APP-VERSION'] = appVersion;\n      options.headers['X-PORTAL-DEVICE-NAME'] = 'OnePlus5';\n      options.headers.connection = 'keep-alive';\n      options.headers['Accept-Encoding'] = 'gzip';\n      options.headers.Accept = 'application/json';\n      options.headers['Content-Type'] = 'application/json';\n\n      if (!options.ignoreDeviceID) {\n        const deviceID = await this.fetchDeviceID();\n        options.headers['X-PORTAL-DEVICE-ID'] = deviceID;\n        options.headers['X-PORTAL-AUTH'] = this.config.apiAuth;\n      }\n\n      // we handle auth/500 errors ourselves for TDR\n      options.ignoreErrors = true;\n    });\n\n    this.http.injectForDomainResponse({\n      hostname: new URL(this.config.apiBase).hostname,\n    }, async (resp) => {\n      if (resp.statusCode === 400) {\n        console.log('TDR version invalid, fetch again...');\n        // force a store version update if we get a 400 error\n        await this.cache.set('tdr_appversion', undefined, -1);\n        return undefined;\n      }\n\n      if (resp.statusCode === 503) {\n        const maintenance = resp.body.errors.find((x) => x.code === 'error.systemMaintenance');\n        if (maintenance) {\n          // down for maintenance!\n          const now = this.getTimeNowMoment();\n          if (now.isBetween(maintenance.startAt, maintenance.endAt)) {\n            const endsIn = now.diff(maintenance.endAt, 'minutes');\n            this.log(`Tokyo Disney Resort API in maintenance. Ends in ${Math.abs(endsIn)} minutes`);\n            // return original response to avoid refetching again and again and again\n            return resp;\n          }\n        } else {\n          this.emit('error', new Error(`Invalid response from TDR ${JSON.stringify(resp.body)}`));\n        }\n      }\n\n      return resp;\n    });\n  }\n\n  /**\n   * Fetch the current app version on the Google Play store\n   * @return {string}\n   */\n  async fetchLatestVersion() {\n    // cache 2 hours\n    '@cache|120';\n    // use the themeparks.wiki appstore watcher API\n    const resp = await this.http(\n      'GET',\n      'https://appwatch.themeparks.wiki/latest/jp.tokyodisneyresort.portalapp',\n      {},\n    );\n    return resp.body.version;\n  }\n\n  /**\n   * Return or fetch a device ID to use for API calls\n   */\n  async fetchDeviceID() {\n    // cache 2 weeks\n    '@cache|20160';\n    const resp = await this.http(\n      'POST',\n      `${this.config.apiBase}/rest/v1/devices`,\n      undefined,\n      {\n        ignoreDeviceID: true,\n      },\n    );\n\n    return resp.body.deviceId;\n  }\n\n  /**\n   * Get the latest facilities data for the entire resort\n   */\n  async fetchAllFacilitiesData() {\n    // cache 2 hours\n    '@cache|120';\n    const headers = {};\n    const lastModifiedTime = await this.cache.get('tdr_facilities_last_modified');\n    if (lastModifiedTime !== undefined) {\n      headers['If-Modified-Since'] = lastModifiedTime;\n    }\n\n    const resp = await this.http('GET', `${this.config.apiBase}/rest/v2/facilities`, undefined, {\n      headers,\n    });\n\n    // store in a separate long-term cache so we can keep using it if the server data hasn't changed\n    if (resp.statusCode !== 304) {\n      // transform data into an array with \"facilityType\", rather than a nested object\n      const data = [];\n      Object.keys(resp.body).forEach((key) => {\n        resp.body[key].forEach((x) => {\n          data.push({\n            facilityType: key,\n            ...x,\n          });\n        });\n      });\n\n      await this.cache.set('tdr_facilities_data', data, Number.MAX_SAFE_INTEGER);\n      await this.cache.set(\n        'tdr_facilities_last_modified',\n        resp.headers['Last-Modified'],\n        Number.MAX_SAFE_INTEGER,\n      );\n      return data;\n    }\n\n    return await this.cache.get('tdr_facilities_data');\n  }\n\n  /**\n   * Get facilities data for this park\n   */\n  async fetchFacilitiesData() {\n    // cache 5 minutes\n    '@cache|5';\n    const parkIdsUpper = this.config.parkIds.map((x) => x.toUpperCase());\n    const resortData = await this.fetchAllFacilitiesData();\n    return resortData.filter((x) => parkIdsUpper.indexOf(x.parkType) >= 0);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _buildAttractionObject(attractionID) {\n    const facilityData = await this.fetchFacilitiesData();\n    const attr = facilityData.find((x) => x.facilityCode == attractionID);\n    if (attr === undefined) return undefined;\n\n    const tags = [];\n\n    tags.push({\n      type: tagType.fastPass,\n      value: !!attr.fastpass,\n    });\n\n    tags.push({\n      type: tagType.singleRider,\n      value: !!attr.filters.find((x) => x.type === 'SINGLE_RIDER'),\n    });\n\n    const heightUppper = attr.restrictions.find((x) => x.type === 'LOWER_HEIGHT');\n    if (heightUppper !== undefined) {\n      const heightMin = /(\\d+)\\s*cm/.exec(heightUppper.name);\n      if (heightMin) {\n        tags.push({\n          key: 'minimumHeight',\n          type: tagType.minimumHeight,\n          value: {\n            unit: 'cm',\n            height: Number(heightMin[1]),\n          },\n        });\n      }\n    }\n\n    const heightLower = attr.restrictions.find((x) => x.type === 'UPPER_HEIGHT');\n    if (heightLower !== undefined) {\n      const heightMax = /(\\d+)\\s*cm/.exec(heightLower.name);\n      if (heightMax) {\n        tags.push({\n          key: 'maximumHeight',\n          type: tagType.maximumHeight,\n          value: {\n            unit: 'cm',\n            height: Number(heightMax[1]),\n          },\n        });\n      }\n    }\n\n    tags.push({\n      type: tagType.unsuitableForPregnantPeople,\n      value: attr.filters.find((x) => x === 'EXPECTANT_MOTHER') === undefined,\n    });\n\n    return {\n      name: attr.nameKana,\n      type: attr.facilityType === 'attractions' ? attractionType.ride : attractionType.other,\n      tags,\n    };\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _update() {\n    const resp = await this.http(\n      'GET',\n      `${this.config.apiBase}/rest/v4/facilities/conditions`,\n    );\n\n    const attractions = resp?.body?.attractions;\n    if (!attractions) {\n      return;\n    }\n\n    await Promise.allSettled(attractions.map(async (attr) => {\n      let status = attr.standbyTime ? statusType.operating : statusType.closed;\n      switch (attr.facilityStatus) {\n        case 'CANCEL':\n          status = statusType.closed;\n          break;\n        case 'CLOSE_NOTICE':\n          status = statusType.down;\n          break;\n        case 'OPEN':\n          status = statusType.operating;\n          break;\n      }\n\n      await this.updateAttractionState(attr.facilityCode, status);\n      await this.updateAttractionQueue(\n        attr.facilityCode,\n        status == statusType.operating ? attr.standbyTime : null,\n        queueType.standBy,\n      );\n    }));\n  }\n\n  /**\n   * Fetch the upcoming calendar\n   */\n  async fetchCalendar() {\n    // cache 12 hours\n    '@cache|720';\n    const cal = await this.http(\n      'GET',\n      `${this.config.apiBase}/rest/v1/parks/calendars`,\n    );\n\n    return cal.body;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getOperatingHoursForDate(date) {\n    const cal = await this.fetchCalendar();\n\n    if (!Array.isArray(cal)) return undefined;\n\n    const dateString = date.format('YYYY-MM-DD');\n    const targetDate = cal.find((x) => {\n      return x.parkType === this.config.parkIdUpper &&\n        x.closedDay === false &&\n        x.undecided === false &&\n        x.date === dateString;\n    });\n    if (targetDate) {\n      const hours = [];\n      const momentParseFormat = 'YYYY-MM-DDTHH:mm';\n\n      hours.push({\n        openingTime: moment.tz(\n          `${dateString}T${targetDate.openTime}`,\n          momentParseFormat,\n          this.config.timezone).format(),\n        closingTime: moment.tz(\n          `${dateString}T${targetDate.closeTime}`,\n          momentParseFormat,\n          this.config.timezone).format(),\n        type: scheduleType.operating,\n      });\n\n      // \"sp\" opening times, i.e, magic hours\n      if (targetDate.spOpenTime && targetDate.spCloseTime) {\n        hours.push({\n          openingTime: moment.tz(\n            `${dateString}T${targetDate.spOpenTime}`,\n            momentParseFormat,\n            this.config.timezone).format(),\n          closingTime: moment.tz(\n            `${dateString}T${targetDate.spCloseTime}`,\n            momentParseFormat,\n            this.config.timezone).format(),\n          type: scheduleType.extraHours,\n        });\n      }\n\n      return hours;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Fetch the restaurant operating hours\n   */\n  async fetchRestaurantOperatingHours() {\n    const resp = await this.http(\n      'GET',\n      `${this.config.apiBase}/rest/v4/facilities/conditions`,\n    );\n\n    return resp.body.restaurants.map((restaurant) => {\n      // console.log(restaurant);\n      if (!restaurant.operatings || restaurant.operatings.length === 0) {\n        return {\n          restaurantID: restaurant.facilityCode,\n          openingTime: 0,\n          closingTime: 0,\n          status: statusType.closed,\n        };\n      }\n\n      // TODO: restaurant.facilityStatus check needed?\n      const momentParseFormat = 'YYYY-MM-DDTHH:mm';\n      const schedule = restaurant.operatings[0];\n\n      return {\n        restaurantID: restaurant.facilityCode,\n        openingTime: moment.tz(\n          schedule.startAt,\n          momentParseFormat,\n          this.config.timezone).format(),\n        closingTime: moment.tz(\n          schedule.endAt,\n          momentParseFormat,\n          this.config.timezone).format(),\n        status: statusType.operating,\n      };\n    });\n  }\n\n  /**\n     * Return restaurant operating hours for the supplied date\n     * @param {moment} date\n     */\n  async _getRestaurantOperatingHoursForDate(date) {\n    const cal = await this.fetchRestaurantOperatingHours();\n    if (!cal) return undefined;\n    return cal;\n  }\n\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data\n   * @return {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    entity.name = data?.name;\n    if (data?.parkType) {\n      entity._parkId = data.parkType.toLowerCase();\n      entity._parentId = data.parkType.toLowerCase();\n    }\n\n    if (data?.latitude) {\n      entity.location = {\n        longitude: Number(data.longitude),\n        latitude: Number(data.latitude),\n      };\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    return {\n      ...this.buildBaseEntityObject(),\n      _id: 'tdr',\n      slug: 'tokyodisneyresort',\n      name: this.config.name,\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    return this.config.parkIds.map((x) => {\n      return {\n        ...this.buildBaseEntityObject(null),\n        _id: x,\n        _destinationId: 'tdr',\n        _parentId: 'tdr',\n        entityType: entityType.park,\n        ...parkData[x],\n      };\n    });\n  }\n\n  /**\n   * Return an array of entities given a filter function (sift-style)\n   * @param {function} filterFn\n   * @return {array<entity>}\n   */\n  async getEntitiesOfType(filterFn) {\n    const poiData = await this.fetchFacilitiesData();\n\n    return poiData.filter(sift(filterFn)).map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        _id: `${x.facilityCode}`,\n        _destinationId: 'tdr',\n        entityType: entityType.attraction,\n        attractionType: attractionType.ride,\n      };\n    });\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    return this.getEntitiesOfType((x) => {\n      // look for attractions that aren't a \"dummy\" entry\n      //  ignore photoMapFlgs, unless facility has any hints the photoMapFlg tag is set incorrectly (i.e, Splash Mountain)\n      return x.facilityType === 'attractions' && !x.dummyFacility && (!x.photoMapFlg || (x.filters && x.filters.indexOf('THRILL') >= 0) || !!x.fastPass);\n    });\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    return this.getEntitiesOfType((x) => {\n      return x.facilityType === 'entertainments' && !x.dummyFacility && !x.photoMapFlg;\n    });\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    return [];\n  }\n\n  /**\n   * Fetch live wait time data\n   * @return {array<data>}\n   */\n  async _fetchWaitTimes() {\n    '@cache|1';\n    const resp = await this.http(\n      'GET',\n      `${this.config.apiBase}/rest/v4/facilities/conditions`,\n    );\n\n    const attractions = resp?.body?.attractions;\n    return attractions;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const waitTimes = await this._fetchWaitTimes();\n\n    const livedata = [];\n    for (let i = 0; i < waitTimes.length; i++) {\n      const attr = waitTimes[i];\n      const live = {\n        _id: attr.facilityCode,\n        status: attr.standbyTime ? statusType.operating : statusType.closed,\n      };\n\n      switch (attr.facilityStatus) {\n        case 'CANCEL':\n          live.status = statusType.closed;\n          break;\n        case 'CLOSE_NOTICE':\n          live.status = statusType.down;\n          break;\n        case 'OPEN':\n          live.status = statusType.operating;\n          break;\n      }\n\n      live.queue = {\n        [queueType.standBy]: {\n          waitTime: live.status == statusType.operating ? attr.standbyTime : null,\n        },\n      };\n\n      livedata.push(live);\n    }\n\n    return livedata;\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @return {array<object>}\n   */\n  async buildEntityScheduleData() {\n    const cal = await this.fetchCalendar();\n\n    if (!Array.isArray(cal)) return undefined;\n\n    const parksUpper = this.config.parkIds.map((x) => x.toUpperCase());\n    const momentParseFormat = 'YYYY-MM-DDTHH:mm';\n\n    const schedules = this.config.parkIds.map((x) => {\n      return {\n        _id: x,\n        schedule: [],\n      };\n    });\n\n    cal.forEach((entry) => {\n      // skip if not for a park\n      if (parksUpper.indexOf(entry.parkType) < 0) return;\n      // skip if a closed or \"undecided\" (?!) schedule day\n      if (entry.undecided || entry.closedDay) return;\n\n      const scheduleObj = schedules.find((x) => x._id === entry.parkType.toLowerCase());\n\n      scheduleObj.schedule.push({\n        date: entry.date,\n        openingTime: moment.tz(\n          `${entry.date}T${entry.openTime}`,\n          momentParseFormat,\n          this.config.timezone).format(),\n        closingTime: moment.tz(\n          `${entry.date}T${entry.closeTime}`,\n          momentParseFormat,\n          this.config.timezone).format(),\n        type: scheduleType.operating,\n      });\n\n      // \"sp\" opening times, i.e, magic hours\n      if (entry.spOpenTime && entry.spCloseTime) {\n        scheduleObj.schedule.push({\n          date: entry.date,\n          openingTime: moment.tz(\n            `${entry.date}T${entry.spOpenTime}`,\n            momentParseFormat,\n            this.config.timezone).format(),\n          closingTime: moment.tz(\n            `${entry.date}T${entry.spCloseTime}`,\n            momentParseFormat,\n            this.config.timezone).format(),\n          type: scheduleType.extraHours,\n          description: 'Special Hours',\n        });\n      }\n    });\n\n    return schedules;\n  }\n}\n\nexport default TokyoDisneyResort;\n\n/*\nexport class TokyoDisneyland extends TokyoDisneyResortPark {\n  constructor(options = {}) {\n    options.name = 'Tokyo Disney Resort - Tokyo Disneyland';\n    options.parkId = 'tdl';\n\n    super(options);\n  }\n}\n\nexport class TokyoDisneySea extends TokyoDisneyResortPark {\n  constructor(options = {}) {\n    options.name = 'Tokyo Disney Resort - Tokyo DisneySea';\n    options.parkId = 'tds';\n\n    super(options);\n  }\n}\n*/\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/tdr/tokyodisneyresort.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 497,
    "kind": "variable",
    "name": "parkData",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js",
    "static": true,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~parkData",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/tdr/tokyodisneyresort.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "{\"tdl\": *, \"tds\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 498,
    "kind": "class",
    "name": "TokyoDisneyResort",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js",
    "static": true,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/tdr/tokyodisneyresort.js",
    "importStyle": "{TokyoDisneyResort}",
    "description": "TokyoDisneyResortPark Object",
    "lineNumber": 20,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 499,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#constructor",
    "access": "public",
    "description": "Create a new TokyoDisneyResortPark object",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 500,
    "kind": "method",
    "name": "fetchLatestVersion",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#fetchLatestVersion",
    "access": "public",
    "description": "Fetch the current app version on the Google Play store",
    "lineNumber": 113,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 501,
    "kind": "method",
    "name": "fetchDeviceID",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#fetchDeviceID",
    "access": "public",
    "description": "Return or fetch a device ID to use for API calls",
    "lineNumber": 128,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 502,
    "kind": "method",
    "name": "fetchAllFacilitiesData",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#fetchAllFacilitiesData",
    "access": "public",
    "description": "Get the latest facilities data for the entire resort",
    "lineNumber": 146,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 503,
    "kind": "method",
    "name": "fetchFacilitiesData",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#fetchFacilitiesData",
    "access": "public",
    "description": "Get facilities data for this park",
    "lineNumber": 187,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 504,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#_buildAttractionObject",
    "access": "private",
    "description": "",
    "lineNumber": 198,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "attractionID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"name\": *, \"type\": *, \"tags\": *}"
      ]
    }
  },
  {
    "__docId__": 505,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#_update",
    "access": "private",
    "description": "",
    "lineNumber": 260,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 506,
    "kind": "method",
    "name": "fetchCalendar",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#fetchCalendar",
    "access": "public",
    "description": "Fetch the upcoming calendar",
    "lineNumber": 297,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 507,
    "kind": "method",
    "name": "_getOperatingHoursForDate",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#_getOperatingHoursForDate",
    "access": "private",
    "description": "",
    "lineNumber": 311,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 508,
    "kind": "method",
    "name": "fetchRestaurantOperatingHours",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#fetchRestaurantOperatingHours",
    "access": "public",
    "description": "Fetch the restaurant operating hours",
    "lineNumber": 363,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 509,
    "kind": "method",
    "name": "_getRestaurantOperatingHoursForDate",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#_getRestaurantOperatingHoursForDate",
    "access": "private",
    "description": "Return restaurant operating hours for the supplied date",
    "lineNumber": 403,
    "params": [
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 510,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 416,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 511,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 438,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": string, \"slug\": string, \"name\": *, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 512,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 451,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 513,
    "kind": "method",
    "name": "getEntitiesOfType",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#getEntitiesOfType",
    "access": "public",
    "description": "Return an array of entities given a filter function (sift-style)",
    "lineNumber": 469,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "filterFn",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<entity>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 514,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 486,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 515,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 497,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 516,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 506,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 517,
    "kind": "method",
    "name": "_fetchWaitTimes",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#_fetchWaitTimes",
    "access": "private",
    "description": "Fetch live wait time data",
    "lineNumber": 514,
    "return": {
      "nullable": null,
      "types": [
        "array<data>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 518,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 528,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 519,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/tdr/tokyodisneyresort.js~TokyoDisneyResort#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 568,
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 520,
    "kind": "file",
    "name": "lib/parks/te2/te2.js",
    "content": "// te2.io / te2.biz interface\n\nimport {Destination} from '../destination.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\nimport {URL} from 'url';\n\nexport class TE2Destination extends Destination {\n  constructor(options = {}) {\n    // venue ID\n    options.destinationId = options.destinationId || '';\n    options.venueId = options.venueId || '';\n    options.subdomain = options.subdomain || 'cf';\n    options.apidomain = options.apidomain || 'te2.biz';\n    options.apiuser = options.apiuser || '';\n    options.apipass = options.apipass || '';\n    options.rideTypes = options.rideTypes || ['Ride', 'Coasters', 'Family', 'ThrillRides', 'Kids', 'Rides & Attractions'];\n    options.diningTypes = options.diningTypes || ['Snacks', 'wpDining', 'Meals', 'Dining'];\n\n    options.configPrefixes = ['TE2'];\n\n    super(options);\n\n    if (!this.config.destinationId) throw new Error('Missing destinationId');\n    if (!this.config.venueId) throw new Error('Missing venueId');\n    if (!this.config.subdomain) throw new Error('Missing subdomain');\n    if (!this.config.apidomain) throw new Error('Missing apidomain');\n    if (!this.config.apiuser) throw new Error('Missing apiuser');\n    if (!this.config.apipass) throw new Error('Missing apipass');\n    if (!this.config.rideTypes) throw new Error('Missing rideTypes');\n\n    // construct our destination's API base URL from the configured pieces\n    this.config.apiBase = this.config.apiBase || `https://${this.config.subdomain}.${this.config.apidomain}`;\n\n    // authenticate all our requests\n    const baseURLHostname = new URL(this.config.apiBase).hostname;\n\n    this.http.injectForDomain({\n      hostname: baseURLHostname,\n    }, async (method, url, data, options) => {\n      // extract path from url\n      const path = new URL(url).pathname;\n\n      // add core headers\n      options.headers = {\n        ...options.headers,\n        'Content-Type': 'application/json',\n      };\n\n      // use username:password credentials for /rest/ requests\n      if (path.startsWith('/rest/')) {\n        options.headers = {\n          ...options.headers,\n          Authorization: `Basic ${Buffer.from(`${this.config.apiuser}:${this.config.apipass}`).toString('base64')}`,\n        };\n      }\n    });\n  }\n\n  /**\n   * Get current POI data status\n   * @returns {array<object>}\n   */\n  async getPOIStatus() {\n    '@cache|1';\n    const resp = await this.http('GET', `${this.config.apiBase}/rest/venue/${this.config.venueId}/poi/all/status`);\n    return resp.body;\n  }\n\n  /**\n   * Get the destination data from the API (name, location, etc.)\n   * @returns {object}\n   */\n  async getDestinationData() {\n    // cache for a day\n    '@cache|1440';\n    const resp = await this.http('GET', `${this.config.apiBase}/rest/venue/${this.config.venueId}`);\n    return resp.body;\n  }\n\n  /**\n   * Get park POI data\n   * @returns {array<object>}\n   */\n  async getPOIData() {\n    // cache for a day\n    '@cache|1440';\n    const resp = await this.http('GET', `${this.config.apiBase}/rest/venue/${this.config.venueId}/poi/all`);\n    return resp.body;\n  }\n\n  /**\n   * Fetch the POI category data for this destination\n   */\n  async _fetchCategories() {\n    '@cache|1440'; // cache for a day\n    const resp = await this.http('GET', `${this.config.apiBase}/rest/app/${this.config.venueId}/displayCategories`);\n    return resp.body;\n  }\n\n  /**\n   * Get categories from API based on the configured initial types\n   * @param {object} params\n   * @param {array<string>} params.initialTypes\n   * @returns {object} - {types: {string: string}, entities: {string: string}}\n   */\n  async _getParsedCategories({initialTypes}) {\n    const types = [].concat(...initialTypes);\n    // some categories just list the POIs that belong to it\n    const entities = [];\n\n    const categoryData = await this._fetchCategories();\n\n    categoryData.categories.forEach((cat) => {\n      if (types.indexOf(cat.label) >= 0) {\n        if (types.indexOf(cat.id) < 0) {\n          types.push(cat.id);\n        }\n        if (cat.poi) {\n          entities.push(...cat.poi);\n        }\n      }\n      if (cat.parent && types.indexOf(cat.parent) >= 0) {\n        if (types.indexOf(cat.id) < 0) {\n          types.push(cat.id);\n        }\n        if (cat.poi) {\n          entities.push(...cat.poi);\n        }\n      }\n    });\n\n    return {\n      types,\n      entities: entities.filter((x, idx) => {\n        // remove duplicates\n        return entities.indexOf(x) === idx;\n      }),\n    };\n  }\n\n  /**\n   * Get the type IDs for this destination's attractions\n   */\n  async getAttractionTypes() {\n    return await this._getParsedCategories({\n      initialTypes: this.config.rideTypes,\n    });\n  }\n\n  /**\n   * Get the type IDs for this destination's dining\n   */\n  async getDiningTypes() {\n    return await this._getParsedCategories({\n      initialTypes: this.config.diningTypes,\n    });\n  }\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data \n   * @returns {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    if (data) {\n      // name\n      entity.name = data.name || data.label;\n\n      entity._id = data.id || undefined;\n\n      // entity location\n      if (data.location) {\n        if (data.location.lon) {\n          entity.location = {\n            longitude: data.location.lon,\n            latitude: data.location.lat,\n          };\n        }\n        if (data.location.center?.lon) {\n          entity.location = {\n            longitude: data.location.center.lon,\n            latitude: data.location.center.lat,\n          };\n        }\n      }\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    const destinationData = await this.getDestinationData();\n    return {\n      ...this.buildBaseEntityObject(destinationData),\n      _id: `${this.config.destinationId}_destination`,\n      slug: this.config.destinationId,\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    const destinationData = await this.getDestinationData();\n    return [\n      {\n        ...this.buildBaseEntityObject(destinationData),\n        _id: this.config.destinationId,\n        _destinationId: `${this.config.destinationId}_destination`,\n        _parentId: `${this.config.destinationId}_destination`,\n        slug: `${this.config.destinationId}park`,\n        entityType: entityType.park,\n      }\n    ];\n  }\n\n  async _getFilteredEntities({types, entities}, data) {\n    const poi = await this.getPOIData();\n    return poi.filter((entry) => {\n      // filter by rideTypes\n      return types.indexOf(entry.type) >= 0 || entities.indexOf(entry.id) >= 0;\n    }).map((entry) => {\n      // build the entity\n      return {\n        ...this.buildBaseEntityObject(entry),\n        _destinationId: `${this.config.destinationId}_destination`,\n        _parentId: this.config.destinationId,\n        _parkId: this.config.destinationId,\n        ...data,\n      };\n    });\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    return await this._getFilteredEntities(\n      {\n        ...await this.getAttractionTypes(),\n      },\n      {\n        entityType: entityType.attraction,\n        attractionType: attractionType.ride,\n      }\n    );\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    return [];\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    return await this._getFilteredEntities(\n      {\n        ...await this.getDiningTypes(),\n      },\n      {\n        entityType: entityType.restaurant,\n      }\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const statusData = await this.getPOIStatus();\n\n    return statusData.map((entry) => {\n      if (!entry.status || !entry.id) return null;\n\n      if (entry.id.indexOf('_STANDING_OFFER_BEACON') >= 0) {\n        return null;\n      }\n\n      const liveData = {\n        _id: entry.id,\n        status: statusType.closed,\n      };\n\n      if (!!entry.status.isOpen) {\n        liveData.status = statusType.operating;\n      }\n\n      if (entry.status.waitTime !== undefined) {\n        liveData.queue = {\n          [queueType.standBy]: {\n            waitTime: entry.status.waitTime,\n          },\n        };\n      }\n\n      return liveData;\n    }).filter((x) => !!x);\n  }\n\n  /**\n   * Get schedule data for this destination, with an optional number of days to fetch\n   * @param {object} [options]\n   * @param {number} [options.days] Number of days to fetch\n   * @returns {array<object>}\n   */\n  async _fetchScheduleData({days = 120} = {}) {\n    '@cache|1440'; // cache for a day\n    const resp = await this.http('GET', `${this.config.apiBase}/v2/venues/${this.config.venueId}/venue-hours?days=${days}`);\n    return resp.body;\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    const scheduleData = await this._fetchScheduleData();\n\n    const schedules = [];\n    scheduleData.days.forEach((x) => {\n      x.hours.forEach((hours) => {\n        if (x.label !== 'Park' && hours.status === 'CLOSED') return;\n\n        schedules.push({\n          date: x.date,\n          type: hours.label === 'Park' ? \"OPERATING\" : \"INFO\",\n          description: hours.label === 'Park' ? undefined : hours.label,\n          // bless you, API developer, for having the dates in a normal format\n          openingTime: hours.schedule.start,\n          closingTime: hours.schedule.end,\n        });\n      });\n    });\n\n    return [\n      {\n        _id: this.config.destinationId,\n        schedule: schedules,\n      }\n    ];\n  }\n}\n\nexport class CedarPoint extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/New_York';\n    options.venueId = 'CF_CP';\n    options.destinationId = 'cedarpoint';\n\n    super(options);\n  }\n}\n\nexport class KnottsBerryFarm extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/Los_Angeles';\n    options.venueId = 'CF_KBF';\n    options.destinationId = 'knottsberryfarm';\n\n    super(options);\n  }\n}\n\nexport class CaliforniasGreatAmerica extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/Los_Angeles';\n    options.venueId = 'CF_GA';\n    options.destinationId = 'californiasgreatamerica';\n\n    super(options);\n  }\n}\n\nexport class CanadasWonderland extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/Toronto';\n    options.venueId = 'CF_CW';\n    options.destinationId = 'canadaswonderland';\n\n    super(options);\n  }\n}\n\nexport class Carowinds extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/New_York';\n    options.venueId = 'CF_CA';\n    options.destinationId = 'carowinds';\n\n    super(options);\n  }\n}\n\nexport class KingsIsland extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/New_York';\n    options.venueId = 'CF_KI';\n    options.destinationId = 'kingsisland';\n\n    super(options);\n  }\n}\n\nexport class DorneyPark extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/New_York';\n    options.venueId = 'CF_DP';\n    options.destinationId = 'dorneypark';\n\n    super(options);\n  }\n}\n\nexport class KingsDominion extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/New_York';\n    options.venueId = 'CF_KD';\n    options.destinationId = 'kingsdominion';\n\n    super(options);\n  }\n}\n\nexport class MichigansAdventure extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/Detroit';\n    options.venueId = 'CF_MA';\n    options.destinationId = 'michigansadventure';\n\n    super(options);\n  }\n}\n\nexport class ValleyFair extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/Chicago';\n    options.venueId = 'CF_VF';\n    options.destinationId = 'valleyfair';\n\n    super(options);\n  }\n}\n\nexport class WorldsOfFun extends TE2Destination {\n  constructor(options = {}) {\n    options.timezone = 'America/Chicago';\n    options.venueId = 'CF_WF';\n    options.destinationId = 'worldsoffun';\n\n    super(options);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/te2/te2.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 521,
    "kind": "class",
    "name": "TE2Destination",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~TE2Destination",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{TE2Destination}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 522,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true
  },
  {
    "__docId__": 523,
    "kind": "method",
    "name": "getPOIStatus",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#getPOIStatus",
    "access": "public",
    "description": "Get current POI data status",
    "lineNumber": 63,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 524,
    "kind": "method",
    "name": "getDestinationData",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#getDestinationData",
    "access": "public",
    "description": "Get the destination data from the API (name, location, etc.)",
    "lineNumber": 73,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 525,
    "kind": "method",
    "name": "getPOIData",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#getPOIData",
    "access": "public",
    "description": "Get park POI data",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 526,
    "kind": "method",
    "name": "_fetchCategories",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#_fetchCategories",
    "access": "private",
    "description": "Fetch the POI category data for this destination",
    "lineNumber": 94,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 527,
    "kind": "method",
    "name": "_getParsedCategories",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#_getParsedCategories",
    "access": "private",
    "description": "Get categories from API based on the configured initial types",
    "lineNumber": 106,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object} - {types: {string: string}, entities: {string: string}}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "params.initialTypes",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "{types: {string: string}, entities: {string: string}}"
    }
  },
  {
    "__docId__": 528,
    "kind": "method",
    "name": "getAttractionTypes",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#getAttractionTypes",
    "access": "public",
    "description": "Get the type IDs for this destination's attractions",
    "lineNumber": 144,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 529,
    "kind": "method",
    "name": "getDiningTypes",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#getDiningTypes",
    "access": "public",
    "description": "Get the type IDs for this destination's dining",
    "lineNumber": 153,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 530,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 165,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 531,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 197,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": *, \"slug\": *, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 532,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 210,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 533,
    "kind": "method",
    "name": "_getFilteredEntities",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#_getFilteredEntities",
    "access": "private",
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"types\": *, \"entities\": *}"
        ],
        "defaultRaw": {
          "types": null,
          "entities": null
        },
        "defaultValue": "{\"types\":null,\"entities\":null}"
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 534,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 244,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 535,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 259,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 536,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 266,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 537,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 280,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 538,
    "kind": "method",
    "name": "_fetchScheduleData",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#_fetchScheduleData",
    "access": "private",
    "description": "Get schedule data for this destination, with an optional number of days to fetch",
    "lineNumber": 317,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "options.days",
        "description": "Number of days to fetch"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 539,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/te2/te2.js~TE2Destination",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/te2/te2.js~TE2Destination#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 328,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 540,
    "kind": "class",
    "name": "CedarPoint",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~CedarPoint",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{CedarPoint}",
    "description": null,
    "lineNumber": 356,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 541,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~CedarPoint",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~CedarPoint#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 357,
    "undocument": true
  },
  {
    "__docId__": 542,
    "kind": "class",
    "name": "KnottsBerryFarm",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~KnottsBerryFarm",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{KnottsBerryFarm}",
    "description": null,
    "lineNumber": 366,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 543,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~KnottsBerryFarm",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~KnottsBerryFarm#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 367,
    "undocument": true
  },
  {
    "__docId__": 544,
    "kind": "class",
    "name": "CaliforniasGreatAmerica",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~CaliforniasGreatAmerica",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{CaliforniasGreatAmerica}",
    "description": null,
    "lineNumber": 376,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 545,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~CaliforniasGreatAmerica",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~CaliforniasGreatAmerica#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 377,
    "undocument": true
  },
  {
    "__docId__": 546,
    "kind": "class",
    "name": "CanadasWonderland",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~CanadasWonderland",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{CanadasWonderland}",
    "description": null,
    "lineNumber": 386,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 547,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~CanadasWonderland",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~CanadasWonderland#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 387,
    "undocument": true
  },
  {
    "__docId__": 548,
    "kind": "class",
    "name": "Carowinds",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~Carowinds",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{Carowinds}",
    "description": null,
    "lineNumber": 396,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 549,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~Carowinds",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~Carowinds#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 397,
    "undocument": true
  },
  {
    "__docId__": 550,
    "kind": "class",
    "name": "KingsIsland",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~KingsIsland",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{KingsIsland}",
    "description": null,
    "lineNumber": 406,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 551,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~KingsIsland",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~KingsIsland#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 407,
    "undocument": true
  },
  {
    "__docId__": 552,
    "kind": "class",
    "name": "DorneyPark",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~DorneyPark",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{DorneyPark}",
    "description": null,
    "lineNumber": 416,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 553,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~DorneyPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~DorneyPark#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 417,
    "undocument": true
  },
  {
    "__docId__": 554,
    "kind": "class",
    "name": "KingsDominion",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~KingsDominion",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{KingsDominion}",
    "description": null,
    "lineNumber": 426,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 555,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~KingsDominion",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~KingsDominion#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 427,
    "undocument": true
  },
  {
    "__docId__": 556,
    "kind": "class",
    "name": "MichigansAdventure",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~MichigansAdventure",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{MichigansAdventure}",
    "description": null,
    "lineNumber": 436,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 557,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~MichigansAdventure",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~MichigansAdventure#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 437,
    "undocument": true
  },
  {
    "__docId__": 558,
    "kind": "class",
    "name": "ValleyFair",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~ValleyFair",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{ValleyFair}",
    "description": null,
    "lineNumber": 446,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 559,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~ValleyFair",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~ValleyFair#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 447,
    "undocument": true
  },
  {
    "__docId__": 560,
    "kind": "class",
    "name": "WorldsOfFun",
    "memberof": "lib/parks/te2/te2.js",
    "static": true,
    "longname": "lib/parks/te2/te2.js~WorldsOfFun",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/te2/te2.js",
    "importStyle": "{WorldsOfFun}",
    "description": null,
    "lineNumber": 456,
    "undocument": true,
    "interface": false,
    "extends": [
      "TE2Destination"
    ]
  },
  {
    "__docId__": 561,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/te2/te2.js~WorldsOfFun",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/te2/te2.js~WorldsOfFun#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 457,
    "undocument": true
  },
  {
    "__docId__": 562,
    "kind": "file",
    "name": "lib/parks/toverland/toverland.js",
    "content": "import moment from 'moment';\nimport {Destination} from '../destination.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, entityType} from '../parkTypes.js';\n\nexport class Toverland extends Destination {\n  constructor(options = {}) {\n    options.timezone = options.timezone || 'Europe/Amsterdam';\n\n    options.name = options.name || 'Attractiepark Toverland';\n    options.apiBase = options.apiBase || '';\n    options.calendarUrl = options.calendarUrl || '';\n    options.authToken = options.authToken || '';\n    options.languages = options.languages || ['en', 'nl', 'de'];\n\n    super(options);\n\n    if (!this.config.apiBase) throw new Error('Missing apiBase');\n    if (!this.config.authToken) throw new Error('Missing authToken');\n    if (!this.config.calendarUrl) throw new Error('Missing calendarUrl');\n\n    // add our auth token into any API requests\n    const baseURLHostname = new URL(this.config.apiBase).hostname;\n    this.http.injectForDomain({\n      hostname: baseURLHostname,\n    }, async (method, url, data, options) => {\n      options.headers = {\n        ...(options.headers || {}),\n        // inject auth token\n        'authorization': `Bearer ${this.config.authToken}`,\n      };\n    });\n  }\n\n  /**\n   * Fetch Toverland ride live data and names etc.\n   * These are in the same endpoint\n   */\n  async fetchRideData() {\n    '@cache|1'; // cache for 1 minute\n    const response = await this.http('GET', `${this.config.apiBase}park/ride/operationInfo/list`);\n    return response.body;\n  }\n\n  /**\n   * Fetch Toverland show data\n   */\n  async fetchShowData() {\n    '@cache|240'; // cache for 4 hours\n    const response = await this.http('GET', `${this.config.apiBase}park/show/operationInfo/list`);\n    return response.body;\n  }\n\n  /**\n   * Fetch Toverland dining data\n   */\n  async fetchDiningData() {\n    '@cache|480'; // cache for 8 hours\n    const response = await this.http('GET', `${this.config.apiBase}park/foodAndDrinks/operationInfo/list`);\n    return response.body;\n  }\n\n  /**\n   * Helper function to get a preferred translation of a string or object\n   * @param {object|string} obj \n   */\n  getLocString(obj) {\n    if (typeof obj === 'object') {\n      // look for localised strings in order of the languages in config\n      const lang = this.config.languages.find((x) => {\n        return !!obj[lang];\n      });\n      if (lang) return obj[lang];\n\n      // if failed, return first language found\n      return obj[Object.keys(obj)[0]];\n    }\n    return obj;\n  }\n\n  /**\n   * Helper function to build a basic entity document\n   * Useful to avoid copy/pasting\n   * @param {object} data \n   * @returns {object}\n   */\n  buildBaseEntityObject(data) {\n    const entity = Destination.prototype.buildBaseEntityObject.call(this, data);\n\n    if (data.id) {\n      entity._id = `${data.id}`;\n    }\n\n    if (data.name) {\n      entity.name = this.getLocString(data.name);\n    }\n\n    if (data.longitude && data.latitude) {\n      entity.location = {\n        longitude: Number(data.longitude),\n        latitude: Number(data.latitude),\n      };\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this destination\n   */\n  async buildDestinationEntity() {\n    return {\n      ...this.buildBaseEntityObject({}),\n      _id: 'toverlandresort',\n      slug: 'toverlandresort',\n      name: this.config.name,\n      entityType: entityType.destination,\n    };\n  }\n\n  /**\n   * Build the park entities for this destination\n   */\n  async buildParkEntities() {\n    return [\n      {\n        ...this.buildBaseEntityObject({}),\n        _id: 'toverland',\n        _destinationId: 'toverlandresort',\n        _parentId: 'toverlandresort',\n        name: this.config.name,\n        slug: 'toverland',\n        entityType: entityType.park,\n      }\n    ];\n  }\n\n  async _buildEntityList(fetchFn, attributes = {}, id_prefix = '') {\n    const rides = await fetchFn();\n    return rides.map((x) => {\n      return {\n        ...this.buildBaseEntityObject({\n          ...x,\n          id: `${id_prefix}${x.id}`,\n        }),\n        _parentId: 'toverland',\n        _destinationId: 'toverlandresort',\n        _parkId: 'toverland',\n        ...attributes,\n      };\n    });\n  }\n\n  /**\n   * Build the attraction entities for this destination\n   */\n  async buildAttractionEntities() {\n    return await this._buildEntityList(this.fetchRideData.bind(this), {\n      entityType: entityType.attraction,\n      attractionType: attractionType.ride,\n    });\n  }\n\n  /**\n   * Build the show entities for this destination\n   */\n  async buildShowEntities() {\n    return await this._buildEntityList(this.fetchShowData.bind(this), {\n      entityType: entityType.show,\n    }, 'show_');\n  }\n\n  /**\n   * Build the restaurant entities for this destination\n   */\n  async buildRestaurantEntities() {\n    return await this._buildEntityList(this.fetchDiningData.bind(this), {\n      entityType: entityType.restaurant,\n    }, 'dining_');\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    const rides = await this.fetchRideData();\n    return rides.map((x) => {\n      const status = x?.last_status?.status?.name?.en;\n      if (!status) return null;\n\n      // other statuses include \"Variable schedule\", which we will leave as \"operating\"\n      let rideStatus = statusType.operating;\n      if (status.startsWith('Closed')) {\n        rideStatus = statusType.closed;\n      } else if (status.startsWith('Open')) {\n        rideStatus = statusType.operating;\n      } else if (status.startsWith('Maintenance')) {\n        rideStatus = statusType.refurbishment;\n      }\n\n      const waitTime = x?.last_waiting_time?.waiting_time;\n      if (waitTime === undefined) return null;\n\n      return {\n        _id: `${x.id}`,\n        status: rideStatus,\n        queue: {\n          [queueType.standBy]: {\n            waitTime: Number(waitTime),\n          }\n        }\n      };\n    }).filter((x) => !!x);\n  }\n\n  /**\n   * Fetch a week of calendar entries from a given date\n   * @param {string} date Date in YYYY-MM-DD format\n   */\n  async _fetchWeekCalendar(date) {\n    '@cache|1440'; // cache for 24 hours\n    const resp = await this.http('GET', `${this.config.calendarUrl}${date}`);\n    return resp.body;\n  }\n\n  /**\n   * Return schedule data for all scheduled entities in this destination\n   * Eg. parks\n   * @returns {array<object>}\n   */\n  async buildEntityScheduleData() {\n    const startDate = this.getTimeNowMoment().clone().startOf('week');\n    const endDate = startDate.clone().add(60, 'days');\n\n    // fetch data by week\n    const datesToFetch = [];\n    for(let i = startDate.clone(); i.isSameOrBefore(endDate, 'day'); i.add(7, 'days')) {\n      datesToFetch.push(i.format('YYYY-MM-DD'));\n    }\n\n    // collect all data together...\n    const calendarData = await Promise.all(datesToFetch.map((x) => this._fetchWeekCalendar(x)));\n\n    // smush data into a single array\n    const data = calendarData.reduce((acc, x) => {\n      return acc.concat(x.week);\n    }, []);\n\n    return [\n      {\n        _id: 'toverland',\n        schedule: data.map((x) => {\n          if (!x.time_open || !x.time_close || /^\\s*$/.test(x.time_open) || /^\\s*$/.test(x.time_close)) return null;\n\n          return {\n            date: x.date.full,\n            type: \"OPERATING\",\n            openingTime: moment(`${x.date.full}T${x.time_open}`, 'YYYY-MM-DDTHH:mm').tz(this.config.timezone, true).format(),\n            closingTime: moment(`${x.date.full}T${x.time_close}`, 'YYYY-MM-DDTHH:mm').tz(this.config.timezone, true).format(),\n          };\n        }).filter((x) => !!x),\n      },\n    ];\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/toverland/toverland.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 563,
    "kind": "class",
    "name": "Toverland",
    "memberof": "lib/parks/toverland/toverland.js",
    "static": true,
    "longname": "lib/parks/toverland/toverland.js~Toverland",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/toverland/toverland.js",
    "importStyle": "{Toverland}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 564,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true
  },
  {
    "__docId__": 565,
    "kind": "method",
    "name": "fetchRideData",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#fetchRideData",
    "access": "public",
    "description": "Fetch Toverland ride live data and names etc.<br />These are in the same endpoint",
    "lineNumber": 38,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 566,
    "kind": "method",
    "name": "fetchShowData",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#fetchShowData",
    "access": "public",
    "description": "Fetch Toverland show data",
    "lineNumber": 47,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 567,
    "kind": "method",
    "name": "fetchDiningData",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#fetchDiningData",
    "access": "public",
    "description": "Fetch Toverland dining data",
    "lineNumber": 56,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 568,
    "kind": "method",
    "name": "getLocString",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#getLocString",
    "access": "public",
    "description": "Helper function to get a preferred translation of a string or object",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "object",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 569,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#buildBaseEntityObject",
    "access": "public",
    "description": "Helper function to build a basic entity document<br />Useful to avoid copy/pasting",
    "lineNumber": 86,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{object}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 570,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this destination",
    "lineNumber": 110,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": string, \"slug\": string, \"name\": *, \"entityType\": *}"
      ]
    }
  },
  {
    "__docId__": 571,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this destination",
    "lineNumber": 123,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 572,
    "kind": "method",
    "name": "_buildEntityList",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#_buildEntityList",
    "access": "private",
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "params": [
      {
        "name": "fetchFn",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributes",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "id_prefix",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "",
        "defaultValue": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 573,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this destination",
    "lineNumber": 156,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 574,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this destination",
    "lineNumber": 166,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 575,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this destination",
    "lineNumber": 175,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 576,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 184,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 577,
    "kind": "method",
    "name": "_fetchWeekCalendar",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#_fetchWeekCalendar",
    "access": "private",
    "description": "Fetch a week of calendar entries from a given date",
    "lineNumber": 219,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "Date in YYYY-MM-DD format"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 578,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/toverland/toverland.js~Toverland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/toverland/toverland.js~Toverland#buildEntityScheduleData",
    "access": "public",
    "description": "Return schedule data for all scheduled entities in this destination<br />Eg. parks",
    "lineNumber": 230,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array<object>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 579,
    "kind": "file",
    "name": "lib/parks/universal/universal.js",
    "content": "import moment from 'moment-timezone';\nimport crypto from 'crypto';\n\nimport Destination from '../destination.js';\nimport {attractionType, entityType, queueType, scheduleType, statusType, tagType, returnTimeState} from '../parkTypes.js';\n\n// only return restaurants using these dining types\nconst wantedDiningTypes = [\n  'CasualDining',\n  'FineDining',\n];\n\n// only return live data for entities in these POI categories (see getPOI)\nconst wantedLiveDataPOITypes = [\n  'Rides',\n];\n\nexport class UniversalResortBase extends Destination {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.timezone = options.timezone || 'America/New_York';\n\n    options.secretKey = options.secretKey || '';\n    options.appKey = options.appKey || '';\n    options.city = options.city || '';\n    options.vQueueURL = options.vQueueURL || '';\n    options.baseURL = options.baseURL || '';\n    options.resortSlug = options.resortSlug || '';\n\n    // any custom environment variable prefixes we want to use for this park (optional)\n    options.configPrefixes = ['UNIVERSALSTUDIOS'].concat(options.configPrefixes || []);\n\n    super(options);\n\n    // here we can validate the resulting this.config object\n    if (!this.config.name) throw new Error('Missing Universal resort name');\n    if (!this.config.secretKey) throw new Error('Missing Universal secretKey');\n    if (!this.config.appKey) throw new Error('Missing Universal appKey');\n    if (!this.config.city) throw new Error('Missing Universal city');\n    if (!this.config.vQueueURL) throw new Error('Missing Universal vQueueURL');\n    if (!this.config.baseURL) throw new Error('Missing Universal baseURL');\n    if (!this.config.resortSlug) throw new Error('Missing Universal resortSlug');\n\n    const baseURLHostname = new URL(this.config.baseURL).hostname;\n\n    // add out ApiKey to all API requests\n    //  add our service token only if this is not the login request\n    //  set options.loginRequest=true to skip adding the service token\n    this.http.injectForDomain({\n      hostname: baseURLHostname,\n    }, async (method, url, data, options) => {\n      options.headers['X-UNIWebService-ApiKey'] = this.config.appKey;\n      if (!options.loginRequest) {\n        const token = await this.getServiceToken();\n        options.headers['X-UNIWebService-Token'] = token;\n      }\n    });\n\n    // if our API ever returns 401, refetch our service token with a new login\n    this.http.injectForDomainResponse({\n      hostname: baseURLHostname,\n    }, async (response) => {\n      if (response.statusCode === 401) {\n        // clear out our token and try again\n        await this.cache.set('servicetoken', undefined, -1);\n        return undefined;\n      }\n\n      return response;\n    });\n  }\n\n  /**\n   * Get a service auth token for Universal\n   */\n  async getServiceToken() {\n    let tokenExpiration = null;\n    return await this.cache.wrap('servicetoken', async () => {\n      // create signature to get access token\n      const today = `${moment.utc().format('ddd, DD MMM YYYY HH:mm:ss')} GMT`;\n      const signatureBuilder = crypto.createHmac('sha256', this.config.secretKey);\n      signatureBuilder.update(`${this.config.appKey}\\n${today}\\n`);\n      // generate hash from signature builder\n      //  also convert trailing equal signs to unicode. because. I don't know\n      const signature = signatureBuilder.digest('base64').replace(/=$/, '\\u003d');\n\n      const resp = await this.http('POST', `${this.config.baseURL}?city=${this.config.city}`, {\n        apikey: this.config.appKey,\n        signature,\n      }, {\n        headers: {\n          'Date': today,\n        },\n        // tell our HTTP injector to not add our (currently undefined) service token\n        loginRequest: true,\n        json: true,\n      });\n\n      // remember the expiration time\n      const expireTime = resp.body.TokenExpirationUnix * 1000;\n      tokenExpiration = Math.max(+new Date() + (1000 * 60 * 60), expireTime - (+new Date()) - (1000 * 60 * 60 * 12));\n\n      return resp.body.Token;\n    }, () => {\n      // return ttl for cached service token based on data in the token response\n      //  can define ttl as a function instead of a Number for dynamic cache timeouts\n      return tokenExpiration;\n    });\n  }\n\n  async _getParks() {\n    // cache for 3 hours\n    '@cache|180';\n    const resp = await this.http('GET', `${this.config.baseURL}/venues?city=${this.config.city}`);\n    return resp.body.Results.filter((x) => {\n      // skip \"parks\" which don't require admission (i.e, CityWalk)\n      return x.AdmissionRequired;\n    });\n  }\n\n  /**\n   * Get POI data from API for this resort\n   * @returns {Object}\n   */\n  async getPOI() {\n    // cache for 3 hours\n    '@cache|180';\n    const resp = await this.http('GET', `${this.config.baseURL}/pointsofinterest?city=${this.config.city}`);\n    return resp.body;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  buildBaseEntityObject(data) {\n    const entity = super.buildBaseEntityObject(data);\n\n    if (data) {\n      // add location data (if present)\n      if (data.Longitude && data.Latitude) {\n        entity.location = {\n          longitude: data.Longitude,\n          latitude: data.Latitude,\n        };\n      }\n\n      // grab entity name from incoming data\n      if (data.MblDisplayName) {\n        entity.name = data.MblDisplayName;\n      }\n    }\n\n    return entity;\n  }\n\n  /**\n   * Build the destination entity representing this resort\n   */\n  async buildDestinationEntity() {\n    return {\n      ...this.buildBaseEntityObject(),\n      _id: `universalresort_${this.config.city}`,\n      name: this.config.name,\n      entityType: entityType.destination,\n      slug: this.config.resortSlug,\n    };\n  }\n\n  /**\n   * Build the park entities for this resort\n   */\n  async buildParkEntities() {\n    const parks = await this._getParks();\n\n    return parks.map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        // all IDs must be strings in ThemeParks.wiki\n        _id: x.Id.toString(),\n        // parented to the resort\n        _parentId: `universalresort_${this.config.city}`,\n        _contentId: x.ExternalIds.ContentId.slice(0, x.ExternalIds.ContentId.indexOf('.venues.')),\n        entityType: entityType.park,\n        slug: x.MblDisplayName.replace(/[^a-zA-Z]/g, '').toLowerCase(),\n      };\n    });\n  }\n\n  /**\n   * Build the attraction entities for this resort\n   */\n  async buildAttractionEntities() {\n    return (await this.getPOI()).Rides.map((x) => {\n      // what kind of attraction is this?\n      let type = attractionType.ride; // default to \"ride\"\n      // Hogwarts Express manually tag as \"transport\"\n      if (x.Tags.indexOf('train') >= 0) {\n        type = attractionType.transport;\n      }\n\n      // TODO - how to classify pool areas like Puka Uli Lagoon?\n\n      return {\n        ...this.buildBaseEntityObject(x),\n        _id: x.Id.toString(),\n        _parkId: x.VenueId.toString(),\n        _parentId: x.VenueId.toString(),\n        entityType: entityType.attraction,\n        attractionType: type,\n      };\n    });\n  }\n\n  /**\n   * Build the show entities for this resort\n   */\n  async buildShowEntities() {\n    return [];\n    // TODO - filter out meet & greets and street entertainment\n    return (await this.getPOI()).Shows.map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        _id: x.Id.toString(),\n        _parkId: x.VenueId.toString(),\n        _parentId: x.VenueId.toString(),\n        entityType: entityType.show,\n      };\n    });\n  }\n\n  /**\n   * Build the restaurant entities for this resort\n   */\n  async buildRestaurantEntities() {\n    return (await this.getPOI()).DiningLocations.filter((x) => {\n      // only return dining locations that match our wantedDiningTypes list\n      //  eg. CasualDining, FineDining - skip coffee carts\n      if (!x.DiningTypes) return false;\n      return !!x.DiningTypes.find((type) => {\n        return wantedDiningTypes.indexOf(type) >= 0;\n      });\n    }).map((x) => {\n      return {\n        ...this.buildBaseEntityObject(x),\n        _id: x.Id.toString(),\n        _parkId: x.VenueId.toString(),\n        _parentId: x.VenueId.toString(),\n        entityType: entityType.restaurant,\n      };\n    });\n  }\n\n  /**\n   * Fetch wait time data\n   * @private\n   */\n  async _fetchWaitTimes() {\n    // cache for 1 minute\n    '@cache|1';\n    const resp = await this.http('GET', `${this.config.baseURL}/pointsofinterest/rides/waittimes`, {\n      city: this.config.city,\n      pageSize: 'All',\n    });\n    return resp.body;\n  }\n\n  /**\n   * Get the current state of virtual queues for the resort\n   * @private\n   */\n  async _fetchVirtualQueueStates() {\n    // cache for 1 minute\n    '@cache|1';\n    const virtualData = await this.http('GET', `${this.config.baseURL}/Queues`, {\n      city: this.config.city,\n      page: 1,\n      pageSize: 'all',\n    });\n    return virtualData?.body?.Results;\n  }\n\n  /**\n   * Fetch the virtual queue state for a specific ride\n   * @private\n   */\n  async _fetchVirtualQueueStateForRide(queueId) {\n    // cache for 1 minute\n    '@cache|1';\n    const todaysDate = (await this.getTimeNowMoment()).format('MM/DD/YYYY');\n    const res = await this.http(\n      'GET',\n      `${this.config.baseURL}/${this.config.vQueueURL}/${queueId}`, {\n      page: 1,\n      pageSize: 'all',\n      city: this.config.city,\n      appTimeForToday: todaysDate,\n    });\n\n    return res.body;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityLiveData() {\n    // fetch standard wait times\n    const waittime = await this._fetchWaitTimes();\n\n    // fetch virtual lines state\n    //  this returns all the virtual queues and if they are running\n    const vQueueData = await this._fetchVirtualQueueStates();\n\n    // build a map of POI data to their poi type\n    //  so we can filter out entities we don't want to return live data for\n    // API returns live data for \"lands\" or other non-Ride things we don't want\n    const poiData = await this.getPOI();\n    const poiTypes = {};\n    Object.keys(poiData).forEach((type) => {\n      poiData[type].forEach((x) => {\n        poiTypes[`${x.Id}`] = type;\n      });\n    });\n\n    return Promise.all(waittime.Results.filter((x) => {\n      // filter all live data so we only return live data for things like Rides\n      //  (see wantedLiveDataPOITypes)\n      return wantedLiveDataPOITypes.indexOf(poiTypes[`${x.Key}`]) >= 0;\n    }).map(async (ride) => {\n      let queue = queueType.standBy;\n      let status = statusType.operating;\n      let postWaitTime = Math.max(0, ride.Value);\n      // figure out ride status and wait time based on ride.Value\n      //  generally anything < 0 is a special case\n      switch (ride.Value) {\n        case -50:\n          // wait time unknown\n          //  app just displays nothing for the ride status when -50\n          postWaitTime = null;\n          break;\n        case -9:\n          // this is a virtual line update, so bail out\n          queue = queueType.returnTime;\n          break;\n        case -8:\n          // not open yet\n          status = statusType.closed;\n          postWaitTime = null;\n          break;\n        case -7:\n          // \"ride now\"\n          break;\n        case -6:\n        case -5:\n          // \"closed inside of operating hours\", not sure what that means, but it's closed\n          status = statusType.closed;\n          postWaitTime = null;\n          break;\n        case -4:\n        case -3:\n          // bad weather\n          status = statusType.down;\n          postWaitTime = null;\n          break;\n        case -1:\n        // not open yet (too early)\n        case -2:\n          // \"delayed\", but expected to open\n          status = statusType.closed;\n          postWaitTime = null;\n          break;\n      }\n\n      const data = {\n        _id: ride.Key.toString(),\n        status,\n      };\n\n      data.queue = {};\n      if (queue == queueType.standBy) {\n        data.queue[queueType.standBy] = {\n          waitTime: postWaitTime,\n        };\n      }\n\n      if (queue == queueType.returnTime && !!vQueueData) {\n        // look for vqueue data for this attraction\n        const vQueue = vQueueData.find((x) => x.QueueEntityId === ride.Key);\n\n        if (vQueue && vQueue.IsEnabled) {\n          // hurray! we found some vqueue data in the state object\n          //  and it's enabled!\n\n          // get details about this queue\n          const vQueueFetchedData = await this._fetchVirtualQueueStateForRide(vQueue.Id);\n\n          // find and return the earliest appointment time available\n          const nextSlot = vQueueFetchedData.AppointmentTimes.reduce((p, x) => {\n            const startTime = moment.tz(x.StartTime, this.config.timezone);\n            if (p === undefined || startTime.isBefore(p.startTime)) {\n              const endTime = moment.tz(x.EndTime, this.config.timezone);\n              return {\n                startTime,\n                endTime,\n              };\n            }\n            return p;\n          }, undefined);\n\n          data.queue[queueType.returnTime] = {\n            returnStart: nextSlot === undefined ? null : nextSlot.startTime.format(),\n            returnEnd: nextSlot === undefined ? null : nextSlot.endTime.format(),\n            // TODO - can we tell the difference between temporarily full and finished for the day?\n            state: nextSlot === undefined ? returnTimeState.temporarilyFull : returnTimeState.available,\n          };\n        }\n      }\n\n      return data;\n    }).filter((x) => !!x));\n  }\n\n  /**\n   * Convert a time string from the API to a valid timestamp in our timezone\n   * @param {string} time \n   * @returns \n   */\n  _stringTimeToLocalTime(time) {\n    return moment.tz(time, this.config.timezone).format();\n  }\n\n  /**\n   * Get the latest raw opening hours for a given venue\n   */\n  async getLatestOpeningHoursForVenue(venueId) {\n    // cache for 12 hours\n    '@cache|720';\n    const now = this.getTimeNowMoment();\n    const cal = await this.http('GET', `${this.config.baseURL}/venues/${venueId}/hours`, {\n      endDate: now.clone().add(190, 'days').format('MM/DD/YYYY'),\n    });\n\n    const ret = [];\n    // loop over all hours data the API returns\n    cal.body.forEach((todaysCal) => {\n      // skip any Closed dates, just return nothing\n      if (todaysCal.VenueStatus === 'Closed') return;\n\n      ret.push({\n        date: todaysCal.Date,\n        openingTime: this._stringTimeToLocalTime(todaysCal.OpenTimeString),\n        closingTime: this._stringTimeToLocalTime(todaysCal.CloseTimeString),\n        type: scheduleType.operating,\n      });\n\n      if (todaysCal.EarlyEntryString) {\n        // extra hours\n        ret.push({\n          date: todaysCal.Date,\n          openingTime: this._stringTimeToLocalTime(todaysCal.EarlyEntryString),\n          closingTime: this._stringTimeToLocalTime(todaysCal.OpenTimeString),\n          type: scheduleType.extraHours,\n        });\n      }\n\n      // TODO - handle todaysCal.SpecialEntryString (when these exist)\n      if (todaysCal.SpecialEntryString) {\n        this.emit('error', new Error(`Unknown Universal SpecialEntryString ${todaysCal.SpecialEntryString}`));\n      }\n    });\n\n    return ret;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityScheduleData() {\n    // get list of venues to fetch schedules for\n    const venues = (await this.getParkEntities()).map((x) => {\n      return x._id;\n    });\n\n    // loop over each venue and build up our return object\n    const returnData = [];\n    for (let i = 0; i < venues.length; i++) {\n      const venueScheduleData = await this.getLatestOpeningHoursForVenue(venues[i]);\n      returnData.push({\n        _id: venues[i],\n        schedule: venueScheduleData,\n      });\n    }\n    return returnData;\n  }\n}\n\nexport class UniversalOrlando extends UniversalResortBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Universal Orlando Resort';\n    options.city = options.city || 'orlando';\n    options.timezone = options.timezone || 'America/New_York';\n    options.resortSlug = options.resortSlug || 'universalorlando';\n\n    super(options);\n  }\n}\n\nexport class UniversalStudios extends UniversalResortBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Universal Studios';\n    options.city = options.city || 'hollywood';\n    options.timezone = options.timezone || 'America/Los_Angeles';\n    options.resortSlug = options.resortSlug || 'universalstudios';\n\n    super(options);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/universal/universal.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 580,
    "kind": "variable",
    "name": "wantedDiningTypes",
    "memberof": "lib/parks/universal/universal.js",
    "static": true,
    "longname": "lib/parks/universal/universal.js~wantedDiningTypes",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universal.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 581,
    "kind": "variable",
    "name": "wantedLiveDataPOITypes",
    "memberof": "lib/parks/universal/universal.js",
    "static": true,
    "longname": "lib/parks/universal/universal.js~wantedLiveDataPOITypes",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universal.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 582,
    "kind": "class",
    "name": "UniversalResortBase",
    "memberof": "lib/parks/universal/universal.js",
    "static": true,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universal.js",
    "importStyle": "{UniversalResortBase}",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 583,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 584,
    "kind": "method",
    "name": "getServiceToken",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#getServiceToken",
    "access": "public",
    "description": "Get a service auth token for Universal",
    "lineNumber": 78,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 585,
    "kind": "method",
    "name": "_getParks",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#_getParks",
    "access": "private",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 586,
    "kind": "method",
    "name": "getPOI",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#getPOI",
    "access": "public",
    "description": "Get POI data from API for this resort",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 587,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#buildBaseEntityObject",
    "access": "public",
    "description": "",
    "lineNumber": 137,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 588,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#buildDestinationEntity",
    "access": "public",
    "description": "Build the destination entity representing this resort",
    "lineNumber": 161,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"_id\": *, \"name\": *, \"entityType\": *, \"slug\": *}"
      ]
    }
  },
  {
    "__docId__": 589,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#buildParkEntities",
    "access": "public",
    "description": "Build the park entities for this resort",
    "lineNumber": 174,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 590,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#buildAttractionEntities",
    "access": "public",
    "description": "Build the attraction entities for this resort",
    "lineNumber": 194,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 591,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#buildShowEntities",
    "access": "public",
    "description": "Build the show entities for this resort",
    "lineNumber": 219,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 592,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#buildRestaurantEntities",
    "access": "public",
    "description": "Build the restaurant entities for this resort",
    "lineNumber": 236,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 593,
    "kind": "method",
    "name": "_fetchWaitTimes",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#_fetchWaitTimes",
    "access": "private",
    "description": "Fetch wait time data",
    "lineNumber": 259,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 594,
    "kind": "method",
    "name": "_fetchVirtualQueueStates",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#_fetchVirtualQueueStates",
    "access": "private",
    "description": "Get the current state of virtual queues for the resort",
    "lineNumber": 273,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 595,
    "kind": "method",
    "name": "_fetchVirtualQueueStateForRide",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#_fetchVirtualQueueStateForRide",
    "access": "private",
    "description": "Fetch the virtual queue state for a specific ride",
    "lineNumber": 288,
    "params": [
      {
        "name": "queueId",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 596,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#buildEntityLiveData",
    "access": "public",
    "description": "",
    "lineNumber": 307,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 597,
    "kind": "method",
    "name": "_stringTimeToLocalTime",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#_stringTimeToLocalTime",
    "access": "private",
    "description": "Convert a time string from the API to a valid timestamp in our timezone",
    "lineNumber": 429,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 598,
    "kind": "method",
    "name": "getLatestOpeningHoursForVenue",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#getLatestOpeningHoursForVenue",
    "access": "public",
    "description": "Get the latest raw opening hours for a given venue",
    "lineNumber": 436,
    "params": [
      {
        "name": "venueId",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 599,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/universal/universal.js~UniversalResortBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalResortBase#buildEntityScheduleData",
    "access": "public",
    "description": "",
    "lineNumber": 479,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 600,
    "kind": "class",
    "name": "UniversalOrlando",
    "memberof": "lib/parks/universal/universal.js",
    "static": true,
    "longname": "lib/parks/universal/universal.js~UniversalOrlando",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universal.js",
    "importStyle": "{UniversalOrlando}",
    "description": null,
    "lineNumber": 498,
    "undocument": true,
    "interface": false,
    "extends": [
      "UniversalResortBase"
    ]
  },
  {
    "__docId__": 601,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universal.js~UniversalOrlando",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalOrlando#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 502,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 602,
    "kind": "class",
    "name": "UniversalStudios",
    "memberof": "lib/parks/universal/universal.js",
    "static": true,
    "longname": "lib/parks/universal/universal.js~UniversalStudios",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universal.js",
    "importStyle": "{UniversalStudios}",
    "description": null,
    "lineNumber": 512,
    "undocument": true,
    "interface": false,
    "extends": [
      "UniversalResortBase"
    ]
  },
  {
    "__docId__": 603,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universal.js~UniversalStudios",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universal.js~UniversalStudios#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 516,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 604,
    "kind": "file",
    "name": "lib/parks/universal/universalstudios.js",
    "content": "import {Park} from '../park.js';\nimport {attractionType, statusType, queueType, tagType, scheduleType, returnTimeState} from '../parkTypes.js';\nimport moment from 'moment-timezone';\nimport crypto from 'crypto';\nimport {URL} from 'url';\n\n/**\n * Sample Park Object\n */\nexport class UniversalParkBase extends Park {\n  /**\n   * Create a new Sample Park object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Universal Park';\n    options.timezone = options.timezone || 'America/New_York';\n\n    options.secretKey = options.secretKey || '';\n    options.appKey = options.appKey || '';\n    options.venueID = options.venueID || '';\n    options.city = options.city || '';\n    options.vQueueURL = options.venueID || '';\n    options.baseURL = options.baseURL || '';\n    options.contentID = options.contentID || '';\n\n    // any custom environment variable prefixes we want to use for this park (optional)\n    options.configPrefixes = ['UNIVERSALSTUDIOS'].concat(options.configPrefixes || []);\n\n    super(options);\n\n    // here we can validate the resulting this.config object\n    if (!this.config.secretKey) throw new Error('Missing Universal secretKey');\n    if (!this.config.appKey) throw new Error('Missing Universal appKey');\n    if (!this.config.venueID) throw new Error('Missing Universal venueID');\n    this.config.venueID = Number(this.config.venueID);\n    if (!this.config.city) throw new Error('Missing Universal city');\n    if (!this.config.vQueueURL) throw new Error('Missing Universal vQueueURL');\n    if (!this.config.baseURL) throw new Error('Missing Universal baseURL');\n    if (!this.config.contentID) throw new Error('Missing Universal contentID');\n\n    const baseURLHostname = new URL(this.config.baseURL).hostname;\n\n    this.http.injectForDomain({\n      hostname: baseURLHostname,\n    }, async (method, url, data, options) => {\n      options.headers['X-UNIWebService-ApiKey'] = this.config.appKey;\n      if (!options.loginRequest) {\n        const token = await this.getServiceToken();\n        options.headers['X-UNIWebService-Token'] = token;\n      }\n    });\n\n    // listen to unauthorised responses, to generate a new token\n    this.http.injectForDomainResponse({\n      hostname: baseURLHostname,\n    }, async (response) => {\n      if (response.statusCode === 401) {\n        // clear out our token and try again\n        await this.cache.set('servicetoken', undefined, -1);\n        return undefined;\n      }\n\n      return response;\n    });\n  }\n\n  /**\n   * Get a service auth token for Universal\n   */\n  async getServiceToken() {\n    let tokenExpiration = null;\n    return await this.cache.wrap('servicetoken', async () => {\n      // create signature to get access token\n      const today = `${moment.utc().format('ddd, DD MMM YYYY HH:mm:ss')} GMT`;\n      const signatureBuilder = crypto.createHmac('sha256', this.config.secretKey);\n      signatureBuilder.update(`${this.config.appKey}\\n${today}\\n`);\n      // generate hash from signature builder\n      //  also convert trailing equal signs to unicode. because. I don't know\n      const signature = signatureBuilder.digest('base64').replace(/=$/, '\\u003d');\n\n      const resp = await this.http('POST', `${this.config.baseURL}?city=${this.config.city}`, {\n        apikey: this.config.appKey,\n        signature,\n      }, {\n        headers: {\n          'Date': today,\n        },\n        loginRequest: true,\n        json: true,\n      });\n\n      // remember the expiration time\n      const expireTime = resp.body.TokenExpirationUnix * 1000;\n      tokenExpiration = Math.max(+new Date() + (1000 * 60 * 60), expireTime - (+new Date()) - (1000 * 60 * 60 * 12));\n\n      return resp.body.Token;\n    }, () => {\n      return tokenExpiration;\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _init() {\n  }\n\n  /**\n   * Get all park POI data\n   */\n  async getPOI() {\n    return await this.cache.wrapGlobal(`universalstudios_${this.config.city}_poi`, async () => {\n      const data = await this.http('GET', `${this.config.baseURL}/pointsOfInterest`, {\n        city: this.config.city,\n      });\n      if (!data?.body?.Rides) {\n        throw new Error('Unable to fetch Universal POI data');\n      }\n      return data.body.Rides;\n    }, 1000 * 60 * 60 * 12); // 12 hours\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _buildAttractionObject(attractionID) {\n    const data = await this.getPOI();\n    if (data === undefined) return undefined;\n    const ride = data.find((x) => `${x.Id}` === attractionID && x.VenueId === this.config.venueID);\n    if (ride === undefined) return undefined;\n\n    const tags = [];\n\n    if (ride.Longitude && ride.Latitude) {\n      tags.push({\n        key: 'location',\n        type: tagType.location,\n        value: {\n          longitude: ride.Longitude,\n          latitude: ride.Latitude,\n        },\n      });\n    }\n\n    if (ride.MinHeightInInches) {\n      tags.push({\n        key: 'minimumHeight',\n        type: tagType.minimumHeight,\n        value: {\n          unit: 'in',\n          height: ride.MinHeightInInches,\n        },\n      });\n    }\n    if (ride.MaxHeightInInches) {\n      tags.push({\n        key: 'maximumHeight',\n        type: tagType.maximumHeight,\n        value: {\n          unit: 'in',\n          height: ride.MaxHeightInInches,\n        },\n      });\n    }\n\n    tags.push({\n      type: tagType.singleRider,\n      value: !!ride.HasSingleRiderLine,\n    });\n\n    tags.push({\n      type: tagType.fastPass,\n      value: !!ride.ExpressPassAccepted,\n    });\n\n    tags.push({\n      type: tagType.childSwap,\n      value: !!ride.HasChildSwap,\n    });\n\n    return {\n      name: ride.MblDisplayName,\n      type: attractionType.ride,\n      tags,\n    };\n  }\n\n  /**\n   * Get the current state of virtual queues for the resort\n   */\n  async getVirtualQueueStates() {\n    return await this.cache.wrap(`universalstudios_${this.config.city}_vqueuestate`, async () => {\n      const virtualData = await this.http('GET', `${this.config.baseURL}/Queues`, {\n        city: this.config.city,\n        page: 1,\n        pageSize: 'all',\n      });\n      return virtualData.body;\n    }, 1000 * 60); // 1 minute\n  }\n\n  /**\n   * Get current state for a virtual queue\n   * @param {number} queueId\n   * @return {object} Object containing startTime and endTime as a moment object.\n   * Or undefined if there are no times available.\n   */\n  async getVirtualQueueTimeForRide(queueId) {\n    return await this.cache.wrap(`vqueue_${queueId}`, async () => {\n      const todaysDate = (await this.getActiveParkDateMoment()).format('MM/DD/YYYY');\n      const res = await this.http(\n          'GET',\n          `${this.config.baseURL}/${this.config.vQueueURL}/${queueId}`, {\n            page: 1,\n            pageSize: 'all',\n            city: this.config.city,\n            appTimeForToday: todaysDate,\n          });\n\n      // find and return the earliest appointment time available\n      const earliestTime = res.body.AppointmentTimes.reduce((p, x) => {\n        const startTime = moment.tz(x.StartTime, this.config.timezone);\n        if (p === undefined || startTime.isBefore(p.startTime)) {\n          const endTime = moment.tz(x.EndTime, this.config.timezone);\n          return {\n            startTime,\n            endTime,\n          };\n        }\n        return p;\n      }, undefined);\n\n      return earliestTime;\n    }, 1000 * 60); // 1 minute\n  }\n\n  /**\n   * Fetch raw waiting times data\n   */\n  async getWaitingTimes() {\n    return await this.cache.wrapGlobal(`universalstudios_${this.config.city}_waittimes`, async () => {\n      const resp = await this.http('GET', `${this.config.baseURL}/pointsofinterest/rides/waittimes`, {\n        city: this.config.city,\n        pageSize: 'All',\n      });\n      return resp.body;\n    }, 1000 * 60); // cache for 1 minute\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _update() {\n    const data = await this.getWaitingTimes();\n\n    await Promise.allSettled(data.Results.filter(\n        (x) => x.ContentId.indexOf(this.config.contentID) === 0,\n    ).map(async (ride) => {\n      let queue = queueType.standBy;\n      let status = statusType.operating;\n      let postWaitTime = Math.max(0, ride.Value);\n      switch (ride.Value) {\n        case -50:\n          // wait time unknown\n          //  app just displays nothing for the ride status when -50\n          postWaitTime = null;\n          break;\n        case -9:\n          // this is a virtual line update, so bail out\n          queue = queueType.returnTime;\n          break;\n        case -8:\n          // \"coming soon\"\n          status = statusType.closed;\n          postWaitTime = null;\n          break;\n        case -7:\n          // \"ride now\"\n          //  fallthrough to default \"operating\" state\n          break;\n        case -6:\n          // not open yet\n        case -5:\n          // \"at capactity\"\n          status = statusType.closed;\n          postWaitTime = null;\n          break;\n        case -4:\n          // bad weather\n        case -2:\n          // \"Delayed\"\n          status = statusType.down;\n          postWaitTime = null;\n          break;\n        case -1:\n          // not open yet (too early)\n        case -3:\n          // closed, but expected to open during operating hours as normal\n          status = statusType.closed;\n          postWaitTime = null;\n          break;\n      }\n\n      await this.updateAttractionState(ride.Key, status);\n      if (queue == queueType.standBy) {\n        await this.updateAttractionQueue(ride.Key, postWaitTime, queueType.standBy);\n      } else {\n        await this.updateAttractionQueue(ride.Key, undefined, queueType.standBy);\n      }\n    }));\n\n    // also fetch virtual lines status\n    const virtualData = await this.getVirtualQueueStates();\n    const vResults = virtualData?.Results;\n    if (vResults !== undefined) {\n      await Promise.allSettled(vResults.map(async (ride) => {\n      // check the right this virtual queue is for is in this park\n        const actual = await this.findAttractionByID(ride.QueueEntityId);\n        if (actual === undefined) return;\n\n        if (ride.IsEnabled) {\n        // get next available slot\n          const nextSlot = await this.getVirtualQueueTimeForRide(ride.Id);\n\n          // update return time queue with slot data\n          await this.updateAttractionQueue(ride.QueueEntityId, {\n            returnStart: nextSlot === undefined ? null : nextSlot.startTime,\n            returnEnd: nextSlot === undefined ? null : nextSlot.endTime,\n            // TODO - can we tell the difference between temporarily full and finished for the day?\n            state: nextSlot === undefined ? returnTimeState.temporarilyFull : returnTimeState.available,\n          }, queueType.returnTime);\n        } else {\n        // virtual queue not enable, ensure return time queue type is not shown\n          await this.updateAttractionQueue(ride.QueueEntityId, undefined, queueType.returnTime);\n        }\n      }));\n    } else {\n      // virtual queue system is down, unset all virtual queues for this park\n      const toUpdate = this._attractions.map((x) => x.rideId);\n      for (let i=0; i<toUpdate.length; i++) {\n        await this.updateAttractionQueue(toUpdate[i], undefined, queueType.returnTime);\n      }\n    }\n  }\n\n  /**\n   * Get the latest raw opening hours for this park\n   */\n  async getLatestOpeningHours() {\n    return await this.cache.wrap('calendar_data', async () => {\n      const now = this.getTimeNowMoment();\n      const cal = await this.http('GET', `${this.config.baseURL}/venues/${this.config.venueID}/hours`, {\n        endDate: now.clone().add(120, 'days').format('MM/DD/YYYY'),\n      });\n      return cal.body;\n    }, 1000 * 60 * 60 * 24); // 1 day\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getOperatingHoursForDate(date) {\n    const cal = await this.getLatestOpeningHours();\n    const dateFormatted = date.format('YYYY-MM-DD');\n    const todaysCal = cal.find((x) => x.Date === dateFormatted);\n    if (todaysCal === undefined) return undefined;\n\n    if (todaysCal.VenueStatus === 'Closed') return undefined;\n\n    const ret = [];\n    ret.push({\n      openingTime: todaysCal.OpenTimeString,\n      closingTime: todaysCal.CloseTimeString,\n      type: scheduleType.operating,\n    });\n\n    if (todaysCal.EarlyEntryString) {\n      // extra hours\n      ret.push({\n        openingTime: todaysCal.EarlyEntryString,\n        closingTime: todaysCal.OpenTimeString,\n        type: scheduleType.extraHours,\n      });\n    }\n\n    // TODO - handle todaysCal.SpecialEntryString (when these exist)\n    if (todaysCal.SpecialEntryString) {\n      this.emit('error', new Error(`Unknown Universal SpecialEntryString ${todaysCal.SpecialEntryString}`));\n    }\n\n    return ret;\n  }\n}\n\nexport default UniversalParkBase;\n\n/**\n * Universal Studios Florida Park\n */\nexport class UniversalStudiosFlorida extends UniversalParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Universal Studios Florida';\n    options.venueID = 10010;\n    options.city = 'orlando';\n    options.contentID = 'com.uo.usf';\n\n    super(options);\n  }\n}\n\n/**\n * Islands Of Adventure Park\n */\nexport class UniversalIslandsOfAdventure extends UniversalParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Universal\\'s Islands Of Adventure';\n    options.venueID = 10000;\n    options.city = 'orlando';\n    options.contentID = 'com.uo.ioa';\n\n    super(options);\n  }\n}\n\n/**\n * Volcano Bay\n */\nexport class UniversalVolcanoBay extends UniversalParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Universal\\'s Volcano Bay';\n    options.venueID = 13801;\n    options.city = 'orlando';\n    options.contentID = 'com.uo.vb';\n\n    super(options);\n  }\n}\n\n/**\n * Universal Studios Hollywood\n */\nexport class UniversalStudios extends UniversalParkBase {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = 'Universal Studios';\n    options.venueID = 13825;\n    options.city = 'hollywood';\n    options.contentID = 'com.uo.us';\n\n    super(options);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/universal/universalstudios.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 605,
    "kind": "class",
    "name": "UniversalParkBase",
    "memberof": "lib/parks/universal/universalstudios.js",
    "static": true,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universalstudios.js",
    "importStyle": "{UniversalParkBase}",
    "description": "Sample Park Object",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "lib/parks/park.js~Park"
    ]
  },
  {
    "__docId__": 606,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#constructor",
    "access": "public",
    "description": "Create a new Sample Park object",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 607,
    "kind": "method",
    "name": "getServiceToken",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getServiceToken",
    "access": "public",
    "description": "Get a service auth token for Universal",
    "lineNumber": 71,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 608,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#_init",
    "access": "private",
    "description": "",
    "lineNumber": 106,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 609,
    "kind": "method",
    "name": "getPOI",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getPOI",
    "access": "public",
    "description": "Get all park POI data",
    "lineNumber": 112,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 610,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#_buildAttractionObject",
    "access": "private",
    "description": "",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "attractionID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"name\": *, \"type\": *, \"tags\": *}"
      ]
    }
  },
  {
    "__docId__": 611,
    "kind": "method",
    "name": "getVirtualQueueStates",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getVirtualQueueStates",
    "access": "public",
    "description": "Get the current state of virtual queues for the resort",
    "lineNumber": 192,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 612,
    "kind": "method",
    "name": "getVirtualQueueTimeForRide",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getVirtualQueueTimeForRide",
    "access": "public",
    "description": "Get current state for a virtual queue",
    "lineNumber": 209,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "queueId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Object containing startTime and endTime as a moment object.\nOr undefined if there are no times available."
    }
  },
  {
    "__docId__": 613,
    "kind": "method",
    "name": "getWaitingTimes",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getWaitingTimes",
    "access": "public",
    "description": "Fetch raw waiting times data",
    "lineNumber": 241,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 614,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#_update",
    "access": "private",
    "description": "",
    "lineNumber": 254,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 615,
    "kind": "method",
    "name": "getLatestOpeningHours",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#getLatestOpeningHours",
    "access": "public",
    "description": "Get the latest raw opening hours for this park",
    "lineNumber": 350,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 616,
    "kind": "method",
    "name": "_getOperatingHoursForDate",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalParkBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalParkBase#_getOperatingHoursForDate",
    "access": "private",
    "description": "",
    "lineNumber": 363,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "date",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 617,
    "kind": "class",
    "name": "UniversalStudiosFlorida",
    "memberof": "lib/parks/universal/universalstudios.js",
    "static": true,
    "longname": "lib/parks/universal/universalstudios.js~UniversalStudiosFlorida",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universalstudios.js",
    "importStyle": "{UniversalStudiosFlorida}",
    "description": "Universal Studios Florida Park",
    "lineNumber": 401,
    "interface": false,
    "extends": [
      "UniversalParkBase"
    ]
  },
  {
    "__docId__": 618,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalStudiosFlorida",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalStudiosFlorida#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 405,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 619,
    "kind": "class",
    "name": "UniversalIslandsOfAdventure",
    "memberof": "lib/parks/universal/universalstudios.js",
    "static": true,
    "longname": "lib/parks/universal/universalstudios.js~UniversalIslandsOfAdventure",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universalstudios.js",
    "importStyle": "{UniversalIslandsOfAdventure}",
    "description": "Islands Of Adventure Park",
    "lineNumber": 418,
    "interface": false,
    "extends": [
      "UniversalParkBase"
    ]
  },
  {
    "__docId__": 620,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalIslandsOfAdventure",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalIslandsOfAdventure#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 422,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 621,
    "kind": "class",
    "name": "UniversalVolcanoBay",
    "memberof": "lib/parks/universal/universalstudios.js",
    "static": true,
    "longname": "lib/parks/universal/universalstudios.js~UniversalVolcanoBay",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universalstudios.js",
    "importStyle": "{UniversalVolcanoBay}",
    "description": "Volcano Bay",
    "lineNumber": 435,
    "interface": false,
    "extends": [
      "UniversalParkBase"
    ]
  },
  {
    "__docId__": 622,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalVolcanoBay",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalVolcanoBay#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 439,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 623,
    "kind": "class",
    "name": "UniversalStudios",
    "memberof": "lib/parks/universal/universalstudios.js",
    "static": true,
    "longname": "lib/parks/universal/universalstudios.js~UniversalStudios",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/universal/universalstudios.js",
    "importStyle": "{UniversalStudios}",
    "description": "Universal Studios Hollywood",
    "lineNumber": 452,
    "interface": false,
    "extends": [
      "UniversalParkBase"
    ]
  },
  {
    "__docId__": 624,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/universal/universalstudios.js~UniversalStudios",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/universal/universalstudios.js~UniversalStudios#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 456,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 625,
    "kind": "file",
    "name": "lib/parks/wdw/waltdisneyworldbase.js",
    "content": "import moment from 'moment-timezone';\nimport {attractionType, boardingGroupState, entityType, queueType, scheduleType, statusType, returnTimeState} from '../parkTypes.js';\nimport Destination from '../destination.js';\nimport {getEntityID, IndexedWDWDB} from './wdwdb.js';\n\nlet wdwDB = null;\n/**\n * Get a reference to the WDW database\n * @return {IndexedWDWDB}\n */\nexport function getDatabase() {\n  if (!wdwDB) {\n    wdwDB = new IndexedWDWDB();\n  }\n  return wdwDB;\n}\n\n// entity types that count as \"parks\"\nconst parkTypes = [\n  'theme-park',\n  'water-park',\n];\n\n// scheduleTypes that are actually not a schedule\nconst invalidScheduleTypes = [\n  'Closed',\n  'No Performance',\n];\n\n/**\n * A Resort class for a Disney live resort (WDW, DLR, HKDR)\n */\nexport class DisneyLiveResort extends Destination {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.virtualQueueURL = options.virtualQueueURL || '';\n    options.genieData = options.genieData || '';\n\n    super(options);\n\n    this.resortId = options.resortId;\n    if (!this.resortId) {\n      throw new Error('Missing Resort ID');\n    }\n    this.resortShortcode = options.resortShortcode;\n    if (!this.resortShortcode) {\n      throw new Error('Missing Resort Shortcode');\n    }\n    this.destinationDocumentIDRegex = new RegExp(`^${this.resortId};entityType=destination`);\n    this.parkIds = options.parkIds || [];\n\n    this.db = getDatabase();\n  }\n\n  /**\n   * Initialise our Disney resort class\n   */\n  async _init() {\n    await this.db.init();\n\n    // setup our live status updating\n    this.initLiveStatusUpdates();\n  }\n\n  /**\n   * Get the channel ID for the facility status live update documents\n   * @return {string}\n   */\n  getFacilityStatusChannelID() {\n    return `${this.resortShortcode}.facilitystatus.1_0`;\n  }\n\n  /**\n   * @private\n   */\n  async fetchVirtualQueueData() {\n    // cache for 1 minute\n    '@cache|1';\n\n    if (!this.config.virtualQueueURL) return undefined;\n\n    return (await this.http('GET', this.config.virtualQueueURL, undefined, {\n      rejectUnauthorized: false,\n    })).body.queues;\n  }\n\n  async fetchGenieData() {\n    // cache for 1 minute\n    '@cache|1';\n\n    if (!this.config.genieData) return undefined;\n\n    return (await this.http('GET', this.config.genieData, undefined, {\n      rejectUnauthorized: false,\n    })).body?.entities;\n  }\n\n  /**\n   * Given a status doc, build a live data object\n   * @param {object} doc\n   */\n  async _buildLiveDataObject(doc) {\n    // get full facility doc\n    const entityId = getEntityID(doc.id || doc._id);\n    const entityDoc = await this.db.getEntityOne(entityId);\n    // if can't find it, or \"soft deleted\", or we get back the same facility update doc, return nothing\n    if (!entityDoc || entityDoc.softDeleted || entityDoc._id === doc._id) {\n      return undefined;\n    }\n\n    // get our entity type\n    const docEntityType = entityDoc.type;\n\n    // skip if this doc is not a valid entity type\n    /* if (docEntityType === undefined) {\n      this.emit('error', doc.id || doc._id, 'LIVEDATA_MISSING_ENTITYTYPE', {\n        message: `Live data for ${doc.id || doc._id} is missing a type. Expecting \"Attraction\", \"Entertainment\"...`,\n        entityDoc,\n      });\n      return undefined;\n    }*/\n\n    // figure out entity status\n    let status = statusType.operating;\n\n    // if name contains \"Temporarily Unavailable\", mark as closed\n    //  will be overriden by better metrics later, if any exist\n    if (entityDoc.name && entityDoc.name.indexOf('Temporarily Unavailable') > 0) {\n      // not refurb, as this more often than not \"unavailable\" is marked as just \"closed\"\n      status = statusType.closed;\n    }\n\n    // restaurants can have status \"Capacity\", \"Walk-Up Disabled\"\n    //  currently these fallback to \"Operating\", which matches the resturant state well enough\n    if (doc.status === 'Down') {\n      status = statusType.down;\n    } else if (doc.status === 'Closed') {\n      status = statusType.closed;\n    } else if (doc.status === 'Refurbishment') {\n      status = statusType.refurbishment;\n    }\n\n    // create base data object\n    const data = {\n      _id: entityDoc.id,\n      status: status,\n    };\n\n    // get our genie data\n    const genieData = await this.fetchGenieData();\n    if (genieData) {\n      const genieEntity = genieData.find((x) => {\n        return x.id === entityId;\n      });\n      if (genieEntity) {\n        const now = this.getTimeNowMoment();\n\n        if (genieEntity.flex) {\n          if (!data.queue) data.queue = {};\n\n          if (!genieEntity.flex.available) {\n            data.queue[queueType.returnTime] = {\n              returnStart: null,\n              returnEnd: null,\n              state: returnTimeState.finished,\n            };\n          } else {\n            const breakTime = genieEntity.flex.nextAvailableTime.split(':');\n\n            data.queue[queueType.returnTime] = {\n              returnStart: now.clone().set({\n                hours: Number(breakTime[0]),\n                minutes: Number(breakTime[1]),\n                seconds: 0,\n              }).format(),\n              returnEnd: null,\n              state: returnTimeState.available,\n            };\n          }\n        }\n\n        if (genieEntity.individual) {\n          if (!data.queue) data.queue = {};\n\n          if (!genieEntity.individual.available) {\n            data.queue[queueType.paidReturnTime] = {\n              returnStart: null,\n              returnEnd: null,\n              state: returnTimeState.finished,\n              price: genieEntity.individual?.price ? {\n                currency: 'USD',\n                amount: genieEntity.individual.price ? genieEntity.individual.price * 100 : null,\n              } : null,\n            };\n          } else {\n            const breakTime = genieEntity.individual.nextAvailableTime.split(':');\n\n            data.queue[queueType.paidReturnTime] = {\n              returnStart: now.clone().set({\n                hours: Number(breakTime[0]),\n                minutes: Number(breakTime[1]),\n                seconds: 0,\n              }).format(),\n              returnEnd: null,\n              state: returnTimeState.available,\n              price: {\n                currency: 'USD',\n                amount: genieEntity.individual.price ? genieEntity.individual.price * 100 : null,\n              },\n            };\n          }\n        }\n      }\n    }\n\n    // get our vqueue data\n    const vQueueData = await this.fetchVirtualQueueData();\n    if (vQueueData) {\n      // find matching queue data for this entity\n      const attractionVQueueData = vQueueData.find((x) => {\n        return x.externalDefinitionId === entityDoc.id;\n      });\n      if (attractionVQueueData) {\n        // we have found a virtual queue!\n        if (!data.queue) data.queue = {}; // make sure our queue object exists\n\n        // figure out our allocation status\n        //  default to available\n        let allocationStatus = boardingGroupState.available;\n\n        if (doc.status !== 'Virtual Queue' || attractionVQueueData.state === 'CLOSED') {\n          allocationStatus = boardingGroupState.closed;\n        }\n\n        // PAUSED state\n        if (attractionVQueueData.state === 'PAUSED') {\n          // if we have an upcoming allocation time, then we are temporarily paused\n          if (attractionVQueueData.nextScheduledOpenTime) {\n            allocationStatus = boardingGroupState.paused;\n          } else {\n            // otherwise... no future times? we're closed for the day\n            allocationStatus = boardingGroupState.closed;\n          }\n        }\n\n        // extract allocation time and present as a full datetime string\n        let nextAllocationTime = null;\n        if (attractionVQueueData.nextScheduledOpenTime) {\n          const nowDate = this.getTimeNowMoment().format('YYYY-MM-DD');\n          nextAllocationTime = moment.tz(\n            `${nowDate}T${attractionVQueueData.nextScheduledOpenTime}`,\n            this.config.timezone,\n          ).format();\n        }\n\n        // pull estimated wait data, if valid/exists\n        let estimatedWait = null;\n        if (allocationStatus === boardingGroupState.available) {\n          estimatedWait = attractionVQueueData.waitTimeMin || null;\n        }\n\n        data.queue[queueType.boardingGroup] = {\n          allocationStatus: allocationStatus,\n          currentGroupStart: attractionVQueueData.currentArrivingGroupStart || null,\n          currentGroupEnd: attractionVQueueData.currentArrivingGroupEnd || null,\n          nextAllocationTime: nextAllocationTime || null,\n          estimatedWait,\n        };\n      }\n    }\n\n    // inject prediction data from Genie\n    const forecastDocId = `${this.resortShortcode}.forecastedwaittimes.1_0.en_us.${data._id}`;\n    try {\n      const forecastDoc = await this.db.get(forecastDocId);\n      if (forecastDoc && forecastDoc.forecasts && forecastDoc.forecasts.length > 0) {\n        // check forecast data is relevant for current time\n\n        // get the largest timestamp from forecast data\n        const now = this.getTimeNowMoment();\n        const lastTimeslot = forecastDoc.forecasts.reduce((prev, curr) => {\n          if (!curr) return prev;\n          if (prev && prev.timestamp > curr.timestamp) {\n            return prev;\n          }\n          return curr;\n        });\n\n        if (lastTimeslot && lastTimeslot.timestamp) {\n          // forecasts are in hour slots, so add an hour to the last timestamp\n          const lastHour = moment(lastTimeslot.timestamp).add(1, 'hour');\n          if (lastHour.isAfter(now)) {\n            // we have a valid forecast for today, return it\n            data.forecast = forecastDoc.forecasts.map((x) => {\n              if (!x) return null;\n              return {\n                time: moment(x.timestamp).tz(this.config.timezone).format(),\n                waitTime: isNaN(x.forecastedWaitMinutes) ? null : x.forecastedWaitMinutes,\n                percentage: isNaN(x.percentage) ? null : x.percentage,\n              };\n            }).filter((x) => !!x);\n          }\n        }\n      }\n    } catch (e) { }\n\n    // add any data from daily Entertainment feed\n    if (docEntityType === 'Entertainment') {\n      // grab entity showtimes\n      // TODO - this is expensive to grab this for every single entity!!!\n      const entertainmentToday = await this.db.get(`${this.resortShortcode}.today.1_0.Entertainment`);\n      if (entertainmentToday && entertainmentToday.facilities) {\n        const showtimes = (entertainmentToday.facilities[doc.id] || []).filter((x) => {\n          // ignore invalid schedule types\n          return invalidScheduleTypes.indexOf(x.scheduleType) < 0;\n        });\n\n        if (showtimes.length === 0) {\n          data.status = statusType.closed;\n        }\n\n        // add showtimes to livedata\n        data.showtimes = showtimes.map((time) => {\n          return {\n            startTime: moment(time.startTime).tz(this.config.timezone).format(),\n            endTime: moment(time.endTime).tz(this.config.timezone).format(),\n            type: time.scheduleType,\n          };\n        });\n      }\n    } else if (docEntityType === 'restaurant') {\n      // TODO - restaurant specific live data\n    } else if (docEntityType === 'Attraction') {\n      // attraction-specific live data\n\n      // check today's schedule for refurbishments!\n      // TODO - this is expensive to grab for every single entity!\n      const attractionsToday = await this.db.get(`${this.resortShortcode}.today.1_0.Attraction`);\n      if (attractionsToday !== undefined && attractionsToday.facilities) {\n        const attractionSchedule = attractionsToday.facilities[doc.id];\n        if (attractionSchedule) {\n          // look for schedules with \"Closed\" or \"Refurb\"\n          if (attractionSchedule.length === 1) {\n            if (attractionSchedule[0].scheduleType === 'Closed') {\n              data.status = statusType.closed;\n            } else if (attractionSchedule[0].scheduleType === 'Refurbishment') {\n              data.status = statusType.refurbishment;\n            }\n          }\n\n          // TODO - store attraction operating hours in live data\n        }\n      }\n    }\n\n    // before we do any queue stuff, check if the lastUpdate is vaguely recent\n    const lastUpdateTime = moment(doc.lastUpdate || 0);\n    const now = moment();\n\n    // if status was updated in past ~2 months, then push queue data\n    //  otherwise, ignore, queues not used\n    const daysSinceLastUpdate = now.diff(lastUpdateTime, 'days');\n    if (daysSinceLastUpdate < 60) {\n      // report wait minutes for standBy line (if present)\n      //  pretty much any entity can have waitMinutes\n      // ignore if doc status is \"Virtual Queue\", which means only Virtual Queue is available for this attraction (right now)\n      if (doc.waitMinutes !== undefined && doc.status !== 'Virtual Queue') {\n        if (!data.queue) data.queue = {};\n        data.queue[queueType.standBy] = {\n          waitTime: doc.waitMinutes || null,\n        };\n      }\n\n      // populate the single ride queue status if this ride offers single rider\n      if (doc.singleRider) {\n        if (!data.queue) data.queue = {};\n        data.queue[queueType.singleRider] = {\n          // TODO - can we get single ride wait time?\n          waitTime: null,\n        };\n      }\n    }\n\n    return data;\n  }\n\n  /**\n   * Return all current live entity data\n   */\n  async buildEntityLiveData() {\n    // fetch the current attraction times\n    const allStatusDocs = await this.db.getByChannel(this.getFacilityStatusChannelID());\n    const docs = [];\n\n    for (let i = 0; i < allStatusDocs.length; i++) {\n      const liveDoc = await this._buildLiveDataObject(allStatusDocs[i]);\n      if (liveDoc) {\n        docs.push(liveDoc);\n      }\n    }\n\n    // TEMPORARY - Guardians of the Galaxy is missing from live data\n    //  so add it manually to get some data through\n    /*const isGotgAlreadyIn = docs.find((x) => x._id === '411499845;entityType=Attraction');\n    if (!isGotgAlreadyIn) {\n      docs.push(await this._buildLiveDataObject({\n        id: '411499845;entityType=Attraction',\n        status: 'Closed',\n        lastUpdate: \"2022-05-24T13:57:46.153Z\",\n      }));\n    }*/\n\n    // loop over entertainment and pretend we have facility update docs for them\n    const entertainmentToday = await this.db.get(`${this.resortShortcode}.today.1_0.Entertainment`);\n    if (entertainmentToday && entertainmentToday.facilities) {\n      const entertainmentEntities = Object.keys(entertainmentToday.facilities);\n      for (let i = 0; i < entertainmentEntities.length; i++) {\n        const facId = entertainmentEntities[i];\n        // look for existing live data doc that has a facility status entry\n        const liveDataIdx = docs.findIndex((x) => x._id === facId);\n        if (liveDataIdx < 0) {\n          // if we don't have a doc already, we create a \"fake\" one\n          // build a pretend facilitystatus doc and push to docs\n          const liveData = await this._buildLiveDataObject({\n            id: facId,\n          });\n          if (liveData) {\n            docs.push(liveData);\n          }\n        }\n      }\n    }\n    \n    // build pretend live entity objects for any attractions with schedules (but no live data!)\n    const attractionsToday = await this.db.get(`${this.resortShortcode}.today.1_0.Attraction`);\n    if (attractionsToday !== undefined && attractionsToday.facilities) {\n      const attractionsEntities = Object.keys(attractionsToday.facilities);\n      for (let i = 0; i < attractionsEntities.length; i++) {\n        const facId = attractionsEntities[i];\n        // look for existing live data doc that has a facility status entry\n        const liveDataIdx = docs.findIndex((x) => x._id === facId);\n        if (liveDataIdx < 0) {\n          const liveData = await this._buildLiveDataObject({\n            id: facId,\n          });\n          if (liveData) {\n            docs.push(liveData);\n          }\n        }\n      }\n    }\n\n    // TODO - do something with invalid objects (?!)\n    // const errors = docs.filter((x) => x.status !== 'fulfilled');\n\n    return docs;\n  }\n\n  /**\n   * Setup our live status update subscriptions\n   */\n  async initLiveStatusUpdates() {\n    // subscribe to any live facility status updates\n    this.db.subscribeToChannel(this.getFacilityStatusChannelID(), async (doc) => {\n      // create our live data object and submit to resort\n      const livedata = await this._buildLiveDataObject(doc);\n      if (!livedata) return; // skip any invalid livedata objects\n\n      try {\n        this.updateEntityLiveData(doc.id, livedata);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  /**\n   * Given a name for an entity, clean up any strings we don't want\n   * @param {string} name\n   * @return {string}\n   */\n  sanitizeEntityName(name) {\n    let newName = `${name}`;\n\n    // trim any name endings we don't want to transfer to our entity object\n    const cutoffExcessiveNameEndings = [\n      ' – Opens',\n      ' - Opens',\n      ' – Reopening',\n      ' - Reopening',\n      ' – Temporarily Unavailable',\n      ' - Temporarily Unavailable',\n      ' – Temporarily ',\n      ' - Temporarily ',\n      ' – Coming ',\n      ' - Coming ',\n      ' – Legacy Passholder Dining',\n      ' - Legacy Passholder Dining',\n      ' – Opening ',\n      ' - Opening ',\n      ' - Returning',\n      ' – Returning',\n      ' – Now Open!',\n    ];\n    cutoffExcessiveNameEndings.forEach((str) => {\n      const substrFound = newName.indexOf(str);\n      if (substrFound > 0) {\n        newName = newName.slice(0, substrFound);\n      }\n    });\n\n    return newName;\n  }\n\n  /**\n   * Given a basic document build a generic entity doc.\n   * This should include all fields that are in any entity type.\n   * @param {object} doc\n   * @return {object}\n   */\n  buildBaseEntityObject(doc) {\n    const entity = {\n      // add any resort-agnostic data from the parent first\n      ...super.buildBaseEntityObject(doc),\n      _id: doc.id,\n      _docId: doc._id,\n      name: this.sanitizeEntityName(doc.name),\n    };\n\n    if (doc.longitude && doc.latitude) {\n      entity.location = {\n        longitude: Number(doc.longitude),\n        latitude: Number(doc.latitude),\n        // TODO - return entrance/exit/shop/etc. interesting points\n        //  that aren't neccessarily the \"main location\"\n        pointsOfInterest: [],\n      };\n    }\n\n    // search for any related locations that is a theme-park - this tells us this entity is within this park!\n    //  set this so we can correctly build our entity heirarchy\n    // skip if our type is actuall \"theme-park\", as parks aren't parented to themselves\n    if (\n      parkTypes.indexOf(doc.type) < 0 &&\n      doc.relatedLocations &&\n      doc.relatedLocations.length > 0 &&\n      doc.relatedLocations[0].ancestors\n    ) {\n      // try to find parkId (if it exists)\n      const park = doc.relatedLocations[0].ancestors.find((x) => {\n        return parkTypes.indexOf(x.type) >= 0;\n      });\n      if (park) {\n        entity._parkId = park.id;\n      }\n    }\n\n    // tags\n    if (doc.facets) {\n      if (doc.facets.find((x) => x.id === 'expectant-mothers')) {\n        entity.unsuitableForPregnantPeople = true;\n      }\n    }\n\n    // TODO - rename so something park-agnostic?\n    if (doc.fastPassPlus !== undefined) {\n      entity.fastPass = !!doc.fastPassPlus;\n    }\n\n    // if we're not inside a park, parent ourselves to the *something*\n    const nonParkParentPriority = [\n      'theme-park',\n      'water-park',\n      'Entertainment-Venue', // eg. Disney Springs\n      'destination',\n    ];\n    // look through list in order until we find an entity we can attach to\n    let parentDoc;\n    if (doc.relatedLocations && doc.relatedLocations.length > 0 && doc.relatedLocations[0].ancestors) {\n      for (let parentTypeIdx = 0; parentTypeIdx < nonParkParentPriority.length; parentTypeIdx++) {\n        const parentType = nonParkParentPriority[parentTypeIdx];\n        parentDoc = doc.relatedLocations[0].ancestors.find((x) => {\n          return x.type === parentType && x.id !== doc.relatedLocations[0].id;\n        });\n        if (parentDoc) break;\n      }\n\n      if (parentDoc) {\n        entity._parentId = parentDoc.id;\n      }\n    }\n\n    return entity;\n  }\n\n  /**\n   * Return entity document for this destination\n   */\n  async buildDestinationEntity() {\n    const resortIndex = await this.db.getEntityIndex(this.resortId, {\n      entityType: 'destination',\n    });\n    if (resortIndex.length === 0) return undefined;\n\n    const doc = await this.db.get(resortIndex[0]._id);\n\n    return {\n      ...this.buildBaseEntityObject(doc),\n      entityType: entityType.destination,\n      slug: doc.name.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(),\n    };\n  }\n\n  /**\n   * Return all park entities for this resort\n   */\n  async buildParkEntities() {\n    const parkData = (await Promise.all(this.parkIds.map(async (parkID) => {\n      return this.db.getEntityOne(parkID);\n    }))).filter((x) => !!x);\n\n    const resort = await this.getDestinationEntity();\n\n    return parkData.map((park) => {\n      return {\n        ...this.buildBaseEntityObject(park),\n        entityType: entityType.park,\n        // parks are parented to the resort\n        _parentId: resort._id,\n        slug: park.name.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(),\n      };\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildAttractionEntities() {\n    const attractions = await this.db.find({\n      type: 'Attraction',\n      relatedLocations: {\n        $elemMatch: {\n          ancestors: {\n            $elemMatch: {\n              id: {\n                $regex: this.destinationDocumentIDRegex,\n              },\n            },\n          },\n        },\n      },\n      // ignore any attractions with zero facets\n      facets: {\n        $exists: true,\n      },\n    });\n\n    // filter out known bad names\n    const ignoreAttractions = [\n      /^Disney Park Pass$/,\n      /Park Pass \\- Afternoon$/,\n      /Play Disney Parks/,\n      /^Temporarily Unavailable Entertainment/,\n    ];\n\n    const entities = attractions.filter((attr) => {\n      return !ignoreAttractions.find((x) => {\n        return !!attr.name.match(x);\n      });\n    }).map((attraction) => {\n      // turn into entity objects\n\n      // TODO - add extra meta data to entity objects\n      let type = attractionType.unknown;\n      const hasFacet = (facet) => {\n        if (!attraction?.facets) return false;\n        return !!attraction.facets.find((x) => {\n          return x.id === facet;\n        });\n      };\n\n      // figure out ride type from available facets...\n      if (\n        hasFacet('slow-rides') ||\n        hasFacet('small-drops') ||\n        hasFacet('thrill-rides') ||\n        hasFacet('spinning')\n      ) {\n        type = attractionType.ride;\n      }\n\n      return {\n        ...this.buildBaseEntityObject(attraction),\n        entityType: entityType.attraction,\n        attractionType: type,\n      };\n    });\n\n    return entities;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildShowEntities() {\n    // filter out known bad names\n    const ignoreShows = [\n      /^Temporarily Unavailable Entertainment/,\n    ];\n\n    return (await this.db.find({\n      type: 'Entertainment',\n      relatedLocations: {\n        $elemMatch: {\n          ancestors: {\n            $elemMatch: {\n              id: {\n                $regex: this.destinationDocumentIDRegex,\n              },\n            },\n          },\n        },\n      },\n    })).filter((show) => {\n      return !ignoreShows.find((x) => {\n        return !!show.name.match(x);\n      });\n    }).map((re) => {\n      return {\n        ...this.buildBaseEntityObject(re),\n        entityType: entityType.show,\n      };\n    });\n  }\n\n  /**\n   * Fetch restaurant menu JSON\n   * @param {string} id\n   * @private\n   */\n  async _fetchRestaurantMenu(id) {\n    // TODO - implement a separate menu service\n    //  this API returns errors *a lot*, so we should fetch on a very gentle cycle and cache heavily\n    return null;\n\n    return this.cache.wrap(\n      `menu_${id}`,\n      async () => {\n        try {\n          const data = await this.http(\n            'GET',\n            `https://dining-menu-svc.wdprapps.disney.com/diningMenuSvc/orchestration/menus/${id}`,\n            null,\n            {\n              retries: 0,\n            },\n          );\n          if (data && data.body) {\n            return data.body;\n          }\n        } catch (e) { }\n        return null;\n      },\n      1000 * 60 * 60 * 6, // cache for 6 hours\n    );\n  }\n\n  /**\n   * Get the menu for a given resturant entity ID\n   * @param {string} id\n   */\n  async getRestaurantMenu(id) {\n    try {\n      const menu = await this._fetchRestaurantMenu(id);\n      if (!menu) return undefined;\n\n      const menuData = menu.menus.map((menuGroup) => {\n        if (!menuGroup.menuGroups) {\n          return undefined;\n        }\n\n        const items = [];\n\n        let groupPrice = null;\n\n        // WDW menus are split into Entree,Desert etc. \"menuGroups\" - loop through them all and build them into a list\n        menuGroup.menuGroups.forEach((group) => {\n          // look for buffet pricings\n          // extract characters and digits to find pricing categories\n          const findBuffetPrices = /([^\\/\\(]+\\d+\\.\\d+)/g;\n          let match;\n          while (match = findBuffetPrices.exec(group.names.PCLong)) {\n            // split each buffet price into name and USD\n            const nameAndPrice = /(.*)\\s+(\\d+\\.\\d+)/;\n            const priceData = nameAndPrice.exec(match[1]);\n            if (priceData) {\n              if (groupPrice === null) {\n                groupPrice = [];\n              }\n\n              // add each unique price name once\n              const priceName = priceData[1].trim();\n              if (groupPrice.findIndex((x) => x.name === priceName) < 0) {\n                groupPrice.push({\n                  name: priceData[1].trim(),\n                  USD: Number(priceData[2]) * 100,\n                });\n              }\n            }\n          }\n\n          group.menuItems.forEach((dish) => {\n            const newDish = {\n              name: dish.names.PCLong || dish.names.MobileLong || dish.names.PCShort || dish.names.MobileShort || null,\n              description: dish?.descriptions?.PCLong?.text ||\n                dish?.descriptions?.MobileLong?.text ||\n                dish?.descriptions?.MobileShort?.text ||\n                null,\n              group: group.menuGroupType,\n              price: null,\n            };\n\n            if (dish?.prices?.PerServing?.withoutTax) {\n              // standard per-serving prices\n              newDish.price = [{\n                USD: dish.prices.PerServing.withoutTax * 100,\n              }];\n            } else if (dish.prices) {\n              // not per serving price\n              newDish.price = Object.keys(dish.prices).map((x) => {\n                return {\n                  name: dish.prices[x].type,\n                  USD: dish.prices[x].withoutTax * 100,\n                };\n              });\n            }\n\n            items.push(newDish);\n          });\n        });\n\n        return {\n          type: menuGroup.menuType,\n          description: `${menuGroup.primaryCuisineType} - ${menuGroup.serviceStyle} - ${menuGroup.experienceType}`,\n          items,\n          price: groupPrice, // a menu can have a price (buffets etc.)\n        };\n      }).filter((x) => !!x);\n\n      return menuData;\n    } catch (e) {\n      console.error(e);\n    }\n    return undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildRestaurantEntities() {\n    const restaurants = (await this.db.find({\n      type: 'restaurant',\n      relatedLocations: {\n        $elemMatch: {\n          ancestors: {\n            $elemMatch: {\n              id: {\n                $regex: this.destinationDocumentIDRegex,\n              },\n            },\n          },\n        },\n      },\n    })).filter((restaurant) => {\n      // only include \"proper\" resturants\n      //  avoid listing every coffee stand etc.\n\n      // determine resturant type using available facets\n      if (!restaurant.facets) return false;\n      const tableService = restaurant.facets.find((x) => x.id === 'table-service');\n      // some resturants are missing the 'table-service' facet, but have other facets that are similar\n      const tableReservations = restaurant.facets.find((x) => x.id === 'reservations-accepted');\n      // TODO - also add quick service\n      return !!tableService || !!tableReservations;\n    }).map((re) => {\n      // TODO - populate with any other interesting restaurant detail\n      return {\n        ...this.buildBaseEntityObject(re),\n        entityType: entityType.restaurant,\n        // list of available cuisines\n        cuisines: re.facets.filter((x) => x.group === 'cuisine').map((x) => {\n          return x.name;\n        }),\n      };\n    });\n\n    // fetch menus\n    /* for (let i = 0; i < restaurants.length; i++) {\n      restaurants[i].menus = (await this.getRestaurantMenu(restaurants[i]._id)) || null;\n    }*/\n\n    return restaurants;\n  }\n\n  /**\n   *\n   * @param {array<string>} ids document IDs to get schedules for\n   * @param {moment} date Moment date to get schedule data for\n   * @return {array<object>} Array of objects containing _id and schedule\n   */\n  async _getSchedulesForDate(ids, date) {\n    const dateCalendar = await this.db.getByChannel(\n      `${this.config.resortShortcode}.calendar.1_0`,\n      {\n        'id': date.format('DD-MM'),\n      },\n    );\n\n    if (dateCalendar.length === 0) {\n      return [];\n    }\n    const calendar = dateCalendar[0];\n\n    const hours = calendar.parkHours.filter((h) => {\n      // filter for hours for any of our parks\n      return ids.indexOf(h.facilityId) >= 0 &&\n        // that aren't closed hours (just ignore these)\n        h.scheduleType !== 'Closed' &&\n        // ignore annual pass blockout data\n        h.scheduleType.indexOf('blockout') < 0;\n    }).reduce((p, x) => {\n      let hoursType = scheduleType.operating;\n\n      switch (x.scheduleType) {\n        case 'Operating':\n          hoursType = scheduleType.operating;\n          break;\n        case 'Park Hopping':\n          hoursType = scheduleType.informational;\n          break;\n        case 'Refurbishment':\n          // return refurbishment hours as purely informational\n          hoursType = scheduleType.informational;\n          break;\n        default:\n          // default to a ticketed event\n          hoursType = scheduleType.ticketed;\n          break;\n      }\n\n      p[ids.indexOf(x.facilityId)].schedule.push({\n        date: moment(x.startTime).tz(this.config.timezone).format('YYYY-MM-DD'),\n        openingTime: moment(x.startTime).tz(this.config.timezone).format(),\n        closingTime: moment(x.endTime).tz(this.config.timezone).format(),\n        type: hoursType,\n        description: hoursType != scheduleType.operating ? x.scheduleType : undefined,\n      });\n\n      return p;\n    }, ids.map((x) => {\n      return {\n        _id: x,\n        schedule: [],\n      };\n    }));\n\n    return hours;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async buildEntityScheduleData() {\n    // grab park IDs!\n    const parks = await this.getParkEntities();\n    const parkIds = parks.map((x) => {\n      return x._id;\n    });\n\n    // grab schedules for our parks\n    const daysToReturn = 150;\n    const now = this.getTimeNowMoment();\n    const endDate = now.clone().add(daysToReturn, 'day');\n    const returnData = parkIds.map((x) => {\n      return {\n        _id: x,\n        schedule: [],\n      };\n    });\n    for (; now.isSameOrBefore(endDate, 'day'); now.add(1, 'day')) {\n      const dateData = await this._getSchedulesForDate(parkIds, now);\n      dateData.forEach((entity) => {\n        returnData[parkIds.indexOf(entity._id)].schedule.push(...entity.schedule);\n      });\n    }\n    return returnData;\n  }\n};\n\n/**\n * Walt Disney World Resort\n */\nexport class WaltDisneyWorldResort extends DisneyLiveResort {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Walt Disney World Resort';\n    options.timezone = options.timezone || 'America/New_York';\n\n    options.resortId = options.resortId || 80007798;\n    options.resortShortcode = options.resortShortcode || 'wdw';\n\n    options.parkIds = options.parkIds || [\n      80007944, // Magic Kingdom\n      80007838, // Epcot\n      80007998, // Hollywood Studios\n      80007823, // Animal Kingdom\n      // water parks\n      80007981, // Typhoon Lagoon\n      80007834, // Blizzard Beach\n    ];\n\n    super(options);\n  }\n}\n\n/**\n * Disneyland Resort\n */\nexport class DisneylandResort extends DisneyLiveResort {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Disneyland Resort';\n    // TODO - calculate this from resort entity's location\n    options.timezone = options.timezone || 'America/Los_Angeles';\n\n    options.resortId = options.resortId || 80008297;\n    options.resortShortcode = options.resortShortcode || 'dlr';\n\n    options.parkIds = options.parkIds || [\n      330339, // Disneyland Park\n      336894, // California Adventure\n    ];\n\n    super(options);\n  }\n}\n\n/**\n * Hong Kong Disneyland Resort\n */\nexport class HongKongDisneyland extends DisneyLiveResort {\n  /**\n   * @inheritdoc\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'HongKong Disneyland';\n    // TODO - calculate this from resort entity's location\n    options.timezone = options.timezone || 'Asia/Hong_Kong';\n\n    options.resortId = options.resortId || 'hkdl';\n    options.resortShortcode = options.resortShortcode || 'hkdl';\n\n    options.parkIds = options.parkIds || [\n      'desHongKongDisneyland',\n    ];\n\n    super(options);\n  }\n\n  /**\n   * HK stores menus as PDFs, this function does nothing (yet?)\n   * @return {null}\n   */\n  async _fetchRestaurantMenu() {\n    return null;\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 626,
    "kind": "variable",
    "name": "wdwDB",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~wdwDB",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 627,
    "kind": "function",
    "name": "getDatabase",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~getDatabase",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{getDatabase}",
    "description": "Get a reference to the WDW database",
    "lineNumber": 11,
    "return": {
      "nullable": null,
      "types": [
        "IndexedWDWDB"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 628,
    "kind": "variable",
    "name": "parkTypes",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~parkTypes",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 629,
    "kind": "variable",
    "name": "invalidScheduleTypes",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~invalidScheduleTypes",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 630,
    "kind": "class",
    "name": "DisneyLiveResort",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{DisneyLiveResort}",
    "description": "A Resort class for a Disney live resort (WDW, DLR, HKDR)",
    "lineNumber": 33,
    "interface": false,
    "extends": [
      "lib/parks/destination.js~Destination"
    ]
  },
  {
    "__docId__": 631,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 632,
    "kind": "member",
    "name": "resortId",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#resortId",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 633,
    "kind": "member",
    "name": "resortShortcode",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#resortShortcode",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 634,
    "kind": "member",
    "name": "destinationDocumentIDRegex",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#destinationDocumentIDRegex",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 635,
    "kind": "member",
    "name": "parkIds",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#parkIds",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 636,
    "kind": "member",
    "name": "db",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#db",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 637,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#_init",
    "access": "private",
    "description": "Initialise our Disney resort class",
    "lineNumber": 60,
    "params": [],
    "return": null
  },
  {
    "__docId__": 638,
    "kind": "method",
    "name": "getFacilityStatusChannelID",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#getFacilityStatusChannelID",
    "access": "public",
    "description": "Get the channel ID for the facility status live update documents",
    "lineNumber": 71,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 639,
    "kind": "method",
    "name": "fetchVirtualQueueData",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#fetchVirtualQueueData",
    "access": "private",
    "description": "",
    "lineNumber": 78,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 640,
    "kind": "method",
    "name": "fetchGenieData",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#fetchGenieData",
    "access": "public",
    "description": null,
    "lineNumber": 89,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 641,
    "kind": "method",
    "name": "_buildLiveDataObject",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#_buildLiveDataObject",
    "access": "private",
    "description": "Given a status doc, build a live data object",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 642,
    "kind": "method",
    "name": "buildEntityLiveData",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#buildEntityLiveData",
    "access": "public",
    "description": "Return all current live entity data",
    "lineNumber": 392,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 643,
    "kind": "method",
    "name": "initLiveStatusUpdates",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#initLiveStatusUpdates",
    "access": "public",
    "description": "Setup our live status update subscriptions",
    "lineNumber": 464,
    "params": [],
    "return": null
  },
  {
    "__docId__": 644,
    "kind": "method",
    "name": "sanitizeEntityName",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#sanitizeEntityName",
    "access": "public",
    "description": "Given a name for an entity, clean up any strings we don't want",
    "lineNumber": 484,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 645,
    "kind": "method",
    "name": "buildBaseEntityObject",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#buildBaseEntityObject",
    "access": "public",
    "description": "Given a basic document build a generic entity doc.<br />This should include all fields that are in any entity type.",
    "lineNumber": 523,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 646,
    "kind": "method",
    "name": "buildDestinationEntity",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#buildDestinationEntity",
    "access": "public",
    "description": "Return entity document for this destination",
    "lineNumber": 601,
    "params": [],
    "return": {
      "types": [
        "{...undefined: Object, \"entityType\": *, \"slug\": *}"
      ]
    }
  },
  {
    "__docId__": 647,
    "kind": "method",
    "name": "buildParkEntities",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#buildParkEntities",
    "access": "public",
    "description": "Return all park entities for this resort",
    "lineNumber": 619,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 648,
    "kind": "method",
    "name": "buildAttractionEntities",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#buildAttractionEntities",
    "access": "public",
    "description": "",
    "lineNumber": 640,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 649,
    "kind": "method",
    "name": "buildShowEntities",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#buildShowEntities",
    "access": "public",
    "description": "",
    "lineNumber": 707,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 650,
    "kind": "method",
    "name": "_fetchRestaurantMenu",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#_fetchRestaurantMenu",
    "access": "private",
    "description": "Fetch restaurant menu JSON",
    "lineNumber": 743,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 651,
    "kind": "method",
    "name": "getRestaurantMenu",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#getRestaurantMenu",
    "access": "public",
    "description": "Get the menu for a given resturant entity ID",
    "lineNumber": 774,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 652,
    "kind": "method",
    "name": "buildRestaurantEntities",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#buildRestaurantEntities",
    "access": "public",
    "description": "",
    "lineNumber": 862,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 653,
    "kind": "method",
    "name": "_getSchedulesForDate",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#_getSchedulesForDate",
    "access": "private",
    "description": "",
    "lineNumber": 913,
    "params": [
      {
        "nullable": null,
        "types": [
          "array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "document IDs to get schedules for"
      },
      {
        "nullable": null,
        "types": [
          "moment"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": "Moment date to get schedule data for"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": "Array of objects containing _id and schedule"
    }
  },
  {
    "__docId__": 654,
    "kind": "method",
    "name": "buildEntityScheduleData",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyLiveResort#buildEntityScheduleData",
    "access": "public",
    "description": "",
    "lineNumber": 975,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 655,
    "kind": "class",
    "name": "WaltDisneyWorldResort",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldResort",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{WaltDisneyWorldResort}",
    "description": "Walt Disney World Resort",
    "lineNumber": 1005,
    "interface": false,
    "extends": [
      "DisneyLiveResort"
    ]
  },
  {
    "__docId__": 656,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldResort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~WaltDisneyWorldResort#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 1009,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 657,
    "kind": "class",
    "name": "DisneylandResort",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneylandResort",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{DisneylandResort}",
    "description": "Disneyland Resort",
    "lineNumber": 1033,
    "interface": false,
    "extends": [
      "DisneyLiveResort"
    ]
  },
  {
    "__docId__": 658,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneylandResort",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneylandResort#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 1037,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 659,
    "kind": "class",
    "name": "HongKongDisneyland",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~HongKongDisneyland",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{HongKongDisneyland}",
    "description": "Hong Kong Disneyland Resort",
    "lineNumber": 1057,
    "interface": false,
    "extends": [
      "DisneyLiveResort"
    ]
  },
  {
    "__docId__": 660,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~HongKongDisneyland",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~HongKongDisneyland#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 1061,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 661,
    "kind": "method",
    "name": "_fetchRestaurantMenu",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~HongKongDisneyland",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~HongKongDisneyland#_fetchRestaurantMenu",
    "access": "private",
    "description": "HK stores menus as PDFs, this function does nothing (yet?)",
    "lineNumber": 1080,
    "return": {
      "nullable": null,
      "types": [
        "null"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 662,
    "kind": "file",
    "name": "lib/parks/wdw/wdwdatabase.js",
    "content": "import Database from '../database.js';\nimport WDWDB from './wdwdb.js';\n\n/**\n * @inheritdoc\n */\nexport class DatabaseWDW extends Database {\n  /**\n   * @inheritdoc\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    super(options);\n\n    this.db = new WDWDB();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getEntities() {\n    // make sure our synced database is up-to-date\n    await this.db.init();\n  }\n}\n\nexport default DatabaseWDW;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/wdw/wdwdatabase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 663,
    "kind": "class",
    "name": "DatabaseWDW",
    "memberof": "lib/parks/wdw/wdwdatabase.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdatabase.js",
    "importStyle": "{DatabaseWDW}",
    "description": "",
    "lineNumber": 7,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "lib/parks/database.js~Database"
    ]
  },
  {
    "__docId__": 664,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 665,
    "kind": "member",
    "name": "db",
    "memberof": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW",
    "static": false,
    "longname": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW#db",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 666,
    "kind": "method",
    "name": "_getEntities",
    "memberof": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdatabase.js~DatabaseWDW#_getEntities",
    "access": "private",
    "description": "",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 667,
    "kind": "file",
    "name": "lib/parks/wdw/wdwdb.js",
    "content": "import PouchDB from 'pouchdb';\nimport sift from 'sift';\nimport {promises as fs, constants as fsConstants, createReadStream, createWriteStream} from 'fs';\nimport path from 'path';\n\nimport {parseConfig} from '../../configBase.js';\n\n/**\n * Given a document, return it's entity ID for the WDW database\n * @param {object|string} doc CouchDB document or a document ID\n * @return {string}\n */\nexport function getEntityID(doc) {\n  const docId = doc?.id || doc;\n\n  if (!docId) {\n    console.trace('Unable to find ID from', JSON.stringify(doc));\n    return undefined;\n  }\n\n  const stack = docId.split(':');\n  const lowestLevelEntity = stack[stack.length - 1];\n\n  const parts = lowestLevelEntity.split(';');\n  if (parts <= 1) return undefined;\n\n  return parts.find((p) => {\n    // edge-case for some documents with no attraction attached (guessing test documents)\n    if (p === 'Unassigned') return false;\n\n    const keyval = p.split('=');\n    return (keyval.length === 1);\n  });\n}\n\n// internal key names for our indexes. Stored as constants to save typing these over and over\nconst constants = {\n  INDEX_FACILITYSTATUS: 'facilityStatus',\n  INDEX_CHANNELS: 'channels',\n  INDEX_ENTITIES: 'entities',\n  INDEX_CHILDREN: 'children',\n  INDEX_NAMES: 'names',\n  INDEX_IDS: 'ids',\n};\n\n// ancestors to include in our index\n//  we add these into our index objects to identify unique documents to index\nconst ancestorIndexes = [\n  {\n    key: 'ancestorLandId',\n    index: 'land_id',\n  },\n  {\n    key: 'ancestorResortId',\n    index: 'resort_id',\n  },\n  {\n    key: 'ancestorResortAreaId',\n    index: 'resort_area_id',\n  },\n  {\n    key: 'ancestorThemeParkId',\n    index: 'park_id',\n  },\n];\n\n// Super() function to call when we setup this class as a plugin\nconst pouchBulkDocs = PouchDB.prototype.bulkDocs;\n\n/**\n * An indexed live WDW database\n * Replicated WDW database to local disk for fast access\n * While replicating, will build an in-memory index of entities for fast lookup\n * Options to dump database to a single file or load a snapshot for quicker database boot ups\n */\nexport class IndexedWDWDB extends PouchDB {\n  /**\n   * Construct a new IndexedWDWDB object\n   * @param {object} opts PouchDB options object\n   * @param {string} [opts.remoteHost] Remote database to replicate\n   * @param {string} [opts.remoteUsername] Remote database username to authenticate\n   * @param {string} [opts.remotePassword] Remote database password to authenticate\n   * @param {string} [opts.dbName='wdw'] Local database name\n   * @param {string} [opts.snapshot] File location of a snapshot to 'seed' the database during startup\n   * @param {string} [opts.skipSync] Skip network replication, only use data already on disk\n   * @extends PouchDB\n   */\n  constructor(opts = {}) {\n    // default to enable auto_compaction\n    opts.auto_compaction = opts.auto_compaction || true;\n\n    opts.remoteHost = '';\n    opts.remoteUsername = '';\n    opts.remotePassword = '';\n    opts.dbName = opts.dbName || 'wdw';\n    opts.snapshot = ''; // optional snapshot to use when starting database\n    // 'name' is the config option pouchdb uses for the storage path\n    opts.name = opts.name || IndexedWDWDB.getDatabaseFilePath(opts.dbName);\n\n    opts.skipSync = opts.skipSync === undefined ? false : opts.skipSync;\n\n    opts.restartTimeout = opts.restartTimeout || 5;\n\n    opts.configPrefixes = ['WDWDB'].concat(opts.configPrefixes || []);\n    const config = parseConfig(opts);\n\n    super(config);\n    this.config = config;\n\n    // increase the maximum listeners to this database\n    this.setMaxListeners(50);\n\n    // setup our remote host to replicate locally\n    if (this.config.remoteHost) {\n      const remoteHostOptions = {\n        skip_setup: true,\n      };\n      if (this.config.remoteUsername && this.config.remotePassword) {\n        remoteHostOptions.auth = {\n          username: this.config.remoteUsername,\n          password: this.config.remotePassword,\n        };\n      }\n\n      this.remoteDB = new PouchDB(this.config.remoteHost, remoteHostOptions);\n    }\n\n    this.synced = false;\n    this.replicating = false;\n\n    this._index = {};\n    this._setupPromise = null;\n    this._indexSetup = false;\n  }\n\n  /**\n * Get the LevelDOWN database location to use\n * @param {string} name Database name\n * @return {string}\n */\n  static getDatabaseFilePath(name) {\n    return path.join(process.cwd(), `db.${name}`);\n  }\n\n  /**\n   * Initialise the live database, returns once finished an initial sync\n   */\n  async init() {\n    if (this.synced) {\n      return;\n    }\n\n    if (this.initPromiseSync) return this.initPromiseSync;\n\n    // first, syncronise our database before we start rolling updates\n    this.initPromiseSync = this._loadAndInit();\n    // keep the Promise as a variable so we can keep returning it for any additional init() calls\n    await this.initPromiseSync;\n    this.initPromiseSync = null;\n\n    console.log(`Database finished setup!`);\n\n    this.synced = true;\n\n    if (!this.config.skipSync && this.remoteDB) {\n      this._replicate();\n    }\n  }\n\n  /**\n   * Start database replication\n   * @private\n   */\n  _replicate() {\n    if (this.replicating) return;\n    this.replicating = true;\n\n    let noChangeTimeout = null;\n    let replicationHandle = null;\n\n    // how many minutes before killing and restarting replication\n    const noChangeTimer = Number(this.config.restartTimeout) || 5;\n\n    // function to reboot the replicate based on various possible failure states\n    const rebootReplicator = (err) => {\n      if (noChangeTimeout) {\n        clearTimeout(noChangeTimeout);\n      }\n      if (replicationHandle) {\n        replicationHandle.cancel();\n        replicationHandle = null;\n      }\n\n      if (err) {\n        console.error('Replication Error!', new Date(), err);\n      }\n\n      // console.log('Restarting replicator...');\n      this.replicating = false;\n      setTimeout(this._replicate.bind(this), 1000);\n    };\n\n    const resetTimeoutTimer = () => {\n      if (noChangeTimeout) {\n        clearTimeout(noChangeTimeout);\n      }\n      noChangeTimeout = setTimeout(() => {\n        // console.log('Replicator timed out...');\n        rebootReplicator();\n      }, 1000 * 60 * noChangeTimer);\n    };\n\n    try {\n      replicationHandle = PouchDB.replicate(this.remoteDB, this, {\n        live: true,\n        retry: true,\n      }).on('change', () => {\n        // reset a timer whenever we get a change\n        //  if the timer is ever fired, we will restart the replicator\n        resetTimeoutTimer();\n      }).on('error', (e) => {\n        rebootReplicator(e);\n      });\n\n      // always start the change timer immediately\n      //  otherwise if we start repliating in the middle of the night (when no changes are happening)\n      //  on('change') never fires, so we can lose connection and never fire the timeout\n      resetTimeoutTimer();\n    } catch (e) {\n      rebootReplicator(e);\n    }\n  }\n\n  /**\n   * Internal function\n   * Loads and performs an initial sync on the database\n   * @private\n   */\n  async _loadAndInit() {\n    // load up our indexes\n    await this._initIndexes();\n\n    // reindex every document once we've initialised from disk\n    //  do this before replication, since all new docs will be auto-indexed\n    const docs = await this.allDocs({\n      include_docs: true,\n    });\n    console.log('Building index...');\n    await Promise.allSettled(docs.rows.map((doc) => {\n      return this._indexWDWDocument(doc.doc);\n    }));\n\n    // optionally skip replicating with remote (for local fast testing)\n    if (this.config.skipSync || !this.remoteDB) {\n      return;\n    }\n\n    // then perform an initial replication from remote to local\n    console.log('Performing initial replication...');\n    return await PouchDB.replicate(this.remoteDB, this, {\n      batch_size: 500,\n    }).catch((e) => {\n      console.error(`Replication error: ${e}`);\n    });\n  }\n\n  /**\n   * Get the filename we use for saving backups of the database to disk\n   * Used for creating simple \"snapshots\" to reduce initial sync times\n   * @param {string} [postfix] Optional postfix for the filename\n   * eg. Use postfix to generate a temporary version of a file to write to before replacing the \"real\" database\n   * @return {string}\n   */\n  getDumpFilename(postfix = '') {\n    return path.join('localdb', `${this.config.dbName}${postfix}.db`);\n  }\n\n  /**\n   * Restore a database backup from disk\n   * Perform this after running \"dump()\" on a previous synced database\n   * This will help to reduce the initial sync time for large databases\n   * @param {string} [snapshotFile] File path of the snapshot to restore into the database\n   * snapshotFile will use default saveSnapshot result location if not supplied\n   */\n  async loadSnapshot(snapshotFile = '') {\n    throw new Error('Missing Implementation');\n    if (this.synced || this.replicating) {\n      console.warn('Trying to load database snapshot when replication has already started');\n      return;\n    }\n\n    const useCustomSnapshot = !!snapshotFile;\n    const dumpPath = useCustomSnapshot ? snapshotFile : this.getDumpFilename();\n\n    // if our database dump doesn't exist, then early out and we'll do a normal sync\n    try {\n      await fs.access(dumpPath, fsConstants.F_OK);\n    } catch (error) {\n      return;\n    }\n\n    console.log('Restoring database from disk...');\n\n    // otherwise, load up our database from disk\n    const ws = createReadStream(dumpPath);\n    return this.load(ws, {\n      batch_size: 500,\n    });\n  }\n\n  /**\n   * Save a snapshot of this live database to disk\n   * This will be used to \"seed\" the database to speed up syncs for future runs\n   * @return {string} Path to resulting database snapshot\n   */\n  async saveSnapshot() {\n    throw new Error('Missing Implementation');\n    if (this.databaseDumpPendingPromise) {\n      return this.databaseDumpPendingPromise;\n    }\n\n    console.log('Dumping database to disk...');\n\n    const dumpPath = this.getDumpFilename();\n    const dumpPathNew = this.getDumpFilename('_new');\n\n    // dump database to our new location\n    const ws = createWriteStream(dumpPathNew);\n    this.databaseDumpPendingPromise = this.dump(ws, {\n      batch_size: 500,\n    });\n    // save Promise so multiple \"dump()\" calls can stack cleanly\n    await this.databaseDumpPendingPromise;\n    this.databaseDumpPendingPromise = null;\n\n    // rename new database dump to our final intended location\n    return fs.rename(dumpPathNew, dumpPath).then(() => {\n      // finally, return the actual path of the snapshot\n      return dumpPath;\n    });\n  }\n\n  /**\n   * Index initialisation\n   * This function wraps taking care of creating our indexes once only\n   * @private\n   */\n  async _initIndexes() {\n    if (this._indexSetup) {\n      return;\n    }\n\n    if (this._setupPromise) {\n      return this._setupPromise;\n    }\n\n    this._setupPromise = this._createIndexes();\n    await this._setupPromise;\n    this._indexSetup = true;\n    return;\n  }\n\n  /**\n   * Setup our WDW indexes\n   * @private\n   */\n  async _createIndexes() {\n    await this._createIndex(constants.INDEX_ENTITIES);\n    await this._createIndex(constants.INDEX_CHANNELS);\n    await this._createIndex(constants.INDEX_FACILITYSTATUS, []);\n    await this._createIndex(constants.INDEX_CHILDREN);\n    await this._createIndex(constants.INDEX_NAMES);\n    await this._createIndex(constants.INDEX_IDS, []);\n  }\n\n  /**\n   * Get the internal index object for the given index type\n   * @param {object} name Index name (see constants.INDEX_*)\n   * @return {*}\n   * @private\n   */\n  getIndex(name) {\n    return this._index[name].index;\n  }\n\n  /**\n   * Create an index object to be used by this database\n   * @param {string} name Index name\n   * @param {*} defaultIndex Index initial object state\n   * @private\n   */\n  async _createIndex(name, defaultIndex = {}) {\n    this._index[name] = {\n      index: defaultIndex,\n    };\n  }\n\n  /**\n   * Given a WDW document, extract key identifiable data\n   * This is used to build a look-up index of unique document types\n   * See ancestorIndexes for some of the keys we use\n   * This is important so we can tell the difference between entities with the same ID, but different purposes\n   * eg. an entity ID can have multiple documents, one for the attraction itself, one for it's wait times, etc.\n   * These need to both be in the index under the same entity ID, but with different properties to make them distinct\n   * @param {object} doc WDW Database Document\n   * @return {object} Index object containing important identifying data\n   * @private\n   */\n  _extractEntityKeys(doc) {\n    if (!doc || !doc.id) return undefined;\n\n    // some IDs are stacked using :\n    const stack = doc.id.split(':');\n    const lowestLevelEntity = stack[stack.length - 1];\n\n    const parts = lowestLevelEntity.split(';');\n    if (parts <= 1) return undefined;\n\n    // some documents can have different parents, they're the same, but different path to get there\n    const parentStackEl = stack.length > 1 ? stack[stack.length - 2] : undefined;\n    const parent = parentStackEl ? this._extractEntityKeys({id: parentStackEl}).id : undefined;\n\n    const ret = {\n      parent,\n    };\n\n    // special case for calendars\n    if (doc.channels.find((x) => x.indexOf('.calendar.') >= 0) !== undefined) {\n      ret.entityType = 'calendar';\n    }\n\n    parts.forEach((p) => {\n      const keyval = p.split('=');\n      if (keyval.length === 1) {\n        ret.id = keyval[0];\n      } else {\n        ret[keyval[0]] = keyval[1];\n      }\n    });\n\n    // if this document is in a \"facilitystatus\" channel, add an extra tag\n    //  this is so we don't collide with the actaul document for this attraction\n    //  but also so we can filter it easier later\n    const facilityStatus = doc.channels && (doc.channels.find((x) => x.indexOf('facilitystatus') >= 0) !== undefined);\n    if (facilityStatus) {\n      ret.facilityStatus = true;\n    }\n\n    // include channels in our index\n    if (doc.channels) {\n      const channels = JSON.parse(JSON.stringify(doc.channels));\n      channels.sort();\n      ret.channel = channels.join(',');\n    }\n\n    // add any ancestor data to our index (that we a) care about and b) can find) - see ancestorIndexes\n    ancestorIndexes.forEach((ancestorIndex) => {\n      if (doc[ancestorIndex.key]) {\n        const ancestorID = getEntityID(doc[ancestorIndex.key]);\n        if (ancestorID) {\n          ret[ancestorIndex.index] = ancestorID;\n        }\n      }\n    });\n\n    return ret;\n  }\n\n  /**\n   * Given a WDW database document, try to return its language\n   * @param {object} doc\n   * @return {string} Language of this document. Eg. en_intl, en_us\n   * @private\n   */\n  _extractChannelLanguage(doc) {\n    // pull channel from doc\n    if (!doc.channels) return undefined;\n\n    const langs = doc.channels.map((x) => {\n      // extract last \\.* from the end of the channel name\n      // language-specific channels end with \"en_us\" or something\n      // channels without locale end with a version number eg. \"1_0\"\n      return x.slice(x.lastIndexOf('.') + 1);\n    }).filter((x) => {\n      // check each one to see the language tag starts with a version number\n      return isNaN(Number(x.slice(0, 1)));\n    });\n\n    // default to 'en_intl' if we cannot find a language in our channels\n    return langs[0] || 'en_intl';\n  }\n\n  /**\n   * Remove all indexes referencing docID from the given index\n   * @param {object} index\n   * @param {string} docID\n   */\n  _removeFromArrayIndex(index, docID) {\n    Object.keys(index).forEach((key) => {\n      const indexIDs = index[key].map(\n        (x, idx) => {\n          return x._id === docID ? idx : undefined;\n        }).\n        filter((x) => x !== undefined);\n\n      indexIDs.forEach((idx) => {\n        index[key].splice(idx, 1);\n      });\n    });\n  }\n\n  /**\n   * Add a document to the database index\n   * Used for fast lookups of entities etc. to the correct documents\n   * @param {object} doc CouchDB document to index\n   * @private\n   */\n  async _indexWDWDocument(doc) {\n    const idIndex = this.getIndex(constants.INDEX_IDS);\n\n    if (doc._deleted) {\n      // remove document from all indexes\n\n      // facility status\n      //  quick hack to turn the facility status index into the same type as the others so I can reuse my code\n      const facilityIndexObject = {index: this.getIndex(constants.INDEX_FACILITYSTATUS)};\n      this._removeFromArrayIndex(facilityIndexObject, doc._id);\n\n      // channels\n      this._removeFromArrayIndex(this.getIndex(constants.INDEX_CHANNELS), doc._id);\n\n      // entity index\n      this._removeFromArrayIndex(this.getIndex(constants.INDEX_ENTITIES), doc._id);\n\n      // id index\n      const idIndexIDX = idIndex.indexOf(doc._id);\n      if (idIndexIDX >= 0) {\n        idIndex.splice(idIndexIDX, 1);\n      }\n\n      // ancestor data\n      //  look through all ancestor index items and remove this document\n      const childIndex = this.getIndex(constants.INDEX_CHILDREN);\n      const indexIDs = Object.keys(childIndex);\n      indexIDs.forEach((index) => {\n        const idx = childIndex[index].indexOf(doc._id);\n        if (idx >= 0) {\n          childIndex[index].splice(idx, 1);\n        }\n      });\n\n      // name index\n      const nameIndex = this.getIndex(constants.INDEX_NAMES);\n      const nameIndexIDs = Object.keys(nameIndex);\n      nameIndexIDs.forEach((index) => {\n        const idx = childIndex[index].indexOf(doc._id);\n        if (idx >= 0) {\n          childIndex[index].splice(idx, 1);\n        }\n      });\n\n      return;\n    }\n\n    // always add doc ID to our ID index\n    if (idIndex.indexOf(doc._id) < 0) {\n      idIndex.push(doc._id);\n    }\n\n    const entity = this._extractEntityKeys(doc);\n    if (entity && entity.id && entity.entityType) {\n      const id = entity.id;\n\n      const newIndexEntry = {\n        ...entity,\n        language: this._extractChannelLanguage(doc),\n        _id: doc._id,\n      };\n\n      // special-case, index all facility status documents in another index\n      if (newIndexEntry.facilityStatus) {\n        const facilityIndex = this.getIndex(constants.INDEX_FACILITYSTATUS);\n\n        const docExists = facilityIndex.findIndex((x) => {\n          return x.id === newIndexEntry.id;\n        });\n        if (docExists >= 0) {\n          facilityIndex[docExists] = newIndexEntry;\n        } else {\n          facilityIndex.push(newIndexEntry);\n        }\n      }\n\n      // index all documents based on channel\n      if (doc.channels) {\n        const channelIndex = this.getIndex(constants.INDEX_CHANNELS);\n        doc.channels.forEach((channel) => {\n          if (!channelIndex[channel]) {\n            channelIndex[channel] = [];\n          }\n          channelIndex[channel].push(newIndexEntry);\n        });\n      }\n\n      // index ancestors (so we can find all children of a given entity)\n      const locs = doc?.relatedLocations;\n      if (locs) {\n        const ancestors = locs ? locs.map((x) => x.ancestors || []).flat() : [];\n        const childrenIndex = this.getIndex(constants.INDEX_CHILDREN);\n        for (let i = 0; i < ancestors.length; i++) {\n          const entity = getEntityID(ancestors[i].id);\n          if (entity) {\n            // found entity ID for this ancestor, create or update an entry for it\n            if (childrenIndex[entity] === undefined) {\n              childrenIndex[entity] = [];\n            }\n            if (childrenIndex[entity].indexOf(doc._id) < 0) {\n              childrenIndex[entity].push(doc._id);\n            }\n          }\n        }\n      }\n\n      // index document names for text searching\n      let docName = doc?.name;\n      if (docName) {\n        // simplify our doc name to only alphanumeric characters\n        docName = docName.toLowerCase().replace(/[^a-z0-9]/g, '');\n        const nameIndex = this.getIndex(constants.INDEX_NAMES);\n        if (!nameIndex[docName]) {\n          nameIndex[docName] = [];\n        }\n        nameIndex[docName].push(doc._id);\n      }\n\n      const newIndexKeys = Object.keys(newIndexEntry);\n\n      const entityIndex = this.getIndex(constants.INDEX_ENTITIES);\n      if (!entityIndex[id]) {\n        entityIndex[id] = [];\n      }\n      const findExisting = entityIndex[id].findIndex((x) => {\n        // if # keys are different, not a match\n        if (Object.keys(x).length !== newIndexKeys.length) return false;\n\n        // look for any mismatches between the keys\n        const findMismatch = newIndexKeys.find((key) => {\n          // _id is supposed to be different, so ignore it regardless of if it matches or not\n          if (key === '_id') return false;\n          return (newIndexEntry[key] !== x[key]);\n        });\n        return !findMismatch;\n      });\n\n      if (findExisting < 0) {\n        // entry doesn't exist, add to our list\n        entityIndex[id].push(newIndexEntry);\n      } else {\n        // replace existing entry that matches all the same properties\n        if (entityIndex[id][findExisting]._id !== newIndexEntry._id) {\n          entityIndex[id][findExisting] = newIndexEntry;\n        }\n      }\n    }\n  }\n\n  /**\n   * Get an array of documents from an array of _id\n   * @param {array<string>} ids\n   */\n  async getDocsById(ids) {\n    await this.init();\n\n    return (await Promise.all(ids.map((id) => {\n      // fetch each document using our local DB\n      return this.get(id);\n    }))).filter((doc) => {\n      // filter our any docs that failed to be fetched (they have been deleted etc.)\n      return doc !== undefined;\n    });\n  }\n\n  /**\n   * Find search index entries by ID\n   * If you want the actual document and not just the meta-index data, use getEntity() instead\n   * @param {string} id\n   * @param {object} [filter]\n   * @return {array<object>} Returns the index data for this entity ID\n   */\n  async getEntityIndex(id, filter = {}) {\n    await this.init();\n\n    const entityIndex = this.getIndex(constants.INDEX_ENTITIES);\n    const indexEntry = entityIndex[id];\n    if (!indexEntry) return [];\n\n    // filter entries by supplied filter options before resolving\n    return indexEntry.filter(sift(filter));\n  }\n\n  /**\n   * Return an array of children document IDs for a given entity ID\n   * @param {string} id\n   */\n  async getDocChildren(id) {\n    await this.init();\n\n    const childrenIndex = this.getIndex(constants.INDEX_CHILDREN);\n    const children = childrenIndex[id];\n    if (!children) return [];\n    return children;\n  }\n\n  /**\n   * Very rudementary text search for documents matching the incoming name.\n   * name argument will be stripped of all non-alphanumeric characters for searching.\n   * Will return an array of document IDs with matching name substrings.\n   * @param {string} name\n   */\n  async getDocNameSearch(name) {\n    const searchName = name.toLowerCase().replace(/[^a-z0-9]/g, '');\n    const nameIndex = await this.getIndex(constants.INDEX_NAMES);\n    const names = Object.keys(nameIndex);\n    const found = names.filter((x) => {\n      return x.indexOf(searchName) >= 0;\n    });\n    return found.map((x) => nameIndex[x]).flat();\n  }\n\n  /**\n   * Search for an entity in the WDW database\n   * @param {string} id Entity ID\n   * @param {object} [filter] Filter index by field\n   * @return {array<object>} Returns all documents for this entity ID\n   */\n  async getEntity(id, filter = {}) {\n    const entities = await this.getEntityIndex(id, filter);\n\n    // resolve each index entry to our full documents\n    return this.getDocsById(entities.map((entry) => {\n      return entry._id;\n    }));\n  }\n\n\n  /**\n   * Search for an entity in the WDW database\n   * Attempts to return the \"best candidate\" single document that matches the incoming ID\n   * @param {string} id Entity ID\n   * @param {object} [filter] Optional index filter\n   * @return {object} Returns the best candidate single document, or undefined\n   */\n  async getEntityOne(id, filter = {}) {\n    const entities = await this.getEntityIndex(id, filter);\n    if (entities.length === 0) return undefined;\n\n    // filter to find the best document of the ones available\n    //  prioritise language en_intl\n    const enIntl = entities.find((doc) => {\n      return doc.language === 'en_intl' && !doc.facilityStatus; // don't include facilityStatus docs by-default\n    });\n    if (enIntl) {\n      return await this.get(enIntl._id);\n    }\n\n    //  2nd priority: en_US\n    const enUS = entities.find((doc) => {\n      return doc.language === 'en_us' && !doc.facilityStatus; // don't include facilityStatus docs by-default\n    });\n    if (enUS) {\n      return await this.get(enUS._id);\n    }\n\n    // otherwise just return the first entry in out list\n    return await this.get(entities[0]._id);\n  }\n\n  /**\n   * Get the live facility status for a given entity ID\n   * @param {string} id Entity ID\n   * @return {object} Facility status document, or undefined\n   */\n  async getFacilityStatus(id) {\n    await this.init();\n\n    const statusIndex = this.getIndex(constants.INDEX_FACILITYSTATUS);\n\n    // look up entity ID in our facility status index\n    const indexEntity = statusIndex.find((x) => {\n      return x.id === id;\n    });\n    if (!indexEntity) return undefined;\n\n    return await this.get(indexEntity._id);\n  }\n\n  /**\n   * Find all documents by channel\n   * eg. 'wdw.facilitystatus.1_0' to get all WDW facility status documents\n   * @param {string} channel Channel ID\n   * @param {object} [filter] Optional document index filter\n   * @return {array<object>} All documents in this channel (or empty array)\n   */\n  async getByChannel(channel, filter = {}) {\n    await this.init();\n\n    const channelIndex = this.getIndex(constants.INDEX_CHANNELS);\n\n    const channelData = channelIndex[channel];\n    if (!channelData) {\n      return [];\n    }\n\n    // return resolved documents for the channel\n    return this.getDocsById(channelData.filter(sift(filter)).map((entry) => {\n      return entry._id;\n    }));\n  }\n\n  /**\n   * Return all documents in the database that match the given filter\n   * This is a slow operation! Use sparingly!\n   * @param {object} [filter]\n   * @return {array<object>}\n   */\n  async find(filter = {}) {\n    await this.init();\n\n    const docs = await this.allDocs({\n      include_docs: true,\n    });\n\n    return docs.rows.map((row) => row.doc).filter(sift(filter));\n  }\n\n  /**\n   * Subscribe to all database changes with an optional mongo-style filter\n   * @param {object} [filter]\n   * @param {function} callback\n   */\n  subscribeToChanges(filter, callback) {\n    if (typeof filter === 'function') {\n      // if no filter passed in, call ourselves with an empty set\n      this.subscribeToChanges({}, callback);\n    } else {\n      // listen to changes from now onwards, passing in our filter function\n      this.changes({\n        since: 'now',\n        live: true,\n        include_docs: true,\n        filter: sift(filter),\n      }).on('change', (change) => {\n        callback(change.doc);\n      });\n    }\n  }\n\n  /**\n   * Subscribe to all changes to a channel\n   * @param {string} channel\n   * @param {function} callback\n   */\n  subscribeToChannel(channel, callback) {\n    // only return documents that contain the supplied channel\n    this.subscribeToChanges({\n      channels: {\n        $elemMatch: channel,\n      },\n    }, callback);\n  }\n\n  /**\n   * Plugin function to intercept bulkDocs function\n   * We index any WDW documents we find for easier lookup later\n   * @param  {...any} args bulkDocs in\n   * @private\n   */\n  static async _pluginBulkDocs(...args) {\n    await this._initIndexes();\n\n    const body = args[0];\n    const docs = Array.isArray(body) ? body : body.docs;\n\n    // index each document being added to the database\n    await Promise.allSettled(docs.map((doc) => {\n      return this._indexWDWDocument(doc);\n    }));\n\n    // All documents check out. Pass them to PouchDB.\n    return pouchBulkDocs.call(this, ...args);\n  }\n}\n\n// add our plugin function\nIndexedWDWDB.plugin({\n  bulkDocs: IndexedWDWDB._pluginBulkDocs,\n});\n\nexport default IndexedWDWDB;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/wdw/wdwdb.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 668,
    "kind": "function",
    "name": "getEntityID",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~getEntityID",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": "{getEntityID}",
    "description": "Given a document, return it's entity ID for the WDW database",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "object",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "CouchDB document or a document ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 669,
    "kind": "variable",
    "name": "constants",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~constants",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "{\"INDEX_FACILITYSTATUS\": string, \"INDEX_CHANNELS\": string, \"INDEX_ENTITIES\": string, \"INDEX_CHILDREN\": string, \"INDEX_NAMES\": string, \"INDEX_IDS\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 670,
    "kind": "variable",
    "name": "ancestorIndexes",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~ancestorIndexes",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 671,
    "kind": "variable",
    "name": "pouchBulkDocs",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~pouchBulkDocs",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 672,
    "kind": "class",
    "name": "IndexedWDWDB",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": "{IndexedWDWDB}",
    "description": "An indexed live WDW database<br />Replicated WDW database to local disk for fast access<br />While replicating, will build an in-memory index of entities for fast lookup<br />Options to dump database to a single file or load a snapshot for quicker database boot ups",
    "lineNumber": 76,
    "interface": false,
    "extends": [
      "pouchdb~PouchDB"
    ]
  },
  {
    "__docId__": 673,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#constructor",
    "access": "public",
    "description": "Construct a new IndexedWDWDB object",
    "lineNumber": 88,
    "unknown": [
      {
        "tagName": "@extends",
        "tagValue": "PouchDB"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "PouchDB options object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.remoteHost",
        "description": "Remote database to replicate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.remoteUsername",
        "description": "Remote database username to authenticate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.remotePassword",
        "description": "Remote database password to authenticate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wdw'",
        "defaultRaw": "'wdw'",
        "name": "opts.dbName",
        "description": "Local database name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.snapshot",
        "description": "File location of a snapshot to 'seed' the database during startup"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.skipSync",
        "description": "Skip network replication, only use data already on disk"
      }
    ]
  },
  {
    "__docId__": 674,
    "kind": "member",
    "name": "config",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#config",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 675,
    "kind": "member",
    "name": "remoteDB",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#remoteDB",
    "access": "public",
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 676,
    "kind": "member",
    "name": "synced",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#synced",
    "access": "public",
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 677,
    "kind": "member",
    "name": "replicating",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#replicating",
    "access": "public",
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 678,
    "kind": "member",
    "name": "_index",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_index",
    "access": "private",
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 679,
    "kind": "member",
    "name": "_setupPromise",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_setupPromise",
    "access": "private",
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 680,
    "kind": "member",
    "name": "_indexSetup",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_indexSetup",
    "access": "private",
    "description": null,
    "lineNumber": 133,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 681,
    "kind": "method",
    "name": "getDatabaseFilePath",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB.getDatabaseFilePath",
    "access": "public",
    "description": "Get the LevelDOWN database location to use",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Database name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 682,
    "kind": "method",
    "name": "init",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#init",
    "access": "public",
    "description": "Initialise the live database, returns once finished an initial sync",
    "lineNumber": 148,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 683,
    "kind": "member",
    "name": "initPromiseSync",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#initPromiseSync",
    "access": "public",
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 686,
    "kind": "method",
    "name": "_replicate",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_replicate",
    "access": "private",
    "description": "Start database replication",
    "lineNumber": 174,
    "params": [],
    "return": null
  },
  {
    "__docId__": 689,
    "kind": "method",
    "name": "_loadAndInit",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_loadAndInit",
    "access": "private",
    "description": "Internal function<br />Loads and performs an initial sync on the database",
    "lineNumber": 239,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 690,
    "kind": "method",
    "name": "getDumpFilename",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getDumpFilename",
    "access": "public",
    "description": "Get the filename we use for saving backups of the database to disk<br />Used for creating simple \"snapshots\" to reduce initial sync times",
    "lineNumber": 274,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "postfix",
        "description": "Optional postfix for the filename\neg. Use postfix to generate a temporary version of a file to write to before replacing the \"real\" database"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 691,
    "kind": "method",
    "name": "loadSnapshot",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#loadSnapshot",
    "access": "public",
    "description": "Restore a database backup from disk<br />Perform this after running \"dump()\" on a previous synced database<br />This will help to reduce the initial sync time for large databases",
    "lineNumber": 285,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "snapshotFile",
        "description": "File path of the snapshot to restore into the database\nsnapshotFile will use default saveSnapshot result location if not supplied"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 692,
    "kind": "method",
    "name": "saveSnapshot",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#saveSnapshot",
    "access": "public",
    "description": "Save a snapshot of this live database to disk<br />This will be used to \"seed\" the database to speed up syncs for future runs",
    "lineNumber": 316,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Path to resulting database snapshot"
    },
    "params": []
  },
  {
    "__docId__": 693,
    "kind": "member",
    "name": "databaseDumpPendingPromise",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#databaseDumpPendingPromise",
    "access": "public",
    "description": null,
    "lineNumber": 329,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 695,
    "kind": "method",
    "name": "_initIndexes",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_initIndexes",
    "access": "private",
    "description": "Index initialisation<br />This function wraps taking care of creating our indexes once only",
    "lineNumber": 348,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 698,
    "kind": "method",
    "name": "_createIndexes",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_createIndexes",
    "access": "private",
    "description": "Setup our WDW indexes",
    "lineNumber": 367,
    "params": [],
    "return": null
  },
  {
    "__docId__": 699,
    "kind": "method",
    "name": "getIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getIndex",
    "access": "private",
    "description": "Get the internal index object for the given index type",
    "lineNumber": 382,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Index name (see constants.INDEX_*)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 700,
    "kind": "method",
    "name": "_createIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_createIndex",
    "access": "private",
    "description": "Create an index object to be used by this database",
    "lineNumber": 392,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Index name"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "defaultIndex",
        "description": "Index initial object state"
      }
    ],
    "return": null
  },
  {
    "__docId__": 701,
    "kind": "method",
    "name": "_extractEntityKeys",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_extractEntityKeys",
    "access": "private",
    "description": "Given a WDW document, extract key identifiable data<br />This is used to build a look-up index of unique document types<br />See ancestorIndexes for some of the keys we use<br />This is important so we can tell the difference between entities with the same ID, but different purposes<br />eg. an entity ID can have multiple documents, one for the attraction itself, one for it's wait times, etc.<br />These need to both be in the index under the same entity ID, but with different properties to make them distinct",
    "lineNumber": 409,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "WDW Database Document"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Index object containing important identifying data"
    }
  },
  {
    "__docId__": 702,
    "kind": "method",
    "name": "_extractChannelLanguage",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_extractChannelLanguage",
    "access": "private",
    "description": "Given a WDW database document, try to return its language",
    "lineNumber": 475,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Language of this document. Eg. en_intl, en_us"
    }
  },
  {
    "__docId__": 703,
    "kind": "method",
    "name": "_removeFromArrayIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_removeFromArrayIndex",
    "access": "private",
    "description": "Remove all indexes referencing docID from the given index",
    "lineNumber": 498,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 704,
    "kind": "method",
    "name": "_indexWDWDocument",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_indexWDWDocument",
    "access": "private",
    "description": "Add a document to the database index<br />Used for fast lookups of entities etc. to the correct documents",
    "lineNumber": 518,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "CouchDB document to index"
      }
    ],
    "return": null
  },
  {
    "__docId__": 705,
    "kind": "method",
    "name": "getDocsById",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getDocsById",
    "access": "public",
    "description": "Get an array of documents from an array of _id",
    "lineNumber": 671,
    "params": [
      {
        "nullable": null,
        "types": [
          "array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 706,
    "kind": "method",
    "name": "getEntityIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getEntityIndex",
    "access": "public",
    "description": "Find search index entries by ID<br />If you want the actual document and not just the meta-index data, use getEntity() instead",
    "lineNumber": 690,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": "Returns the index data for this entity ID"
    }
  },
  {
    "__docId__": 707,
    "kind": "method",
    "name": "getDocChildren",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getDocChildren",
    "access": "public",
    "description": "Return an array of children document IDs for a given entity ID",
    "lineNumber": 705,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 708,
    "kind": "method",
    "name": "getDocNameSearch",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getDocNameSearch",
    "access": "public",
    "description": "Very rudementary text search for documents matching the incoming name.<br />name argument will be stripped of all non-alphanumeric characters for searching.<br />Will return an array of document IDs with matching name substrings.",
    "lineNumber": 720,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 709,
    "kind": "method",
    "name": "getEntity",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getEntity",
    "access": "public",
    "description": "Search for an entity in the WDW database",
    "lineNumber": 736,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Entity ID"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": "Filter index by field"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": "Returns all documents for this entity ID"
    }
  },
  {
    "__docId__": 710,
    "kind": "method",
    "name": "getEntityOne",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getEntityOne",
    "access": "public",
    "description": "Search for an entity in the WDW database<br />Attempts to return the \"best candidate\" single document that matches the incoming ID",
    "lineNumber": 753,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Entity ID"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": "Optional index filter"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Returns the best candidate single document, or undefined"
    }
  },
  {
    "__docId__": 711,
    "kind": "method",
    "name": "getFacilityStatus",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getFacilityStatus",
    "access": "public",
    "description": "Get the live facility status for a given entity ID",
    "lineNumber": 783,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Entity ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Facility status document, or undefined"
    }
  },
  {
    "__docId__": 712,
    "kind": "method",
    "name": "getByChannel",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getByChannel",
    "access": "public",
    "description": "Find all documents by channel<br />eg. 'wdw.facilitystatus.1_0' to get all WDW facility status documents",
    "lineNumber": 804,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "channel",
        "description": "Channel ID"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": "Optional document index filter"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": "All documents in this channel (or empty array)"
    }
  },
  {
    "__docId__": 713,
    "kind": "method",
    "name": "find",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#find",
    "access": "public",
    "description": "Return all documents in the database that match the given filter<br />This is a slow operation! Use sparingly!",
    "lineNumber": 826,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 714,
    "kind": "method",
    "name": "subscribeToChanges",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#subscribeToChanges",
    "access": "public",
    "description": "Subscribe to all database changes with an optional mongo-style filter",
    "lineNumber": 841,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 715,
    "kind": "method",
    "name": "subscribeToChannel",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#subscribeToChannel",
    "access": "public",
    "description": "Subscribe to all changes to a channel",
    "lineNumber": 863,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "channel",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 716,
    "kind": "method",
    "name": "_pluginBulkDocs",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB._pluginBulkDocs",
    "access": "private",
    "description": "Plugin function to intercept bulkDocs function<br />We index any WDW documents we find for easier lookup later",
    "lineNumber": 878,
    "params": [
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "bulkDocs in"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 717,
    "kind": "file",
    "name": "lib/reusePromises.js",
    "content": "/**\n * Module that wraps re-using the same Promise multiple times.\n * This allows a function to be called multiple times before returning, but only return once.\n * Useful for latent network requests,\n *  such as requesting a document from multiple sources, but only making one HTTP request.\n */\n\nconst activeFunctions = [];\n\n/**\n * Find the active function with these arguments\n * @param {*} self\n * @param {function} fn\n * @param {string} argsSerialised\n * @return {number}\n * @private\n */\nfunction findActiveFunctionIndex(self, fn, argsSerialised) {\n  return activeFunctions.findIndex((x) => {\n    return x.self === self && x.fn === fn && x.args === argsSerialised;\n  });\n}\n\n/**\n * Reuse a function until it resolves\n * @param {*} self\n * @param {function} fn\n * @param  {...any} args Arguments to pass to the function\n * @return {Promise}\n */\nexport function reusePromise(self, fn, ...args) {\n  return _reusePromise(false, self, fn, ...args);\n}\n\n/**\n * Reuse a function, returning it's result forever\n * @param {*} self\n * @param {function} fn\n * @param  {...any} args Arguments to pass to the function\n * @return {Promise}\n */\nexport function reusePromiseForever(self, fn, ...args) {\n  return _reusePromise(true, self, fn, ...args);\n}\n\n/**\n * Internal call to run a Promise once time (and optionally keep result forever)\n * @param {boolean} useResultForever\n * @param {*} self\n * @param {function} fn\n * @param  {...any} args\n * @return {Promise}\n * @private\n */\nfunction _reusePromise(useResultForever, self, fn, ...args) {\n  // search for existing promise that hasn't resolved yet\n  const argsSerialise = args ? JSON.stringify(args) : null;\n  const existingFunctionIndex = findActiveFunctionIndex(self, fn, argsSerialise);\n  const existingFunction = existingFunctionIndex >= 0 ? activeFunctions[existingFunctionIndex] : undefined;\n  if (existingFunction) {\n    if (existingFunction.resolved) {\n      return existingFunction.value;\n    }\n    return existingFunction.promise;\n  }\n\n  const cleanupPendingFunction = () => {\n    const pendingFunctionIDX = findActiveFunctionIndex(self, fn, argsSerialise);\n    if (pendingFunctionIDX >= 0) {\n      if (!useResultForever) {\n      // clean up pending Promise\n        activeFunctions.splice(pendingFunctionIDX, 1);\n      }\n    }\n  };\n\n  // didn't find a pending existing promise, make a new one!\n  const newPromise = (self !== null && self !== undefined) ? fn.apply(self, args) : fn(...args);\n  newPromise.then((value) => {\n    // clean up our pending Promise\n    if (!useResultForever) {\n      cleanupPendingFunction();\n    } else {\n      const pendingFunctionIDX = findActiveFunctionIndex(self, fn, argsSerialise);\n      if (pendingFunctionIDX >= 0) {\n      // store result so we can re-use it for future calls\n        activeFunctions[pendingFunctionIDX].resolved = true;\n        activeFunctions[pendingFunctionIDX].value = value;\n      }\n    }\n\n    return value;\n  }).catch((err) => {\n    cleanupPendingFunction();\n    throw err;\n  });\n  activeFunctions.push({\n    fn,\n    self,\n    args: argsSerialise,\n    promise: newPromise,\n    resolved: false,\n  });\n  return newPromise;\n}\n\nexport default reusePromise;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/reusePromises.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 718,
    "kind": "variable",
    "name": "activeFunctions",
    "memberof": "lib/reusePromises.js",
    "static": true,
    "longname": "lib/reusePromises.js~activeFunctions",
    "access": "public",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/reusePromises.js",
    "importStyle": null,
    "description": "Module that wraps re-using the same Promise multiple times.<br />This allows a function to be called multiple times before returning, but only return once.<br />Useful for latent network requests,<br /> such as requesting a document from multiple sources, but only making one HTTP request.",
    "lineNumber": 8,
    "type": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 719,
    "kind": "function",
    "name": "findActiveFunctionIndex",
    "memberof": "lib/reusePromises.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/reusePromises.js~findActiveFunctionIndex",
    "access": "private",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/reusePromises.js",
    "importStyle": null,
    "description": "Find the active function with these arguments",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "self",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "argsSerialised",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 720,
    "kind": "function",
    "name": "reusePromise",
    "memberof": "lib/reusePromises.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/reusePromises.js~reusePromise",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/reusePromises.js",
    "importStyle": "{reusePromise}",
    "description": "Reuse a function until it resolves",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "self",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Arguments to pass to the function"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 721,
    "kind": "function",
    "name": "reusePromiseForever",
    "memberof": "lib/reusePromises.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/reusePromises.js~reusePromiseForever",
    "access": "public",
    "export": true,
    "importPath": "@themeparks/parksapi/lib/reusePromises.js",
    "importStyle": "{reusePromiseForever}",
    "description": "Reuse a function, returning it's result forever",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "self",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Arguments to pass to the function"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 722,
    "kind": "function",
    "name": "_reusePromise",
    "memberof": "lib/reusePromises.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/reusePromises.js~_reusePromise",
    "access": "private",
    "export": false,
    "importPath": "@themeparks/parksapi/lib/reusePromises.js",
    "importStyle": null,
    "description": "Internal call to run a Promise once time (and optionally keep result forever)",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "useResultForever",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "self",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "kind": "index",
    "content": "# ThemeParks.wiki Parks API\n\n![Unit Test](https://github.com/ThemeParks/parksapi/workflows/Unit%20Test/badge.svg) ![Documentation Build](https://github.com/ThemeParks/parksapi/workflows/ESDoc/badge.svg)\n\n[API Documentation](https://themeparks.github.io/parksapi/)\n\nThis is a backend module to fetch and query live data for themeparks. This source code powers the free-to-use API at [ThemeParks.wiki](https://themeparks.wiki)\n\nTo fetch data from the API, you should look at the client libraries:\n* https://github.com/ThemeParks/ThemeParks_JavaScript\n* https://github.com/ThemeParks/ThemeParks_Python\n\nFetching and parsing logic is provided in this source code. Most parks require some form of credentials, which are not supplied in this repo. You will need to source these yourself.\n\nGeneral support is available for the ThemeParks.wiki API, and not this source code (except for Sponsors with support benefits).\n\n`test.js` contains a basic set of sanity checks and output validation, which also shows how a destination object can be accessed.\n\nEach destination generates *entities*. Entities can be of various types:\n\n* Destinations\n  * i.e, Resorts\n  * These are not called resorts to avoid confusion for parks that are not part of resorts\n  * eg. Walt Disney World Resort\n* Parks\n  * All parks must be within a Destination entity\n  * eg. Magic Kingdom\n* Attraction\n  * A ride / transport / etc.\n  * Attraction entities must be within a Destination entity (usually also within a park, but not always)\n  * eg. Pirates of the Carribean\n* Resturant\n  * A dining location within a destination\n  * eg. Casey's Corner\n* Show\n  * A show / parade entity with scheduled show times\n  * eg. Main Street Electrical Parade\n\n*Entity Types Being Finalised - Destinations, Parks, and Attractions however, are well supported and unlikely to change*\n\n## Adding Destinations\n\nBest current documentation for this is to check out `scripts/templateDestination.js` and look at the existing supported destinations.\n\nSetup `index.js` with your new class, and edit `test.js` to test your destination to check everything is setup correctly.\n\n## Destinations\n\n<!-- BEGIN_DESTINATIONS -->\n* WaltDisneyWorldResort\n* DisneylandResort\n* DisneylandParis\n* TokyoDisneyResort\n* HongKongDisneyland\n* ShanghaiDisneylandResort\n* UniversalStudios\n* UniversalOrlando\n* EuropaPark\n* Efteling\n* Phantasialand\n* SeaworldOrlando\n* SeaworldSanAntonio\n* SeaworldSanDiego\n* AltonTowers\n* ThorpePark\n* ChessingtonWorldOfAdventures\n* LegolandWindsor\n* LegolandOrlando\n* Gardaland\n* PortAventuraWorld\n* ParcAsterix\n* Toverland\n* Dollywood\n* SilverDollarCity\n* Plopsaland\n* HolidayPark\n<!-- END_DESTINATIONS -->\n\n## Configuration\n\nDestination objects can be configured by either passing an object of variables into the constructor, or using environment variables (the preferred way).\n\nTo use environment variables, create a file called `.env` in the working directory of your project.\n\nEnvironment variables are structured as:\n* Class name (upper case)\n* Underscore _\n* Variable name (upper case)\n\nFor example, the class `WaltDisneyWorldResort` has a `resortId` configuration variable which can be loaded through the environment variable `WALTDISNEYWORLDRESORT_RESORTID`\n\nSome classes expose \"parent scopes\" to allow configuring environment variables once for a range of destinations. For example, Attractions.io's base URL can be configured once through `ATTRACTIONSIO_BASEURL` rather than configuring it identically for every destination.\n\nEnvironment Variables (auto-generated):\n\n<!-- BEGIN_ENV -->\n```\nWALTDISNEYWORLDRESORT_RESORTID\nWALTDISNEYWORLDRESORT_RESORTSHORTCODE\nWALTDISNEYWORLDRESORT_PARKIDS\nWALTDISNEYWORLDRESORT_VIRTUALQUEUEURL\nWALTDISNEYWORLDRESORT_GENIEDATA\nDISNEYLANDRESORT_RESORTID\nDISNEYLANDRESORT_RESORTSHORTCODE\nDISNEYLANDRESORT_PARKIDS\nDISNEYLANDRESORT_VIRTUALQUEUEURL\nDISNEYLANDRESORT_GENIEDATA\nDISNEYLANDPARIS_APIKEY\nDISNEYLANDPARIS_APIBASE\nDISNEYLANDPARIS_APIBASEWAITTIMES\nDISNEYLANDPARIS_LANGUAGE\nDISNEYLANDPARIS_STANDBYAPIBASE\nDISNEYLANDPARIS_STANDBYAPIKEY\nDISNEYLANDPARIS_STANDBYAUTHURL\nDISNEYLANDPARIS_STANDBYAPIREFRESHTOKEN\nDISNEYLANDPARIS_PREMIERACCESSAPIKEY\nDISNEYLANDPARIS_PREMIERACCESSURL\nDISNEYLANDPARIS_USERAGENT\nTOKYODISNEYRESORT_APIKEY\nTOKYODISNEYRESORT_APIAUTH\nTOKYODISNEYRESORT_APIOS\nTOKYODISNEYRESORT_APIBASE\nTOKYODISNEYRESORT_APIVERSION\nTOKYODISNEYRESORT_PARKIDS\nHONGKONGDISNEYLAND_RESORTID\nHONGKONGDISNEYLAND_RESORTSHORTCODE\nHONGKONGDISNEYLAND_PARKIDS\nHONGKONGDISNEYLAND_VIRTUALQUEUEURL\nHONGKONGDISNEYLAND_GENIEDATA\nSHANGHAIDISNEYLANDRESORT_APIBASE\nSHANGHAIDISNEYLANDRESORT_APIAUTH\nSHANGHAIDISNEYLANDRESORT_PARKIDS\nUNIVERSALSTUDIOS_CITY\nUNIVERSALSTUDIOS_RESORTSLUG\nUNIVERSALSTUDIOS_SECRETKEY\nUNIVERSALSTUDIOS_APPKEY\nUNIVERSALSTUDIOS_VQUEUEURL\nUNIVERSALSTUDIOS_BASEURL\nUNIVERSALORLANDO_CITY\nUNIVERSALORLANDO_RESORTSLUG\nUNIVERSALORLANDO_SECRETKEY\nUNIVERSALORLANDO_APPKEY\nUNIVERSALORLANDO_VQUEUEURL\nUNIVERSALORLANDO_BASEURL\nEUROPAPARK_PARKS\nEFTELING_APIKEY\nEFTELING_APIVERSION\nEFTELING_APPVERSION\nEFTELING_SEARCHURL\nEFTELING_WAITTIMESURL\nPHANTASIALAND_APIBASE\nSEAWORLDORLANDO_RESORTIDS\nSEAWORLDORLANDO_RESORTID\nSEAWORLDORLANDO_RESORTSLUG\nSEAWORLDORLANDO_APPID\nSEAWORLDORLANDO_BASEURL\nSEAWORLDSANANTONIO_RESORTIDS\nSEAWORLDSANANTONIO_RESORTID\nSEAWORLDSANANTONIO_RESORTSLUG\nSEAWORLDSANANTONIO_APPID\nSEAWORLDSANANTONIO_BASEURL\nSEAWORLDSANDIEGO_RESORTIDS\nSEAWORLDSANDIEGO_RESORTID\nSEAWORLDSANDIEGO_RESORTSLUG\nSEAWORLDSANDIEGO_APPID\nSEAWORLDSANDIEGO_BASEURL\nALTONTOWERS_DESTINATIONID\nALTONTOWERS_PARKID\nALTONTOWERS_INITIALDATAVERSION\nALTONTOWERS_APPBUILD\nALTONTOWERS_APPVERSION\nALTONTOWERS_BASEURL\nALTONTOWERS_DEVICEIDENTIFIER\nALTONTOWERS_APIKEY\nALTONTOWERS_CALENDARURL\nTHORPEPARK_DESTINATIONID\nTHORPEPARK_PARKID\nTHORPEPARK_INITIALDATAVERSION\nTHORPEPARK_APPBUILD\nTHORPEPARK_APPVERSION\nTHORPEPARK_BASEURL\nTHORPEPARK_DEVICEIDENTIFIER\nTHORPEPARK_APIKEY\nTHORPEPARK_CALENDARURL\nCHESSINGTONWORLDOFADVENTURES_DESTINATIONID\nCHESSINGTONWORLDOFADVENTURES_PARKID\nCHESSINGTONWORLDOFADVENTURES_INITIALDATAVERSION\nCHESSINGTONWORLDOFADVENTURES_APPBUILD\nCHESSINGTONWORLDOFADVENTURES_APPVERSION\nCHESSINGTONWORLDOFADVENTURES_BASEURL\nCHESSINGTONWORLDOFADVENTURES_DEVICEIDENTIFIER\nCHESSINGTONWORLDOFADVENTURES_APIKEY\nCHESSINGTONWORLDOFADVENTURES_CALENDARURL\nLEGOLANDWINDSOR_DESTINATIONID\nLEGOLANDWINDSOR_PARKID\nLEGOLANDWINDSOR_INITIALDATAVERSION\nLEGOLANDWINDSOR_APPBUILD\nLEGOLANDWINDSOR_APPVERSION\nLEGOLANDWINDSOR_BASEURL\nLEGOLANDWINDSOR_DEVICEIDENTIFIER\nLEGOLANDWINDSOR_APIKEY\nLEGOLANDWINDSOR_CALENDARURL\nLEGOLANDORLANDO_DESTINATIONID\nLEGOLANDORLANDO_PARKID\nLEGOLANDORLANDO_INITIALDATAVERSION\nLEGOLANDORLANDO_APPBUILD\nLEGOLANDORLANDO_APPVERSION\nLEGOLANDORLANDO_BASEURL\nLEGOLANDORLANDO_DEVICEIDENTIFIER\nLEGOLANDORLANDO_APIKEY\nLEGOLANDORLANDO_CALENDARURL\nGARDALAND_DESTINATIONID\nGARDALAND_PARKID\nGARDALAND_INITIALDATAVERSION\nGARDALAND_APPBUILD\nGARDALAND_APPVERSION\nGARDALAND_BASEURL\nGARDALAND_DEVICEIDENTIFIER\nGARDALAND_APIKEY\nGARDALAND_CALENDARURL\nPORTAVENTURAWORLD_APIBASE\nPARCASTERIX_APIBASE\nPARCASTERIX_LANGUAGE\nTOVERLAND_APIBASE\nTOVERLAND_CALENDARURL\nTOVERLAND_AUTHTOKEN\nTOVERLAND_LANGUAGES\nDOLLYWOOD_DESTINATIONID\nDOLLYWOOD_DESTINATIONSLUG\nDOLLYWOOD_CRMBASEURL\nDOLLYWOOD_CRMGUID\nDOLLYWOOD_CRMATTRACTIONSID\nDOLLYWOOD_CRMDININGID\nDOLLYWOOD_CRMSHOWID\nDOLLYWOOD_APIBASE\nDOLLYWOOD_CRMAUTH\nSILVERDOLLARCITY_DESTINATIONID\nSILVERDOLLARCITY_DESTINATIONSLUG\nSILVERDOLLARCITY_CRMBASEURL\nSILVERDOLLARCITY_CRMGUID\nSILVERDOLLARCITY_CRMATTRACTIONSID\nSILVERDOLLARCITY_CRMDININGID\nSILVERDOLLARCITY_CRMSHOWID\nSILVERDOLLARCITY_APIBASE\nSILVERDOLLARCITY_CRMAUTH\nPLOPSALAND_DESTINATIONSLUG\nPLOPSALAND_PARKSLUG\nPLOPSALAND_BASEURL\nPLOPSALAND_BASELANG\nPLOPSALAND_CLIENTID\nPLOPSALAND_CLIENTSECRET\nHOLIDAYPARK_DESTINATIONSLUG\nHOLIDAYPARK_PARKSLUG\nHOLIDAYPARK_BASEURL\nHOLIDAYPARK_BASELANG\nHOLIDAYPARK_CLIENTID\nHOLIDAYPARK_CLIENTSECRET\n```\n<!-- END_ENV -->",
    "longname": "/home/runner/work/parksapi/parksapi/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@themeparks/parksapi\",\n  \"type\": \"module\",\n  \"version\": \"1.2.40\",\n  \"description\": \"\",\n  \"engines\": {\n    \"npm\": \">=6\",\n    \"node\": \">=14\"\n  },\n  \"main\": \"lib/index.js\",\n  \"exports\": {\n    \".\": \"./lib/index.js\",\n    \"./park\": \"./lib/parks/park.js\",\n    \"./parkTypes\": \"./lib/parks/parkTypes.js\",\n    \"./cache/\": \"./lib/cache/\",\n    \"./cache\": \"./lib/cache.js\",\n    \"./cache/scopedCache\": \"./lib/cache/scopedCache.js\",\n    \"./tags\": \"./lib/parks/tags.js\"\n  },\n  \"scripts\": {\n    \"test\": \"npm run lint && npm run mocha\",\n    \"docs\": \"esdoc\",\n    \"mocha\": \"mocha\",\n    \"lint\": \"eslint ./lib/**/*.js\",\n    \"lintfix\": \"eslint ./lib/**/*.js --fix\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/ThemeParks/parksapi.git\"\n  },\n  \"author\": \"@cube\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ThemeParks/parksapi/issues\"\n  },\n  \"homepage\": \"https://github.com/ThemeParks/parksapi#readme\",\n  \"dependencies\": {\n    \"ajv\": \"^6.12.6\",\n    \"cheerio\": \"^1.0.0-rc.10\",\n    \"dotenv\": \"^8.2.0\",\n    \"egoroof-blowfish\": \"^2.2.2\",\n    \"fetch-cookie\": \"^0.10.1\",\n    \"json-diff\": \"^0.5.4\",\n    \"leveldown\": \"^5.4.1\",\n    \"levelup\": \"^4.1.0\",\n    \"lmdb\": \"^2.5.2\",\n    \"memdown\": \"^5.1.0\",\n    \"mingo\": \"^3.0.6\",\n    \"moment-timezone\": \"^0.5.31\",\n    \"needle\": \"^2.5.0\",\n    \"node-fetch\": \"^3.1.1\",\n    \"object-hash\": \"^2.1.1\",\n    \"pouchdb\": \"^7.2.2\",\n    \"promise-retry\": \"^2.0.1\",\n    \"random-useragent\": \"^0.4.0\",\n    \"sift\": \"^13.1.10\",\n    \"tough-cookie\": \"^4.0.0\",\n    \"uuid\": \"^8.3.0\",\n    \"yauzl\": \"^2.10.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/traverse\": \"^7.11.0\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^7.4.0\",\n    \"eslint-config-google\": \"^0.14.0\",\n    \"mocha\": \"^8.3.2\"\n  }\n}\n",
    "longname": "/home/runner/work/parksapi/parksapi/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]