[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "lib/.external-ecmascript.js",
    "static": true,
    "longname": "lib/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "lib/cache/cacheBase.js",
    "content": "/**\n * Our base Cache implementation\n * Extend this class with new implementations to create different cache types (in-memory, database, file system etc.)\n * @class\n */\nexport default class CacheBase {\n  /**\n     * @param {Object} options\n     * @param {boolean} [options.useMemoryCache=true] Use an in-memory layer on top of this cache\n     *  Avoid hitting databases too often\n     *  Not useful if using any distributed setup where memory will be out-of-sync between processes\n     * @param {(number|null)} [options.memoryCacheTimeout=null] Timeout for in-memory cache values\n     *  Default is null, which will use the incoming ttl values for each key\n     */\n  constructor(options = {\n    useMemoryCache: true,\n    memoryCacheTimeout: null,\n  }) {\n    this.memoryLayerEnabled = options.useMemoryCache;\n    this.memCache = {};\n  }\n\n  /**\n     * Internal implementation of Get()\n     * @param {string} key Unique key name for this cache entry\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     * @abstract\n     * @private\n     */\n  async _get(key) {\n    throw new Error('Missing Implementation CacheBase::_Get(key)');\n  }\n\n  /**\n     * Internal implementation of Set()\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} value\n     * @param {number} ttl How long the cache entry should last in milliseconds\n     * @abstract\n     * @private\n     */\n  async _set(key, value, ttl) {\n    throw new Error('Missing Implementation CacheBase::_Set(key, value, ttl)');\n  }\n\n  /**\n     * Internal implementation of getKeys()\n     * @param {string} prefix\n     * @abstract\n     * @private\n     */\n  async _getKeys(prefix) {\n    throw new Error('Missing Implementation CacheBase::_getKeys(prefix)');\n  }\n\n  /**\n     * Get a cached object\n     * @param {string} key Unique key name for this cache entry\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     */\n  async get(key) {\n    // our optional in-memory cache goes first\n    if (this.memoryLayerEnabled) {\n      const cacheEntry = this.memCache[key];\n      if (cacheEntry !== undefined) {\n        const now = +new Date();\n        if (cacheEntry.expires >= now) {\n          return cacheEntry.value;\n        }\n      }\n    }\n\n    // then use our internal cache if we haven't got the value stored locally\n    return await this._get(key);\n  }\n\n  /**\n     * Set a key in our cache\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} value\n     * @param {(Function|number)} [ttl=3600000] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     *  Default 1 hour\n     */\n  async set(key, value, ttl = 3600000) {\n    // resolve our cache time\n    let cacheTime = ttl;\n    // if our cache time input is a function, resolve it and store the result (in milliseconds)\n    if (typeof cacheTime === 'function') {\n      cacheTime = await cacheTime();\n    }\n\n    // optionally keep an in-memory cache layer\n    if (this.memoryLayerEnabled) {\n      const memoryCacheTime = this.memoryCacheTimeout === null ?\n        cacheTime :\n        (Math.min(this.memoryCacheTimeout, cacheTime)\n        );\n\n      this.memCache[key] = {\n        value,\n        expires: (+new Date()) + memoryCacheTime,\n      };\n    }\n\n    // call the private _Set implementation to actually set the key\n    this._set(key, value, cacheTime);\n  }\n\n  /**\n     * A helper \"wrap\" function that will return a cached value if present\n     *  This will call the supplied function to fetch it if the value isn't present in the cache\n     * @param {string} key Unique key name for this cache entry\n     * @param {function} fn Fetch function that will be called if the cache entry is not present\n     * @param {(function|number)} [ttl] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     */\n  async wrap(key, fn, ttl) {\n    // try and fetch the cached value\n    let cachedValue = await this.get(key);\n\n    // if not in our cache, call the supplied fetcher function\n    if (cachedValue === undefined) {\n      cachedValue = await fn();\n      // set the new value in our cache\n      await this.set(key, cachedValue, ttl);\n    }\n\n    // return the fetched or calculated value\n    return cachedValue;\n  }\n\n  /**\n   * Get an array of all the cached keys matching the supplied prefix\n   * @param {string} [prefix='']\n   * @return {array<string>}\n   */\n  async getKeys(prefix = '') {\n    return this._getKeys(prefix);\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheBase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "CacheBase",
    "memberof": "lib/cache/cacheBase.js",
    "static": true,
    "longname": "lib/cache/cacheBase.js~CacheBase",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/cache/cacheBase.js",
    "importStyle": "CacheBase",
    "description": "Our base Cache implementation<br />Extend this class with new implementations to create different cache types (in-memory, database, file system etc.)",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.useMemoryCache",
        "description": "Use an in-memory layer on top of this cache\n Avoid hitting databases too often\n Not useful if using any distributed setup where memory will be out-of-sync between processes"
      },
      {
        "nullable": null,
        "types": [
          "number",
          "null"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "options.memoryCacheTimeout",
        "description": "Timeout for in-memory cache values\n Default is null, which will use the incoming ttl values for each key"
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "memoryLayerEnabled",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#memoryLayerEnabled",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "memCache",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#memCache",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_get",
    "access": "private",
    "description": "Internal implementation of Get()",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    },
    "abstract": true
  },
  {
    "__docId__": 54,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_set",
    "access": "private",
    "description": "Internal implementation of Set()",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds"
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#_getKeys",
    "access": "private",
    "description": "Internal implementation of getKeys()",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "prefix",
        "description": ""
      }
    ],
    "abstract": true,
    "return": null
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "get",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#get",
    "access": "public",
    "description": "Get a cached object",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    }
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "set",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#set",
    "access": "public",
    "description": "Set a key in our cache",
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3600000",
        "defaultRaw": 3600000,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number\n Default 1 hour"
      }
    ],
    "return": null
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "wrap",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#wrap",
    "access": "public",
    "description": "A helper \"wrap\" function that will return a cached value if present<br /> This will call the supplied function to fetch it if the value isn't present in the cache",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "Fetch function that will be called if the cache entry is not present"
      },
      {
        "nullable": null,
        "types": [
          "function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "getKeys",
    "memberof": "lib/cache/cacheBase.js~CacheBase",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheBase.js~CacheBase#getKeys",
    "access": "public",
    "description": "Get an array of all the cached keys matching the supplied prefix",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "prefix",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 60,
    "kind": "file",
    "name": "lib/cache/cacheLevel.js",
    "content": "import CacheBase from './cacheBase.js';\nimport level from 'level';\nimport path from 'path';\n\n/**\n * A cache implementation using LevelDown\n * @extends CacheBase\n * @class\n */\nexport default class CacheLevel extends CacheBase {\n  /**\n   * Create new Memory cache object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.useMemoryCache = false;\n\n    super(options);\n\n    // setup our Level database\n    this.db = level(path.join(process.cwd(), 'db.cache'));\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _get(key) {\n    try {\n      const cacheEntry = await this.db.get(key);\n      if (cacheEntry !== undefined) {\n        const cacheEntryData = JSON.parse(cacheEntry);\n        const now = +new Date();\n        if (cacheEntryData.expires >= now) {\n          return cacheEntryData.value;\n        }\n      }\n    } catch (err) {\n      // ignore NotFoundError, throw any other errors back up the chain\n      if (err.name !== 'NotFoundError') {\n        throw err;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _set(key, value, ttl) {\n    await this.db.put(key, JSON.stringify({\n      value,\n      expires: (+ new Date()) + ttl,\n    }));\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getKeys(prefix) {\n    return new Promise((resolve) => {\n      const keys = [];\n      const keyStream = this.db.createKeyStream();\n      keyStream.on('data', (data) => {\n        if (data.indexOf(prefix) === 0) {\n          keys.push(data);\n        }\n      });\n      keyStream.on('end', () => {\n        return resolve(keys);\n      });\n    });\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheLevel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 61,
    "kind": "class",
    "name": "CacheLevel",
    "memberof": "lib/cache/cacheLevel.js",
    "static": true,
    "longname": "lib/cache/cacheLevel.js~CacheLevel",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/cache/cacheLevel.js",
    "importStyle": "CacheLevel",
    "description": "A cache implementation using LevelDown",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 62,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#constructor",
    "access": "public",
    "description": "Create new Memory cache object",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "db",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#db",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_get",
    "access": "private",
    "description": "",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_set",
    "access": "private",
    "description": "",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "ttl",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheLevel.js~CacheLevel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheLevel.js~CacheLevel#_getKeys",
    "access": "private",
    "description": "",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "file",
    "name": "lib/cache/cacheMemory.js",
    "content": "import CacheBase from './cacheBase.js';\n\n/**\n * A basic in-memory cache implementation\n * @extends CacheBase\n * @class\n */\nexport default class CacheMemory extends CacheBase {\n  /**\n   * Create new Memory cache object\n   * @param {object} options\n   */\n  constructor(options) {\n    // disable our internal memory cache, since this is exactly what this implementation is already doing\n    options.useMemoryCache = false;\n\n    super(options);\n\n    this.cache = {};\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _get(key) {\n    const cacheEntry = this.cache[key];\n\n    if (cacheEntry !== undefined) {\n      const now = +new Date();\n      if (cacheEntry.expires >= now) {\n        return cacheEntry.value;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _set(key, value, ttl) {\n    this.cache[key] = {\n      value,\n      expires: (+ new Date()) + ttl,\n    };\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getKeys(prefix) {\n    return Object.keys(this.cache).filter((key) => {\n      return key.indexOf(prefix) === 0;\n    });\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheMemory.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 68,
    "kind": "class",
    "name": "CacheMemory",
    "memberof": "lib/cache/cacheMemory.js",
    "static": true,
    "longname": "lib/cache/cacheMemory.js~CacheMemory",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/cache/cacheMemory.js",
    "importStyle": "CacheMemory",
    "description": "A basic in-memory cache implementation",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 69,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#constructor",
    "access": "public",
    "description": "Create new Memory cache object",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 70,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#cache",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_get",
    "access": "private",
    "description": "",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_set",
    "access": "private",
    "description": "",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "ttl",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheMemory.js~CacheMemory",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheMemory.js~CacheMemory#_getKeys",
    "access": "private",
    "description": "",
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "file",
    "name": "lib/cache/cacheSqlite.js",
    "content": "import sqlite3 from 'sqlite3';\n\nimport CacheBase from './cacheBase.js';\n\n/**\n * Caching implementation using SQLite\n * @extends CacheBase\n * @class\n */\nexport default class CacheSqlite extends CacheBase {\n  /**\n     * @param {Object} options\n     * @param {string} options.filename Database filename to use with Sqlite\n     * @param {Object} [options.db] Existing SQLite3 object to use for our database\n     *  If left empty, a database object will be created automatically\n     */\n  constructor(options = {\n    filename: ':memory:',\n    db: undefined,\n  }) {\n    options.useMemoryCache = false;\n\n    super(options);\n\n    const dbFilename = options.filename || ':memory:';\n    this.db = options.db || new sqlite3.Database(dbFilename);\n\n    this.init = false;\n  }\n\n  /**\n   * Run a query against our SQLite database\n   * @param {string} query\n   * @param {array} args\n   */\n  async runQuery(query, args) {\n    return new Promise((resolve, reject) => {\n      this.db.get(query, args, (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n        resolve(result);\n      });\n    });\n  }\n\n  /**\n   * Setup the database ready for use\n   * @private\n   */\n  async setupDB() {\n    if (this.init) return;\n\n    // setup our database\n    this.db.serialize(() => {\n      this.db.run('CREATE TABLE IF NOT EXISTS cache (key TEXT PRIMARY KEY, value TEXT, expires BIGINT)');\n    });\n\n    this.init = true;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _get(key) {\n    await this.setupDB();\n\n    const row = await this.runQuery('SELECT value FROM cache WHERE key = ? AND expires >= ?', [key, +new Date()]);\n    if (!row) return undefined;\n\n    try {\n      return JSON.parse(row.value);\n    } catch (e) {\n    }\n    return undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _set(key, value, ttl) {\n    await this.setupDB();\n\n    await this.runQuery(\n        'INSERT OR REPLACE INTO cache (key, value, expires) VALUES (?, ?, ?)',\n        [\n          key,\n          JSON.stringify(value),\n          (+new Date()) + ttl,\n        ]);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _getKeys(prefix) {\n    await this.setupDB();\n\n    return new Promise((resolve, reject) => {\n      const keys = [];\n      this.db.each('SELECT key FROM cache WHERE key LIKE \"?%\"',\n          [\n            prefix,\n          ], (err, result) => {\n            keys.push(row.key);\n          });\n      return resolve(keys);\n    });\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/cacheSqlite.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 75,
    "kind": "class",
    "name": "CacheSqlite",
    "memberof": "lib/cache/cacheSqlite.js",
    "static": true,
    "longname": "lib/cache/cacheSqlite.js~CacheSqlite",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/cache/cacheSqlite.js",
    "importStyle": "CacheSqlite",
    "description": "Caching implementation using SQLite",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "*"
    ]
  },
  {
    "__docId__": 76,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/cacheSqlite.js~CacheSqlite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/cacheSqlite.js~CacheSqlite#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.filename",
        "description": "Database filename to use with Sqlite"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.db",
        "description": "Existing SQLite3 object to use for our database\n If left empty, a database object will be created automatically"
      }
    ]
  },
  {
    "__docId__": 77,
    "kind": "member",
    "name": "db",
    "memberof": "lib/cache/cacheSqlite.js~CacheSqlite",
    "static": false,
    "longname": "lib/cache/cacheSqlite.js~CacheSqlite#db",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "member",
    "name": "init",
    "memberof": "lib/cache/cacheSqlite.js~CacheSqlite",
    "static": false,
    "longname": "lib/cache/cacheSqlite.js~CacheSqlite#init",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "runQuery",
    "memberof": "lib/cache/cacheSqlite.js~CacheSqlite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheSqlite.js~CacheSqlite#runQuery",
    "access": "public",
    "description": "Run a query against our SQLite database",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "setupDB",
    "memberof": "lib/cache/cacheSqlite.js~CacheSqlite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheSqlite.js~CacheSqlite#setupDB",
    "access": "private",
    "description": "Setup the database ready for use",
    "lineNumber": 51,
    "params": [],
    "return": null
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "_get",
    "memberof": "lib/cache/cacheSqlite.js~CacheSqlite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheSqlite.js~CacheSqlite#_get",
    "access": "private",
    "description": "",
    "lineNumber": 65,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "_set",
    "memberof": "lib/cache/cacheSqlite.js~CacheSqlite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheSqlite.js~CacheSqlite#_set",
    "access": "private",
    "description": "",
    "lineNumber": 81,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      },
      {
        "name": "ttl",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "_getKeys",
    "memberof": "lib/cache/cacheSqlite.js~CacheSqlite",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/cacheSqlite.js~CacheSqlite#_getKeys",
    "access": "private",
    "description": "",
    "lineNumber": 96,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "prefix",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "file",
    "name": "lib/cache/scopedCache.js",
    "content": "import {getCache} from '../cache.js';\n\n/**\n * A wrapper class for accessing the cache.\n * Prefixes a string before each key to avoid conflicts.\n */\nexport class ScopedCache {\n  /**\n   * Create a new ScopedCache object by passing in the key prefix descired\n   * @param {string} keyPrefix\n   * @param {number} [version] Cache version, bump this to invalidate existing cache entries for a scope\n   */\n  constructor(keyPrefix, version = 0) {\n    this.prefix = keyPrefix;\n    this.version = version;\n\n    this.cache = null;\n  }\n\n  /**\n   * Initialise the cache for this scope\n   */\n  async initCache() {\n    if (this.cache) {\n      return this.cache;\n    }\n\n    if (this._initCachePromise) {\n      return this._initCachePromise;\n    }\n\n    this._initCachePromise = (async () => {\n      this.cache = await getCache();\n\n      // check and flush cache if version mismatch\n      const cacheVersion = await this.get('%%version%%');\n      if (cacheVersion !== undefined && cacheVersion != this.version) {\n        // find all cache entries with this scope, and remove them\n        const keys = await this.cache.getKeys(`${this.prefix}_`);\n\n        await Promise.allSettled(keys.map((key) => {\n          // set expire date to 1 millisecond ago (this basically deletes it)\n          return this.setGlobal(key, {}, -1);\n        }));\n      }\n\n      // set our new cache version with a very very long ttl\n      await this.set('%%version%%', this.version, Number.MAX_SAFE_INTEGER);\n    })();\n    await this._initCachePromise;\n    this._initCachePromise = null;\n\n    return this.cache;\n  }\n\n  /**\n   * Generate a scoped key by adding our prefix to the incoming key\n   * @param {string} inKey\n   * @return {string} Scoped key\n   */\n  generateScopedKey(inKey) {\n    return `${this.prefix}_${inKey}`;\n  }\n\n  /**\n     * Get a cached object\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     */\n  async get(key) {\n    return this.getGlobal(this.generateScopedKey(key));\n  }\n\n  /**\n     * Get a cached object from the global cache (skipping the scope prefix)\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @return {(Object|undefined)} Returns the object in the cache, or undefined if not present\n     */\n  async getGlobal(key) {\n    const cache = await this.initCache();\n    return cache.get(key);\n  }\n\n  /**\n     * Set a key in our cache\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} value\n     * @param {(Function|number)} [ttl=3600000] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     *  Default 1 hour\n     */\n  async set(key, value, ttl = 3600000) {\n    return this.setGlobal(this.generateScopedKey(key), value, ttl);\n  }\n\n  /**\n     * Set a key in our global cache, skipping the scoped prefix\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {Object} value\n     * @param {(Function|number)} [ttl=3600000] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     *  Default 1 hour\n     */\n  async setGlobal(key, value, ttl = 3600000) {\n    const cache = await this.initCache();\n    return cache.set(key, value, ttl);\n  }\n\n  /**\n     * A helper \"wrap\" function that will return a cached value if present\n     *  This will call the supplied function to fetch it if the value isn't present in the cache\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {function} fn Fetch function that will be called if the cache entry is not present\n     * @param {(function|number)} [ttl] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     */\n  async wrap(key, fn, ttl) {\n    return this.wrapGlobal(this.generateScopedKey(key), fn, ttl);\n  }\n\n  /**\n     * A helper \"wrap\" function that will return a cached value if present (in the global scope)\n     *  This will call the supplied function to fetch it if the value isn't present in the cache\n     * @public\n     * @async\n     * @param {string} key Unique key name for this cache entry\n     * @param {function} fn Fetch function that will be called if the cache entry is not present\n     * @param {(function|number)} [ttl] How long the cache entry should last in milliseconds\n     *  Can be a number or a function that will return a number\n     */\n  async wrapGlobal(key, fn, ttl) {\n    const cache = await this.initCache();\n    return cache.wrap(key, fn, ttl);\n  }\n}\n\nexport default ScopedCache;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache/scopedCache.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 86,
    "kind": "class",
    "name": "ScopedCache",
    "memberof": "lib/cache/scopedCache.js",
    "static": true,
    "longname": "lib/cache/scopedCache.js~ScopedCache",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/cache/scopedCache.js",
    "importStyle": "{ScopedCache}",
    "description": "A wrapper class for accessing the cache.<br />Prefixes a string before each key to avoid conflicts.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 87,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#constructor",
    "access": "public",
    "description": "Create a new ScopedCache object by passing in the key prefix descired",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "keyPrefix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "version",
        "description": "Cache version, bump this to invalidate existing cache entries for a scope"
      }
    ]
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "prefix",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#prefix",
    "access": "public",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "version",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#version",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#cache",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "initCache",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#initCache",
    "access": "public",
    "description": "Initialise the cache for this scope",
    "lineNumber": 23,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "_initCachePromise",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#_initCachePromise",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "generateScopedKey",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#generateScopedKey",
    "access": "public",
    "description": "Generate a scoped key by adding our prefix to the incoming key",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "inKey",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Scoped key"
    }
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "get",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#get",
    "access": "public",
    "description": "Get a cached object",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    }
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "getGlobal",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#getGlobal",
    "access": "public",
    "description": "Get a cached object from the global cache (skipping the scope prefix)",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object",
        "undefined"
      ],
      "spread": false,
      "description": "Returns the object in the cache, or undefined if not present"
    }
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "set",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#set",
    "access": "public",
    "description": "Set a key in our cache",
    "lineNumber": 98,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3600000",
        "defaultRaw": 3600000,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number\n Default 1 hour"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "setGlobal",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#setGlobal",
    "access": "public",
    "description": "Set a key in our global cache, skipping the scoped prefix",
    "lineNumber": 112,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "3600000",
        "defaultRaw": 3600000,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number\n Default 1 hour"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "wrap",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#wrap",
    "access": "public",
    "description": "A helper \"wrap\" function that will return a cached value if present<br /> This will call the supplied function to fetch it if the value isn't present in the cache",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "Fetch function that will be called if the cache entry is not present"
      },
      {
        "nullable": null,
        "types": [
          "function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "wrapGlobal",
    "memberof": "lib/cache/scopedCache.js~ScopedCache",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/cache/scopedCache.js~ScopedCache#wrapGlobal",
    "access": "public",
    "description": "A helper \"wrap\" function that will return a cached value if present (in the global scope)<br /> This will call the supplied function to fetch it if the value isn't present in the cache",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Unique key name for this cache entry"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "fn",
        "description": "Fetch function that will be called if the cache entry is not present"
      },
      {
        "nullable": null,
        "types": [
          "function",
          "number"
        ],
        "spread": false,
        "optional": true,
        "name": "ttl",
        "description": "How long the cache entry should last in milliseconds\n Can be a number or a function that will return a number"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "file",
    "name": "lib/cache.js",
    "content": "/**\n * Cache provider for this module.\n * Various cache types are available, we default to using \"leveldown\" via the Level library.\n */\n\nimport CacheLevel from './cache/cacheLevel.js';\n\n// our global cache instance\nlet CacheInstance = null;\n\n/**\n * Create a new Cache Instance.\n * This function should only be called once for the lifetime of the module.\n */\nasync function createCacheInstance() {\n  // TODO - accept configured caches through environment variables (or other?)\n  return new CacheLevel();\n}\n\n/**\n  * Get the configured Cache implementation\n  */\nexport async function getCache() {\n  if (CacheInstance === null) {\n    CacheInstance = await createCacheInstance();\n  }\n\n  return CacheInstance;\n}\n\nexport default {\n  getCache,\n};\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/cache.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 103,
    "kind": "variable",
    "name": "CacheInstance",
    "memberof": "lib/cache.js",
    "static": true,
    "longname": "lib/cache.js~CacheInstance",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/cache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 104,
    "kind": "function",
    "name": "createCacheInstance",
    "memberof": "lib/cache.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/cache.js~createCacheInstance",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/cache.js",
    "importStyle": null,
    "description": "Create a new Cache Instance.<br />This function should only be called once for the lifetime of the module.",
    "lineNumber": 15,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 105,
    "kind": "function",
    "name": "getCache",
    "memberof": "lib/cache.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/cache.js~getCache",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/cache.js",
    "importStyle": "{getCache}",
    "description": "Get the configured Cache implementation",
    "lineNumber": 23,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "file",
    "name": "lib/configBase.js",
    "content": "// load any environment variables from .env (if it exists)\nimport DotEnv from 'dotenv';\nDotEnv.config();\n\nimport EventEmitter from 'events';\n\n/**\n * Combine given options with environment variables\n * @param {object} options Incoming options\n * @return {object} Processed configuration options\n */\nexport function parseConfig(options = {}) {\n  const configKeys = Object.keys(options);\n\n  const config = {};\n\n  options.configPrefixes = ['THEMEPARKS'].concat(\n      options.configPrefixes || [],\n  );\n\n  // build this.config object with our settings\n  configKeys.forEach((key) => {\n    // default prefixes are either \"classname_\" or \"THEMEPARKS_\"\n    //  classes can add more with configPrefixes\n    options.configPrefixes.forEach((prefix) => {\n      const configEnvName = `${prefix}_${key}`.toUpperCase();\n\n      if (process.env[configEnvName]) {\n        console.log(`Using env variable ${configEnvName}`);\n        config[key] = process.env[configEnvName];\n        console.log(` ${key}(env.${configEnvName})=${config[key]}`);\n      }\n    });\n\n    if (config[key] === undefined) {\n      config[key] = options[key];\n    } else {\n      // convert env variable to number if the base default is a number\n      if (typeof config[key] === 'number') {\n        config[key] = Number(config[key]);\n      } else if (typeof config[key] === 'boolean') {\n        // convert any boolean configs too\n        config[key] = (config[key] === 'true');\n      }\n    }\n  });\n\n  return config;\n}\n\n/**\n * Base Config Object\n * Supports classes with a single argument \"options\"\n * These will be sorted into a member called \"this.config\" containing all the same keys\n *\n * Crucially, these can also be overriden through environment variables\n * For example, for a config option \"timeout\" for class Database, this could be overriden through either:\n *   env.THEMEPARKS_TIMEOUT (using a \"global module name\")\n *   env.DATABASE_TIMEOUT (using the class name)\n *\n * Classes can also add additional prefixes to the supported environment variables through:\n *   new ClassInstance({configPrefixes: ['myCustomPrefix']});\n * Which would also allow env.MYCUSTOMPREFIX_TIMEOUT to be used\n *\n * Note that a default value must be supplied for the environment variable to be processed\n * If the default value is a number, the environment variable will be cast to a number as well\n * @class\n */\nexport class ConfigBase extends EventEmitter {\n  /**\n   * A base class that can be configured through environment variables\n   * @param {object} options Config for instantiating this object\n   */\n  constructor(options = {}) {\n    super();\n\n    options.configPrefixes = [this.constructor.name].concat(\n        options.configPrefixes || [],\n    );\n\n    this.config = parseConfig(options || {});\n  }\n}\n\nexport default ConfigBase;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/configBase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 107,
    "kind": "function",
    "name": "parseConfig",
    "memberof": "lib/configBase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/configBase.js~parseConfig",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/configBase.js",
    "importStyle": "{parseConfig}",
    "description": "Combine given options with environment variables",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Incoming options"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Processed configuration options"
    }
  },
  {
    "__docId__": 108,
    "kind": "class",
    "name": "ConfigBase",
    "memberof": "lib/configBase.js",
    "static": true,
    "longname": "lib/configBase.js~ConfigBase",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/configBase.js",
    "importStyle": "{ConfigBase}",
    "description": "Base Config Object<br />Supports classes with a single argument \"options\"<br />These will be sorted into a member called \"this.config\" containing all the same keys<br /><br />Crucially, these can also be overriden through environment variables<br />For example, for a config option \"timeout\" for class Database, this could be overriden through either:<br />  env.THEMEPARKS_TIMEOUT (using a \"global module name\")<br />  env.DATABASE_TIMEOUT (using the class name)<br /><br />Classes can also add additional prefixes to the supported environment variables through:<br />  new ClassInstance({configPrefixes: ['myCustomPrefix']});<br />Which would also allow env.MYCUSTOMPREFIX_TIMEOUT to be used<br /><br />Note that a default value must be supplied for the environment variable to be processed<br />If the default value is a number, the environment variable will be cast to a number as well",
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "events~EventEmitter"
    ]
  },
  {
    "__docId__": 109,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/configBase.js~ConfigBase",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/configBase.js~ConfigBase#constructor",
    "access": "public",
    "description": "A base class that can be configured through environment variables",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Config for instantiating this object"
      }
    ]
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "config",
    "memberof": "lib/configBase.js~ConfigBase",
    "static": false,
    "longname": "lib/configBase.js~ConfigBase#config",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "file",
    "name": "lib/index.js",
    "content": "",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 112,
    "kind": "file",
    "name": "lib/parks/efteling/efteling.js",
    "content": "import {Park} from '../park.js';\nimport {attractionType, statusType, queueType, tagType} from '../parkTypes.js';\n\n/**\n * Efteling Park Object\n */\nexport class Efteling extends Park {\n  /**\n   * Create a new Efteling Park object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.name = options.name || 'Efteling';\n    options.timezone = options.timezone || 'Europe/Amsterdam';\n\n    options.apiKey = '';\n    options.apiVersion = '';\n    options.appVersion = '';\n\n    options.searchUrl = options.searchUrl || 'https://prd-search-acs.efteling.com/2013-01-01/search';\n    options.waitTimesUrl = options.waitTimesUrl || 'https://api.efteling.com/app/wis/';\n\n    super(options);\n\n    if (!this.config.apiKey) throw new Error('Missing Efteling apiKey');\n    if (!this.config.apiVersion) throw new Error('Missing Efteling apiVersion');\n    if (!this.config.appVersion) throw new Error('Missing Efteling appVersion');\n\n    this.injectForDomain('*.efteling.com', (method, url, data, options) => {\n      // all requests from the app to any efteling subdomain should send these headers\n      options.headers['x-app-version'] = this.config.appVersion;\n      options.headers['x-app-name'] = 'Efteling';\n      options.headers['x-app-id'] = 'nl.efteling.android';\n      options.headers['x-app-platform'] = 'Android';\n      options.headers['x-app-language'] = 'en';\n      options.headers['x-app-timezone'] = this.config.timezone;\n      // override user-agent here, rather than class-wide\n      //  any other non-Efteling API requests can use the default user-agent\n      options.headers['user-agent'] = 'okhttp/4.4.0';\n      options.compressed = true;\n    });\n\n    this.injectForDomain('api.efteling.com', (method, url, data, options) => {\n      // api.efteling.com requries an API key as well as the above headers\n      options.headers['x-api-key'] = this.config.apiKey;\n      options.headers['x-api-version'] = this.config.apiVersion;\n    });\n  }\n\n  /**\n   * Get Efteling POI data\n   * This data contains general ride names, descriptions etc.\n   * Wait time data references this to get ride names\n   */\n  async getPOIData() {\n    return await this.cache.wrap('poidata', async () => {\n      // curl -H 'Host: prd-search-acs.efteling.com' -H 'user-agent: okhttp/4.4.0' -H 'x-app-version: v3.7.1' -H 'x-app-name: Efteling' -H 'x-app-id: nl.efteling.android' -H 'x-app-platform: Android' -H 'x-app-language: en' -H 'x-app-timezone: Europe/London' --compressed 'https://prd-search-acs.efteling.com/2013-01-01/search?q.parser=structured&size=1000&q=%28and%20%28phrase%20field%3Dlanguage%20%27en%27%29%29'\n      const fetchedPOIData = await this.http('GET', this.config.searchUrl, {\n        'size': 1000,\n        'q.parser': 'structured',\n        'q': '(and (phrase field=language \\'en\\'))',\n      });\n\n      const data = fetchedPOIData?.body?.hits?.hit;\n      if (!data) {\n        throw new Error('Failed to fetch Efteling POI data');\n      }\n\n      const poiData = {};\n      data.forEach((hit) => {\n        // skip any entries that aren't shown in the app\n        if (hit.hide_in_app) return;\n\n        if (hit.fields) {\n          poiData[hit.fields.id] = {\n            name: hit.fields.name,\n            type: hit.fields.category,\n            props: hit.fields.properties,\n          };\n\n          // try to parse lat/long\n          //  edge-case: some rides have dud \"0.0,0.0\" location, ignore these\n          if (hit.fields.latlon && hit.fields.latlon !== '0.0,0.0') {\n            const match = /([0-9.]+),([0-9.]+)/.exec(hit.fields.latlon);\n            if (match) {\n              poiData[hit.fields.id].location = {\n                latitude: Number(match[1]),\n                longitude: Number(match[2]),\n              };\n            }\n          }\n        }\n      });\n\n      return poiData;\n    }, 1000 * 60 * 60 * 12 /* cache for 12 hours */);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _init() {\n    // make sure POI data is up-to-date\n    const poi = await this.getPOIData();\n\n    // auto-populate our attractions list with all rides and shows\n    //  this makes them appear in our API output even if they have no wait time data\n    // other valid attraction types from the Efteling API:\n    //  'merchandise', 'restaurant', 'fairytale', 'facilities-toilets', 'facilities-generic', 'eventlocation', 'game'\n    const wantedAttractionTypes = ['attraction', 'show'];\n    await Promise.allSettled(Object.keys(poi).map(async (id) => {\n      const p = poi[id];\n      if (wantedAttractionTypes.indexOf(p.type) >= 0) {\n        // request the attraction by ID so it is built, then we'll tag it with some metadata\n        const attraction = await this.findAttractionByID(id);\n        if (attraction !== undefined && p.location !== undefined) {\n          // tag with attraction's location\n          await this.setAttractionTag(id, 'location', tagType.location, {\n            longitude: p.location.longitude,\n            latitude: p.location.latitude,\n          });\n\n          // look for any other useful tags\n          // may get wet\n          await this.toggleAttractionTag(id, tagType.mayGetWet, p.props.indexOf('wet') >= 0);\n          // tag \"pregnant people should not ride\" attractions\n          await this.toggleAttractionTag(\n              id,\n              tagType.unsuitableForPregnantPeople,\n              p.props.indexOf('pregnantwomen') >= 0,\n          );\n\n          // look for attraction minimum height\n          const minHeightProp = p.props.find((prop) => prop.indexOf('minimum') === 0);\n          if (minHeightProp !== undefined) {\n            const minHeightNumber = Number(minHeightProp.slice(7));\n            if (!isNaN(minHeightNumber)) {\n              await this.setAttractionTag(id, 'minimumHeight', tagType.minimumHeight, {\n                height: minHeightNumber,\n                unit: 'cm',\n              });\n            }\n          }\n        }\n      }\n    }));\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _buildAttractionObject(attractionID) {\n    const poiData = await this.getPOIData();\n\n    const data = poiData[attractionID];\n    if (!data) return undefined;\n\n    // assign the attraction type\n    let type = attractionType.other; // default to \"other\" for attractions that don't match our types\n    if (data.type === 'attraction') {\n      // all attractions default to \"ride\"\n      type = attractionType.ride;\n    } else if (data.type ==='show') {\n      type = attractionType.show;\n    }\n\n    return {\n      name: data.name,\n      type: type,\n    };\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _update() {\n    const poiData = await this.getPOIData();\n\n    const waitTimes = await this.http('GET', this.config.waitTimesUrl, {\n      language: 'en',\n    });\n\n    const attractions = waitTimes?.body?.AttractionInfo;\n    if (!attractions) throw new Error('Efteling wait times response missing AttractionInfo');\n\n    await Promise.allSettled(attractions.map(async (entry) => {\n      if (entry.Type === 'Attraction' && poiData[entry.Id] !== undefined) {\n        let rideStatus = null;\n        const rideWaitTime = parseInt(entry.WaitingTime, 10);\n        const rideState = entry.State.toLowerCase();\n        // update ride with wait time data\n        if (rideState === 'storing' || rideState === 'tijdelijkbuitenbedrijf') {\n          // Ride down because of an interruption\n          rideStatus = statusType.down;\n        } else if (rideState === 'inonderhoud') {\n          // Ride down because of maintenance/refurbishment\n          rideStatus = statusType.refurbishment;\n        } else if (rideState === 'gesloten' || rideState === '') {\n          // ride is \"closed\"\n          rideStatus = statusType.closed;\n        } else if (rideState === 'open') {\n          // Ride operating\n          rideStatus = statusType.operating;\n        }\n\n        if (rideStatus === null) {\n          console.log('Unknown Efteling rideStatus', JSON.stringify(rideState));\n        }\n\n        // update attraction status\n        await this.updateAttractionState(\n            entry.Id,\n            rideStatus,\n        );\n\n        // update queue status\n        await this.updateAttractionQueue(\n            entry.Id,\n            rideStatus == statusType.operating ? rideWaitTime : null,\n            queueType.standBy,\n        );\n      }\n    }));\n  }\n}\n\nexport default Efteling;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/efteling/efteling.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 113,
    "kind": "class",
    "name": "Efteling",
    "memberof": "lib/parks/efteling/efteling.js",
    "static": true,
    "longname": "lib/parks/efteling/efteling.js~Efteling",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/efteling/efteling.js",
    "importStyle": "{Efteling}",
    "description": "Efteling Park Object",
    "lineNumber": 7,
    "interface": false,
    "extends": [
      "lib/parks/park.js~Park"
    ]
  },
  {
    "__docId__": 114,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#constructor",
    "access": "public",
    "description": "Create a new Efteling Park object",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "getPOIData",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#getPOIData",
    "access": "public",
    "description": "Get Efteling POI data<br />This data contains general ride names, descriptions etc.<br />Wait time data references this to get ride names",
    "lineNumber": 55,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_init",
    "access": "private",
    "description": "",
    "lineNumber": 102,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_buildAttractionObject",
    "access": "private",
    "description": "",
    "lineNumber": 152,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "name": "attractionID",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"name\": *, \"type\": *}"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/efteling/efteling.js~Efteling",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/efteling/efteling.js~Efteling#_update",
    "access": "private",
    "description": "",
    "lineNumber": 176,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 119,
    "kind": "file",
    "name": "lib/parks/park.js",
    "content": "import promiseRetry from 'promise-retry';\nimport ConfigBase from '../configBase.js';\nimport needle from 'needle';\nimport domainMatch from 'domain-match';\nimport moment from 'moment-timezone';\nimport randomUseragent from 'random-useragent';\nimport Cache from '../cache/scopedCache.js';\nimport * as tags from './tags.js';\n\n// quick helper function to wait x milliseconds as a Promise\nconst delay = (milliseconds) => {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n};\n\n/** Generate a random Android user agent for making network requests */\nexport function generateRandomAndroidUseragent() {\n  randomUseragent.getRandom((ua) => {\n    return (ua.osName === 'Android');\n  });\n}\n\n/**\n * Base Park Object\n * @class\n */\nexport class Park extends ConfigBase {\n  /**\n   * Create a new park object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    // how often to wait between updates to run another update\n    options.updateInterval = 1000 * 60 * 5; // 5 minutes\n    // disable auto-update for this object\n    //  set this if the update is being handled by an external system\n    options.disableParkUpdate = false;\n\n    // generate a random Android user-agent if we aren't supplied one\n    options.useragent = options.useragent || generateRandomAndroidUseragent();\n\n    super(options);\n\n    if (!options.name) {\n      throw new Error(`Missing name for constructed park object ${this.constructor.name}`);\n    }\n\n    if (!options.timezone) {\n      throw new Error(`Missing timezone for constructed park object ${this.constructor.name}`);\n    }\n    // validate park timezone\n    if (moment.tz.names().indexOf(options.timezone) < 0) {\n      throw new Error(`Park object ${this.constructor.name} gives an invalid timezone: ${options.timezone}`);\n    }\n\n    // create a new cache object for this park\n    this.cache = new Cache(this.constructor.name, this.config.cacheVersion || 0);\n\n    this.initialised = false;\n\n    this._attractions = [];\n\n    // any HTTP injections that have been setup\n    //  allows parks to automatically intercept HTTP requests and add auth headers etc.\n    this._httpInjections = [];\n  }\n\n  /**\n   * Get a globally unique ID for this park\n   * @return {string}\n   */\n  getParkUniqueID() {\n    // by default, return the class name\n    return this.constructor.name.toLowerCase();\n  }\n\n  /**\n   * Return the current time for this park in its local timezone\n   * @return {string}\n   */\n  getTimeNow() {\n    return moment().tz(this.config.timezone).format();\n  }\n\n  /**\n   * Get Park Attractions\n   */\n  async getAttractions() {\n    // park must be initialised before returning any data\n    await this.init();\n\n    return this._attractions;\n  }\n\n  /**\n   * Setup the park for use\n   * Call to ensure the object has been initialised before accessing data\n   */\n  async init() {\n    if (this.initialised) {\n      return;\n    }\n\n    // setup the park ready for use\n    //  eg. download any large data-sets, calendars etc.\n    if (this._pendingSetupPromise) {\n      return this._pendingSetupPromise;\n    }\n\n    // call our internal init and wait on it\n    this._pendingSetupPromise = this._runInit();\n    await this._pendingSetupPromise;\n    this._pendingSetupPromise = null;\n\n    this.initialised = true;\n\n    if (!this.config.disableParkUpdate) {\n      // start an update loop\n\n      // use a separate function so we can quickly loop back around\n      const scheduleUpdate = async () => {\n        // pause for our updateInterval time\n        await delay(this.config.updateInterval);\n\n        // wait for Promise to resolve, grab any catches, then continue anyway\n        this.update().then().catch().then(() => {\n          // schedule another update\n          setImmediate(scheduleUpdate.bind(this));\n        });\n      };\n\n      // start the first loop timer\n      scheduleUpdate();\n    }\n  }\n\n  /**\n   * Run all the internal stages of the init process\n   * @private\n   */\n  async _runInit() {\n    try {\n      await this._init();\n    } catch (e) {\n      console.error('Error initialising park', e);\n    }\n\n    // run an initial update so we're fully setup with data before init() returns\n    return this.update();\n  }\n\n  /**\n   * Build an object representing an attraction from sourced data\n   * This object should not contain any \"state\" data, just static information about the attraction\n   * @param {string} attractionID Unique Attraction ID\n   * @return {object} Object containing at least 'name'.\n   * Also accepts 'type', which is an {@link attractionType}\n   */\n  async _buildAttractionObject(attractionID) {\n    throw new Error('Missing _buildAttractionObject Implementation', this.constructor.name);\n  }\n\n  /**\n   * Get data about a attraction from its ID\n   * @param {string} attractionID Unique Attraction ID\n   * @return {object} The attraction object for the given ID, or undefined\n   */\n  async findAttractionByID(attractionID) {\n    // build a unique attraction ID by prefixing the park's unique ID\n    const uniqueAttractionID = `${this.getParkUniqueID()}_${attractionID}`;\n\n    // search our existing store for this attraction\n    const attraction = this._attractions.find((attr) => attr.id == uniqueAttractionID);\n    if (attraction) {\n      return attraction;\n    }\n\n    // attraction wasn't found, try and add one to our store\n    const newAttraction = {\n      id: uniqueAttractionID,\n      rideId: attractionID, // unique attraction ID without the park prefix\n      name: undefined,\n      type: null,\n      status: {\n        status: null,\n        lastUpdated: null,\n        lastChanged: null,\n      },\n      queue: {},\n      tags: [],\n    };\n\n    // list of fields we want to accept from the park class\n    //  we don't want the park to add random fields to our attraction object\n    //  park-specific data should be added using \"tags\" instead, so our object structure is the same for all parks\n    const fieldsToCopyFromParkClass = [\n      'name',\n      'type',\n    ];\n\n    // TODO - restore stored live attraction data from a cache\n    //  restore from cache *before* we build the actual attraction data\n    //  this will allow the park API to fill in any out-of-date fields with live data\n\n    // ask the park implementation to supply us with some basic attraction information (name, type, etc.)\n    //  we'll then inject this into our attraction object, assuming it returns successfully\n    try {\n      const builtAttractionObject = await this._buildAttractionObject(attractionID);\n      if (builtAttractionObject !== undefined && !!builtAttractionObject.name) {\n        // copy fields we're interested in into our new attraction object\n        fieldsToCopyFromParkClass.forEach((key) => {\n          if (builtAttractionObject[key] !== undefined) {\n            newAttraction[key] = builtAttractionObject[key];\n          }\n        });\n\n        // add to our attractions array\n        this._attractions.push(newAttraction);\n\n        return newAttraction;\n      }\n    } catch (e) {\n      console.error('Error building attraction object:', e);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Remove a tag from a given attraction ID\n   * @param {string} attractionID\n   * @param {string} key\n   * @param {tagType} type\n   */\n  async removeAttractionTag(attractionID, key, type) {\n    const attraction = await this.findAttractionByID(attractionID);\n    if (!attraction) return;\n\n    const existingTag = attraction.tags.findIndex((t) => t.key === key && t.type === type);\n    if (existingTag >= 0) {\n      attraction.tags.splice(existingTag, 1);\n    }\n  }\n\n  /**\n   * Set a toggle tag for an attraction.\n   * This is different from more complex tags that expect a data structure.\n   * Use this for tags that don't have any actual value, but are just present. Eg. FastPass as a feature.\n   * @param {string} attractionID\n   * @param {tagType} type\n   * @param {boolean} value\n   */\n  async toggleAttractionTag(attractionID, type, value) {\n    if (!value) {\n      // if value is false, remove the key\n      const newTag = tags.getValidTagObject(null, type, null);\n      await this.removeAttractionTag(attractionID, newTag.key, type);\n    } else {\n      // otherwise, add our tag\n      await this.setAttractionTag(attractionID, null, type, null);\n    }\n  }\n\n  /**\n   * Set an attraction tag\n   * Used for metadata on rides, such as location, thrill level, fastpass availability etc.\n   * @param {string} attractionID Attraction ID to update\n   * @param {string} key Tag key to set\n   * @param {tagType} type Tag type to use\n   * @param {*} value Tag value to set\n   * @return {boolean} True if tag was stored successfully\n   */\n  async setAttractionTag(attractionID, key, type, value) {\n    // validate tag value\n    const newTag = tags.getValidTagObject(key, type, value);\n    if (newTag === undefined) {\n      return false;\n    }\n\n    // find attraction and apply tag to it\n    const attraction = await this.findAttractionByID(attractionID);\n    if (attraction) {\n      const existingTag = attraction.tags.findIndex((t) => t.key === newTag.key && t.type === newTag.type);\n      if (existingTag < 0) {\n        // push our new tag onto our attraction\n        attraction.tags.push(newTag);\n      } else {\n        // update existing tag entry\n        attraction.tags[existingTag] = newTag;\n      }\n    }\n  }\n\n  /**\n   * Update an attraction state\n   * @param {string} attractionID Unique Attraction ID\n   * @param {statusType} status New Attraction state\n   */\n  async updateAttractionState(attractionID, status) {\n    if (attractionID === undefined) return;\n\n    const existingRide = await this.findAttractionByID(attractionID);\n    if (existingRide) {\n      // if we found a matching attraction, update its \"state\" property with our new data\n      const now = this.getTimeNow();\n\n      // last updated is always kept up-to-date, regardless of whether the data changed\n      existingRide.status.lastUpdated = now;\n\n      // only update \"lastChanged\" if the status has changed\n      const previousStatus = existingRide.status.lastChanged;\n      if (previousStatus !== status || previousStatus === null) {\n        existingRide.status.status = status;\n        existingRide.status.lastChanged = now;\n\n        // broadcast updated ride event\n        //  try to make sure we have updated everything before we fire this event\n        this.emit('attractionStatus', existingRide, previousStatus);\n      }\n\n      // TODO - write updated attraction data to cache\n    }\n  }\n\n  /**\n   * Update the queue status for an attraction\n   * @param {string} attractionID Attraction ID to update\n   * @param {number} waitTime Updated Wait Time in minutes, or null if wait time doesn't exist or isn't valid\n   * @param {queueType} queueType Type of queue to update (standup, virtual, fastpass etc.)\n   */\n  async updateAttractionQueue(attractionID, waitTime = -1, queueType = queueType.standBy) {\n    if (attractionID === undefined) return;\n\n    const existingRide = await this.findAttractionByID(attractionID);\n    if (existingRide) {\n      if (!existingRide.queue) {\n        existingRide.queue = {};\n      }\n      if (!existingRide.queue[queueType]) {\n        existingRide.queue[queueType] = {\n          waitTime: null,\n          lastUpdated: null,\n          lastChanged: null,\n        };\n      }\n\n      const queueData = existingRide.queue[queueType];\n\n      const now = this.getTimeNow();\n      // wait times must be a positive number (in minutes)\n      //  if wait time is unknown (because it is not tracker or there is some issue), waitTime should be null\n      const newWaitTime = (isNaN(waitTime) || waitTime < 0) ? null : waitTime;\n      const previousWaitTime = queueData.waitTime;\n\n      // store last updated time\n      queueData.lastUpdated = now;\n\n      if (newWaitTime !== previousWaitTime || previousWaitTime === null) {\n        queueData.waitTime = newWaitTime;\n        queueData.lastChanged = now;\n\n        // broadcast updated ride event\n        //  try to make sure we have updated everything before we fire this event\n        this.emit('attractionQueue', existingRide, queueType, previousWaitTime);\n      }\n\n      // TODO - write updated attraction data to cache\n    }\n  }\n\n  /**\n   * Update this park\n   * This is automatically called for you unless disableParkUpdate is set to false\n   */\n  async update() {\n    if (this._pendingUpdatePromise) {\n      return this._pendingUpdatePromise;\n    }\n\n    // start the _update call in a retry loop\n    this._pendingUpdatePromise = promiseRetry({\n      retries: 5,\n    }, (retryFn, retryAttempt) => {\n      /* if (retryAttempt > 1) {\n        console.error(`Making attempt ${retryAttempt} to call _update on ${this.constructor.name} class`);\n      }*/\n      return this._update().catch(retryFn);\n    });\n\n    // wait and catch the update Promise\n    try {\n      await this._pendingUpdatePromise;\n    } catch (e) {\n      // TODO - record park API error somewhere and continue\n      console.error(e);\n    }\n\n    this._pendingUpdatePromise = null;\n  }\n\n  /**\n   * Internal function\n   * Called by init() to initialise the object\n   * @private\n   * @abstract\n   */\n  async _init() {\n    // implementation should be setup in child classes\n    throw new Error('_init() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Update function the park object calls on interval to update internal state\n   * @private\n   * @abstract\n   */\n  async _update() {\n    // implementation should be setup in child classes\n    throw new Error('_update() needs an implementation', this.constructor.name);\n  }\n\n  /**\n   * Register a new injection for a specific domain\n   * @param {string} domain Domain to inject for, accepts wildcards. See domain-match\n   * @param {function} func Function to call with needle request to inject extra data into.\n   * Function will take arguments: (method, URL, data, options)\n   */\n  async injectForDomain(domain, func) {\n    // add to our array of injections, this is processing by http()\n    this._httpInjections.push({\n      domain,\n      func,\n    });\n  }\n\n  /**\n   * Helper function to make an HTTP request for this park\n   * Parks can automatically add in authentication headers etc. to requests sent to this function\n   * @param {string} method HTTP method to use (GET,POST,DELETE, etc)\n   * @param {string} url URL to request\n   * @param {object} [data] data to send. Will become querystring for GET, body for POST\n   * @param {object} [options] Object containing needle-compatible HTTP options\n   */\n  async http(method, url, data = {}, options = {}) {\n    // always have a headers array\n    if (!options.headers) {\n      options.headers = {};\n    }\n\n    // inject custom standard user agent (if we have one)\n    //  do this before any custom injections so parks can optionally override this for each domain\n    if (this.config.useragent) {\n      options.headers['user-agent'] = this.config.useragent;\n    }\n\n    // check any hostname injections we have setup\n    for (let injectionIDX=0; injectionIDX<this._httpInjections.length; injectionIDX++) {\n      const injection = this._httpInjections[injectionIDX];\n\n      // check if the domain matches\n      if (domainMatch(injection.domain, url)) {\n        await injection.func(method, url, data, options);\n      }\n    }\n\n    return needle(method, url, data, options);\n  }\n}\n\nexport default Park;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/park.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 120,
    "kind": "function",
    "name": "delay",
    "memberof": "lib/parks/park.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/park.js~delay",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/parks/park.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "milliseconds",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 121,
    "kind": "function",
    "name": "generateRandomAndroidUseragent",
    "memberof": "lib/parks/park.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/park.js~generateRandomAndroidUseragent",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/park.js",
    "importStyle": "{generateRandomAndroidUseragent}",
    "description": "Generate a random Android user agent for making network requests",
    "lineNumber": 18,
    "params": [],
    "return": null
  },
  {
    "__docId__": 122,
    "kind": "class",
    "name": "Park",
    "memberof": "lib/parks/park.js",
    "static": true,
    "longname": "lib/parks/park.js~Park",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/park.js",
    "importStyle": "{Park}",
    "description": "Base Park Object",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": ""
      }
    ],
    "interface": false,
    "extends": [
      "lib/configBase.js~ConfigBase"
    ]
  },
  {
    "__docId__": 123,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/park.js~Park#constructor",
    "access": "public",
    "description": "Create a new park object",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 124,
    "kind": "member",
    "name": "cache",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#cache",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "member",
    "name": "initialised",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#initialised",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 126,
    "kind": "member",
    "name": "_attractions",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#_attractions",
    "access": "private",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "member",
    "name": "_httpInjections",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#_httpInjections",
    "access": "private",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "getParkUniqueID",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/park.js~Park#getParkUniqueID",
    "access": "public",
    "description": "Get a globally unique ID for this park",
    "lineNumber": 73,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "getTimeNow",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/park.js~Park#getTimeNow",
    "access": "public",
    "description": "Return the current time for this park in its local timezone",
    "lineNumber": 82,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "getAttractions",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#getAttractions",
    "access": "public",
    "description": "Get Park Attractions",
    "lineNumber": 89,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "init",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#init",
    "access": "public",
    "description": "Setup the park for use<br />Call to ensure the object has been initialised before accessing data",
    "lineNumber": 100,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "member",
    "name": "_pendingSetupPromise",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#_pendingSetupPromise",
    "access": "private",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "_runInit",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_runInit",
    "access": "private",
    "description": "Run all the internal stages of the init process",
    "lineNumber": 142,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_buildAttractionObject",
    "access": "private",
    "description": "Build an object representing an attraction from sourced data<br />This object should not contain any \"state\" data, just static information about the attraction",
    "lineNumber": 160,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Object containing at least 'name'.\nAlso accepts 'type', which is an {@link attractionType}"
    }
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "findAttractionByID",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#findAttractionByID",
    "access": "public",
    "description": "Get data about a attraction from its ID",
    "lineNumber": 169,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The attraction object for the given ID, or undefined"
    }
  },
  {
    "__docId__": 138,
    "kind": "method",
    "name": "removeAttractionTag",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#removeAttractionTag",
    "access": "public",
    "description": "Remove a tag from a given attraction ID",
    "lineNumber": 236,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "toggleAttractionTag",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#toggleAttractionTag",
    "access": "public",
    "description": "Set a toggle tag for an attraction.<br />This is different from more complex tags that expect a data structure.<br />Use this for tags that don't have any actual value, but are just present. Eg. FastPass as a feature.",
    "lineNumber": 254,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "setAttractionTag",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#setAttractionTag",
    "access": "public",
    "description": "Set an attraction tag<br />Used for metadata on rides, such as location, thrill level, fastpass availability etc.",
    "lineNumber": 274,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Attraction ID to update"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Tag key to set"
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "Tag type to use"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Tag value to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if tag was stored successfully"
    }
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "updateAttractionState",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#updateAttractionState",
    "access": "public",
    "description": "Update an attraction state",
    "lineNumber": 300,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      },
      {
        "nullable": null,
        "types": [
          "statusType"
        ],
        "spread": false,
        "optional": false,
        "name": "status",
        "description": "New Attraction state"
      }
    ],
    "return": null
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "updateAttractionQueue",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#updateAttractionQueue",
    "access": "public",
    "description": "Update the queue status for an attraction",
    "lineNumber": 332,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Attraction ID to update"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "waitTime",
        "description": "Updated Wait Time in minutes, or null if wait time doesn't exist or isn't valid"
      },
      {
        "nullable": null,
        "types": [
          "queueType"
        ],
        "spread": false,
        "optional": false,
        "name": "queueType",
        "description": "Type of queue to update (standup, virtual, fastpass etc.)"
      }
    ],
    "return": null
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "update",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#update",
    "access": "public",
    "description": "Update this park<br />This is automatically called for you unless disableParkUpdate is set to false",
    "lineNumber": 376,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "_pendingUpdatePromise",
    "memberof": "lib/parks/park.js~Park",
    "static": false,
    "longname": "lib/parks/park.js~Park#_pendingUpdatePromise",
    "access": "private",
    "description": null,
    "lineNumber": 382,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_init",
    "access": "private",
    "description": "Internal function<br />Called by init() to initialise the object",
    "lineNumber": 408,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#_update",
    "access": "private",
    "description": "Update function the park object calls on interval to update internal state",
    "lineNumber": 418,
    "abstract": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "injectForDomain",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#injectForDomain",
    "access": "public",
    "description": "Register a new injection for a specific domain",
    "lineNumber": 429,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "domain",
        "description": "Domain to inject for, accepts wildcards. See domain-match"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "Function to call with needle request to inject extra data into.\nFunction will take arguments: (method, URL, data, options)"
      }
    ],
    "return": null
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "http",
    "memberof": "lib/parks/park.js~Park",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/park.js~Park#http",
    "access": "public",
    "description": "Helper function to make an HTTP request for this park<br />Parks can automatically add in authentication headers etc. to requests sent to this function",
    "lineNumber": 445,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "HTTP method to use (GET,POST,DELETE, etc)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "URL to request"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "data",
        "description": "data to send. Will become querystring for GET, body for POST"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Object containing needle-compatible HTTP options"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "file",
    "name": "lib/parks/parkTypes.js",
    "content": "\n/**\n * Possible types of queue\n * @enum\n */\nexport const queueType = Object.freeze({\n  standBy: 'STANDBY',\n  singleRider: 'SINGLE_RIDER',\n  virtual: 'VIRTUAL',\n  fastPass: 'FAST_PASS',\n});\n\n/**\n * Status an attraction can be in (Operating, Down, etc.)\n * @enum\n */\nexport const statusType = Object.freeze({\n  operating: 'OPERATING',\n  down: 'DOWN',\n  closed: 'CLOSED',\n  refurbishment: 'REFURBISHMENT',\n});\n\n/**\n * All known attraction types (ride, show, etc.)\n * @enum\n */\nexport const attractionType = Object.freeze({\n  ride: 'RIDE',\n  show: 'SHOW',\n  transport: 'TRANSPORT',\n  parade: 'PARADE',\n  meetAndGreet: 'MEET_AND_GREET',\n  other: 'OTHER',\n});\n\n/**\n * All possible Tag types for attractions\n * @enum\n */\nexport const tagType = Object.freeze({\n  location: 'LOCATION',\n  fastPass: 'FASTPASS',\n  mayGetWet: 'MAY_GET_WET',\n  unsuitableForPregnantPeople: 'UNSUITABLE_PREGNANT',\n  minimumHeight: 'MINIMUM_HEIGHT',\n  maximumHeight: 'MAXIMUM_HEIGHT',\n});\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/parkTypes.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 151,
    "kind": "variable",
    "name": "queueType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~queueType",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/parkTypes.js",
    "importStyle": "{queueType}",
    "description": "Possible types of queue<br /><ul><li>queueType.standBy</li><li>queueType.singleRider</li><li>queueType.virtual</li><li>queueType.fastPass</li></ul>",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "variable",
    "name": "statusType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~statusType",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/parkTypes.js",
    "importStyle": "{statusType}",
    "description": "Status an attraction can be in (Operating, Down, etc.)<br /><ul><li>statusType.operating</li><li>statusType.down</li><li>statusType.closed</li><li>statusType.refurbishment</li></ul>",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "variable",
    "name": "attractionType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~attractionType",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/parkTypes.js",
    "importStyle": "{attractionType}",
    "description": "All known attraction types (ride, show, etc.)<br /><ul><li>attractionType.ride</li><li>attractionType.show</li><li>attractionType.transport</li><li>attractionType.parade</li><li>attractionType.meetAndGreet</li><li>attractionType.other</li></ul>",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "variable",
    "name": "tagType",
    "memberof": "lib/parks/parkTypes.js",
    "static": true,
    "longname": "lib/parks/parkTypes.js~tagType",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/parkTypes.js",
    "importStyle": "{tagType}",
    "description": "All possible Tag types for attractions<br /><ul><li>tagType.location</li><li>tagType.fastPass</li><li>tagType.mayGetWet</li><li>tagType.unsuitableForPregnantPeople</li><li>tagType.minimumHeight</li><li>tagType.maximumHeight</li></ul>",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@enum",
        "tagValue": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "file",
    "name": "lib/parks/tags.js",
    "content": "// this file handles storing different tag types\n\nimport {tagType} from './parkTypes.js';\n\n/**\n * Validate a rider height tag. Used for min/max heights\n * @param {string} key\n * @param {*} data\n * @return {boolean}\n */\nconst riderHeightValidate = (key, data) => {\n  if (!validateObjectContainsOnlyGivenKeys(data, ['height', 'unit'])) {\n    return false;\n  }\n\n  const validUnits = ['cm', 'in'];\n  if (validUnits.indexOf(data.unit) < 0) {\n    return false;\n  }\n\n  return !isNaN(data.height) && data.height >= 0;\n};\n\n/**\n * Simple tags that don't have a value entry.\n * Instead, these tags are either present or not.\n */\nconst simpleTags = {\n  [tagType.fastPass]: true,\n  [tagType.mayGetWet]: true,\n  [tagType.unsuitablePregnantPeople]: true,\n};\n\n/**\n * Each tag type must have a validator function to confirm the incoming tag value is correct\n */\nconst validators = {\n  // Location tags\n  [tagType.location]: (key, data) => {\n    // make sure we have our longitude and latitude keys\n    if (!validateObjectContainsOnlyGivenKeys(data, ['longitude', 'latitude'])) {\n      return false;\n    }\n\n    // make sure our keys are valid numbers\n    if (isNaN(data.longitude) || isNaN(data.latitude)) {\n      return false;\n    }\n\n    return true;\n  },\n  // minimum height allowed to ride\n  //  must contain \"height\" as a number, and a \"unit\" which can be 'cm' (centimeters) or 'in' (inches)\n  [tagType.minimumHeight]: riderHeightValidate,\n  // maximum height allowed to ride\n  //  must contain \"height\" as a number, and a \"unit\" which can be 'cm' (centimeters) or 'in' (inches)\n  [tagType.maximumHeight]: riderHeightValidate,\n};\n\n\n/**\n * Given an object, validate that it only contains the given keys\n * Will return false if the object is missing any keys, or has additional keys not listed\n * @param {object} data\n * @param {array<string>} keys\n * @return {boolean}\n */\nfunction validateObjectContainsOnlyGivenKeys(data, keys) {\n  // make sure our input is an object\n  if (typeof data !== 'object' || data === null) return false;\n\n  // make sure our incoming keys is an array\n  keys = [].concat(keys);\n\n  // get the keys of our incoming object\n  const dataKeys = Object.keys(data);\n  // early bail if we have a different number of keys\n  if (dataKeys.length !== keys.length) return false;\n\n  // filter all our keys against our data key\n  // TODO - this may get slow for large objects, look to optimise\n  const matchingKeys = keys.filter((key) => {\n    return dataKeys.indexOf(key) >= 0;\n  });\n  // if our filtered keys is still the same length, we have all the keys we want\n  return (matchingKeys.length === dataKeys.length);\n}\n\n/**\n * Is the supplied tag type supported?\n * @param {tagType} type\n * @return {boolean}\n */\nexport function isValidTagType(type) {\n  return validators[type] !== undefined || simpleTags[type] !== undefined;\n}\n\n/**\n * Is the given type a \"simple tag\" (one with no actual value)\n * @param {tagType} type\n * @return {boolean}\n */\nexport function isSimpleTagType(type) {\n  return simpleTags[type] !== undefined;\n}\n\n/**\n * Validate a tag value based on its type\n * @param {string} key Tag name - some tags must have a valid name\n * @param {tagType} type The type for this tag entry\n * @param {*} value The tag data to validate matches this tag format's data structure\n * @return {boolean}\n */\nexport function isValidTag(key, type, value) {\n  if (!isValidTagType(type)) {\n    return false;\n  }\n\n  // simple tags don't need to run a validator\n  if (isSimpleTagType(type)) {\n    return true;\n  }\n\n  // run tag validator to confirm we are a valid tag\n  const validator = validators[type];\n  return (validator(key, value));\n}\n\n/**\n * Given a tag key, type, and value - parse, validate, and return the full expected tag object\n * @param {string} key Tag name - some tags must have a valid name\n * @param {tagType} type The type for this tag entry\n * @param {*} value The tag data to validate matches this tag format's data structure\n * @return {object} The tag object to use, or undefined if it isn't valid\n */\nexport function getValidTagObject(key, type, value) {\n  if (!isValidTag(key, type, value)) {\n    return undefined;\n  }\n\n  // return data structure based on tag type\n  if (isSimpleTagType(type)) {\n    return {\n      type,\n    };\n  } else {\n    return {\n      key,\n      value,\n      type,\n    };\n  }\n}\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/tags.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 156,
    "kind": "function",
    "name": "riderHeightValidate",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~riderHeightValidate",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Validate a rider height tag. Used for min/max heights",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 157,
    "kind": "variable",
    "name": "simpleTags",
    "memberof": "lib/parks/tags.js",
    "static": true,
    "longname": "lib/parks/tags.js~simpleTags",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Simple tags that don't have a value entry.<br />Instead, these tags are either present or not.",
    "lineNumber": 28,
    "type": {
      "types": [
        "{\"undefined\": boolean}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 158,
    "kind": "variable",
    "name": "validators",
    "memberof": "lib/parks/tags.js",
    "static": true,
    "longname": "lib/parks/tags.js~validators",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Each tag type must have a validator function to confirm the incoming tag value is correct",
    "lineNumber": 37,
    "type": {
      "types": [
        "{\"undefined\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 159,
    "kind": "function",
    "name": "validateObjectContainsOnlyGivenKeys",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~validateObjectContainsOnlyGivenKeys",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/parks/tags.js",
    "importStyle": null,
    "description": "Given an object, validate that it only contains the given keys<br />Will return false if the object is missing any keys, or has additional keys not listed",
    "lineNumber": 68,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 160,
    "kind": "function",
    "name": "isValidTagType",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~isValidTagType",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/tags.js",
    "importStyle": "{isValidTagType}",
    "description": "Is the supplied tag type supported?",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 161,
    "kind": "function",
    "name": "isSimpleTagType",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~isSimpleTagType",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/tags.js",
    "importStyle": "{isSimpleTagType}",
    "description": "Is the given type a \"simple tag\" (one with no actual value)",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 162,
    "kind": "function",
    "name": "isValidTag",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~isValidTag",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/tags.js",
    "importStyle": "{isValidTag}",
    "description": "Validate a tag value based on its type",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Tag name - some tags must have a valid name"
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type for this tag entry"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The tag data to validate matches this tag format's data structure"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 163,
    "kind": "function",
    "name": "getValidTagObject",
    "memberof": "lib/parks/tags.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/tags.js~getValidTagObject",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/tags.js",
    "importStyle": "{getValidTagObject}",
    "description": "Given a tag key, type, and value - parse, validate, and return the full expected tag object",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "Tag name - some tags must have a valid name"
      },
      {
        "nullable": null,
        "types": [
          "tagType"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The type for this tag entry"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The tag data to validate matches this tag format's data structure"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "The tag object to use, or undefined if it isn't valid"
    }
  },
  {
    "__docId__": 164,
    "kind": "file",
    "name": "lib/parks/wdw/waltdisneyworldbase.js",
    "content": "import {IndexedWDWDB, getEntityID} from './wdwdb.js';\nimport {Park, ParkConstants} from '../park.js';\n\nlet wdwDB = null;\n\n/**\n * Base Disney Park Class\n */\nexport class DisneyPark extends Park {\n  /**\n   * Create a new DisneyPark object\n   * @param {object} options\n   */\n  constructor(options = {}) {\n    options.resort_id = options.resort_id || '';\n    options.park_id = options.park_id || '';\n\n    if (!options.configPrefixes) {\n      options.configPrefixes = ['wdw'];\n    }\n\n    super(options);\n\n    if (this.config.park_id === '') {\n      throw new Error(`Missing park_id for class ${this.constructor.name}`);\n    }\n    if (this.config.resort_id === '') {\n      throw new Error(`Missing resort_id for class ${this.constructor.name}`);\n    }\n\n    // get a reference to our shared live database\n    this.db = DisneyPark.getDatabase();\n  }\n\n  /**\n * Get the live WDW database object\n * @return {object} wdwdb live database instance\n */\n  static getDatabase() {\n    if (!wdwDB) {\n      wdwDB = new IndexedWDWDB();\n    }\n    return wdwDB;\n  }\n\n  /**\n   * Get a unique ID for this park\n   * @return {string}\n   */\n  getParkUniqueID() {\n    return `${this.config.resort_id}_${this.config.park_id}`;\n  }\n\n  /**\n   * Get the channel ID for the facility status live update documents\n   * @return {string}\n   */\n  getFacilityStatusChannelID() {\n    return `${this.config.resort_id}.facilitystatus.1_0`;\n  }\n\n  /**\n   *\n   */\n  async _init() {\n    console.log('Initialising...');\n\n    // make sure the shared database is initialised\n    await this.db.init();\n\n    // subscribe to any live facility status updates\n    this.db.subscribeToChannel(this.getFacilityStatusChannelID(), async (doc) => {\n      this._processAttractionStatusUpdate(doc);\n    });\n\n    // fetch the current attraction times\n    await Promise.all((\n      // get all attractions with facility statuses\n      await this.db.getByChannel(this.getFacilityStatusChannelID())\n    ).map(this._processAttractionStatusUpdate.bind(this)));\n  }\n\n  /**\n   * Process a document update from a facilitystatus channel\n   * @param {object} doc The updated document\n   */\n  async _processAttractionStatusUpdate(doc) {\n    // get our clean attraction ID\n    const entityID = getEntityID(doc.id);\n\n    // check attraction is within our park\n    const updateIndexEntry = await this.db.getEntityIndex(entityID, {\n      park_id: this.config.park_id,\n    });\n    // if we have no entries, then attraction is not in our park\n    if (updateIndexEntry.length === 0) {\n      return;\n    }\n\n    // figure out general ride status\n    let status = ParkConstants.STATUS_OPERATING;\n    if (doc.status === 'Down') {\n      status = ParkConstants.STATUS_DOWN;\n    } else if (doc.status === 'Closed') {\n      status = ParkConstants.STATUS_CLOSED;\n    } else if (doc.status === 'Refurbishment') {\n      status = ParkConstants.STATUS_REFURBISHMENT;\n    }\n\n    // build our status object\n    const state = {\n      status,\n      // all our queue types\n      // TODO - how to detect virtual queue and FastPass availability?\n      queues: [\n        {\n          type: ParkConstants.QUEUE_STANDBY,\n          waitTime: doc.waitMinutes,\n        },\n      ],\n    };\n\n    // console.log(entityID, state);\n\n    // update attraction status in base class\n    await this._updateAttractionState(entityID, state);\n  }\n\n  /**\n   * Build an attraction object from an ID\n   * @param {string} attractionID Unique Attraction ID\n   */\n  async _buildAttractionObject(attractionID) {\n    await this.db.init();\n\n    // find a document for our attraction ID\n    const attr = await this.db.getEntityOne(attractionID);\n    if (attr) {\n      // TODO - build a full document about this attraction\n      return {\n        id: attractionID,\n        name: attr.name,\n      };\n    }\n\n    return undefined;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  async _update() {\n    // TODO - parks that don't use the live database need to implement this function\n  }\n}\n\nexport default DisneyPark;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 165,
    "kind": "variable",
    "name": "wdwDB",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~wdwDB",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 166,
    "kind": "class",
    "name": "DisneyPark",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js",
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/wdw/waltdisneyworldbase.js",
    "importStyle": "{DisneyPark}",
    "description": "Base Disney Park Class",
    "lineNumber": 9,
    "interface": false,
    "extends": [
      "lib/parks/park.js~Park"
    ]
  },
  {
    "__docId__": 167,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#constructor",
    "access": "public",
    "description": "Create a new DisneyPark object",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 168,
    "kind": "member",
    "name": "db",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#db",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "getDatabase",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark.getDatabase",
    "access": "public",
    "description": "Get the live WDW database object",
    "lineNumber": 39,
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "wdwdb live database instance"
    },
    "params": []
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "getParkUniqueID",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#getParkUniqueID",
    "access": "public",
    "description": "Get a unique ID for this park",
    "lineNumber": 50,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 171,
    "kind": "method",
    "name": "getFacilityStatusChannelID",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#getFacilityStatusChannelID",
    "access": "public",
    "description": "Get the channel ID for the facility status live update documents",
    "lineNumber": 58,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "_init",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_init",
    "access": "private",
    "description": "",
    "lineNumber": 65,
    "params": [],
    "return": null
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "_processAttractionStatusUpdate",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_processAttractionStatusUpdate",
    "access": "private",
    "description": "Process a document update from a facilitystatus channel",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "The updated document"
      }
    ],
    "return": null
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "_buildAttractionObject",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_buildAttractionObject",
    "access": "private",
    "description": "Build an attraction object from an ID",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "attractionID",
        "description": "Unique Attraction ID"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "_update",
    "memberof": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/waltdisneyworldbase.js~DisneyPark#_update",
    "access": "private",
    "description": "",
    "lineNumber": 152,
    "unknown": [
      {
        "tagName": "@inheritdoc",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 176,
    "kind": "file",
    "name": "lib/parks/wdw/wdwdb.js",
    "content": "import PouchDB from 'pouchdb';\nimport ReplicationStream from 'pouchdb-replication-stream';\nimport sift from 'sift';\nimport {promises as fs, constants as fsConstants, createReadStream, createWriteStream} from 'fs';\nimport path from 'path';\n\nimport {parseConfig} from '../../configBase.js';\n\n/**\n * Given a document, return it's entity ID for the WDW database\n * @param {object|string} doc CouchDB document or a document ID\n * @return {string}\n */\nexport function getEntityID(doc) {\n  const docId = doc?.id || doc;\n\n  const stack = docId.split(':');\n  const lowestLevelEntity = stack[stack.length - 1];\n\n  const parts = lowestLevelEntity.split(';');\n  if (parts <= 1) return undefined;\n\n  return parts.find((p) => {\n    // edge-case for some documents with no attraction attached (guessing test documents)\n    if (p === 'Unassigned') return false;\n\n    const keyval = p.split('=');\n    return (keyval.length === 1);\n  });\n}\n\n// internal key names for our indexes. Stored as constants to save typing these over and over\nconst constants = {\n  INDEX_FACILITYSTATUS: 'facilityStatus',\n  INDEX_CHANNELS: 'channels',\n  INDEX_ENTITIES: 'entities',\n};\n\n// ancestors to include in our index\n//  we add these into our index objects to identify unique documents to index\nconst ancestorIndexes = [\n  {\n    key: 'ancestorLandId',\n    index: 'land_id',\n  },\n  {\n    key: 'ancestorResortId',\n    index: 'resort_id',\n  },\n  {\n    key: 'ancestorResortAreaId',\n    index: 'resort_area_id',\n  },\n  {\n    key: 'ancestorThemeParkId',\n    index: 'park_id',\n  },\n];\n\n// Super() function to call when we setup this class as a plugin\nconst pouchBulkDocs = PouchDB.prototype.bulkDocs;\n\n/**\n * An indexed live WDW database\n * Replicated WDW database to local disk for fast access\n * While replicating, will build an in-memory index of entities for fast lookup\n * Options to dump database to a single file or load a snapshot for quicker database boot ups\n */\nexport class IndexedWDWDB extends PouchDB {\n  /**\n   * Construct a new IndexedWDWDB object\n   * @param {object} opts PouchDB options object\n   * @param {string} [opts.remoteHost] Remote database to replicate\n   * @param {string} [opts.remoteUsername] Remote database username to authenticate\n   * @param {string} [opts.remotePassword] Remote database password to authenticate\n   * @param {string} [opts.dbName='wdw'] Local database name\n   * @param {string} [opts.snapshot] File location of a snapshot to 'seed' the database during startup\n   * @param {string} [opts.skipSync] Skip network replication, only use data already on disk\n   * @extends PouchDB\n   */\n  constructor(opts = {}) {\n    // default to enable auto_compaction\n    opts.auto_compaction = opts.auto_compaction || true;\n\n    opts.remoteHost = '';\n    opts.remoteUsername = '';\n    opts.remotePassword = '';\n    opts.dbName = opts.dbName || 'wdw';\n    opts.snapshot = ''; // optional snapshot to use when starting database\n    // 'name' is the config option pouchdb uses for the storage path\n    opts.name = opts.name || IndexedWDWDB.getDatabaseFilePath(opts.dbName);\n\n    opts.skipSync = opts.skipSync === undefined ? false : opts.skipSync;\n\n    opts.configPrefixes = ['WDWDB'].concat(opts.configPrefixes || []);\n    const config = parseConfig(opts);\n\n    super(config);\n    this.config = config;\n\n    // setup our remote host to replicate locally\n    if (this.config.remoteHost) {\n      const remoteHostOptions = {\n        skip_setup: true,\n      };\n      if (this.config.remoteUsername && this.config.remotePassword) {\n        remoteHostOptions.auth = {\n          username: this.config.remoteUsername,\n          password: this.config.remotePassword,\n        };\n      }\n\n      this.remoteDB = new PouchDB(this.config.remoteHost, remoteHostOptions);\n    }\n\n    this.synced = false;\n    this.replicating = false;\n\n    this._index = {};\n    this._setupPromise = null;\n    this._indexSetup = false;\n  }\n\n  /**\n * Get the LevelDOWN database location to use\n * @param {string} name Database name\n * @return {string}\n */\n  static getDatabaseFilePath(name) {\n    return path.join(process.cwd(), `db.${name}`);\n  }\n\n  /**\n   * Initialise the live database, returns once finished an initial sync\n   */\n  async init() {\n    if (this.synced) {\n      return;\n    }\n\n    if (this.initPromiseSync) return this.initPromiseSync;\n\n    // first, syncronise our database before we start rolling updates\n    this.initPromiseSync = this._loadAndInit();\n    // keep the Promise as a variable so we can keep returning it for any additional init() calls\n    await this.initPromiseSync;\n    this.initPromiseSync = null;\n\n    console.log(`Database finished setup!`);\n\n    this.synced = true;\n\n    if (!this.config.skipSync && this.remoteDB) {\n      this.replicating = true;\n      // start rolling replicate to keep our local database in-sync\n      PouchDB.replicate(this.remoteDB, this, {\n        live: true,\n        retry: true,\n      });\n    }\n  }\n\n  /**\n   * Internal function\n   * Loads and performs an initial sync on the database\n   * @private\n   */\n  async _loadAndInit() {\n    // first, try and restore from disk (will check if an existing snapshot exists)\n    await this.loadSnapshot();\n\n    // load up our indexes\n    await this._initIndexes();\n\n    // reindex every document once we've initialised from disk\n    //  do this before replication, since all new docs will be auto-indexed\n    const docs = await this.allDocs({\n      include_docs: true,\n    });\n    console.log('Building index...');\n    await Promise.allSettled(docs.rows.map((doc) => {\n      return this._indexWDWDocument(doc.doc);\n    }));\n\n    // optionally skip replicating with remote (for local fast testing)\n    if (this.config.skipSync || !this.remoteDB) {\n      return;\n    }\n\n    // then perform an initial replication from remote to local\n    console.log('Performing initial replication...');\n    return await PouchDB.replicate(this.remoteDB, this, {\n      batch_size: 500,\n    }).catch((e) => {\n      console.error(`Replication error: ${e}`);\n    });\n  }\n\n  /**\n   * Get the filename we use for saving backups of the database to disk\n   * Used for creating simple \"snapshots\" to reduce initial sync times\n   * @param {string} [postfix] Optional postfix for the filename\n   * eg. Use postfix to generate a temporary version of a file to write to before replacing the \"real\" database\n   * @return {string}\n   */\n  getDumpFilename(postfix = '') {\n    return path.join('localdb', `${this.config.dbName}${postfix}.db`);\n  }\n\n  /**\n   * Restore a database backup from disk\n   * Perform this after running \"dump()\" on a previous synced database\n   * This will help to reduce the initial sync time for large databases\n   * @param {string} [snapshotFile] File path of the snapshot to restore into the database\n   * snapshotFile will use default saveSnapshot result location if not supplied\n   */\n  async loadSnapshot(snapshotFile = '') {\n    if (this.synced || this.replicating) {\n      console.warn('Trying to load database snapshot when replication has already started');\n      return;\n    }\n\n    const useCustomSnapshot = !!snapshotFile;\n    const dumpPath = useCustomSnapshot ? snapshotFile : this.getDumpFilename();\n\n    // if our database dump doesn't exist, then early out and we'll do a normal sync\n    try {\n      await fs.access(dumpPath, fsConstants.F_OK);\n    } catch (error) {\n      return;\n    }\n\n    console.log('Restoring database from disk...');\n\n    // otherwise, load up our database from disk\n    const ws = createReadStream(dumpPath);\n    return this.load(ws, {\n      batch_size: 500,\n    });\n  }\n\n  /**\n   * Save a snapshot of this live database to disk\n   * This will be used to \"seed\" the database to speed up syncs for future runs\n   * @return {string} Path to resulting database snapshot\n   */\n  async saveSnapshot() {\n    if (this.databaseDumpPendingPromise) {\n      return this.databaseDumpPendingPromise;\n    }\n\n    console.log('Dumping database to disk...');\n\n    const dumpPath = this.getDumpFilename();\n    const dumpPathNew = this.getDumpFilename('_new');\n\n    // dump database to our new location\n    const ws = createWriteStream(dumpPathNew);\n    this.databaseDumpPendingPromise = this.dump(ws, {\n      batch_size: 500,\n    });\n    // save Promise so multiple \"dump()\" calls can stack cleanly\n    await this.databaseDumpPendingPromise;\n    this.databaseDumpPendingPromise = null;\n\n    // rename new database dump to our final intended location\n    return fs.rename(dumpPathNew, dumpPath).then(() => {\n      // finally, return the actual path of the snapshot\n      return dumpPath;\n    });\n  }\n\n  /**\n   * Index initialisation\n   * This function wraps taking care of creating our indexes once only\n   * @private\n   */\n  async _initIndexes() {\n    if (this._indexSetup) {\n      return;\n    }\n\n    if (this._setupPromise) {\n      return this._setupPromise;\n    }\n\n    this._setupPromise = this._createIndexes();\n    await this._setupPromise;\n    this._indexSetup = true;\n    return;\n  }\n\n  /**\n   * Setup our WDW indexes\n   * @private\n   */\n  async _createIndexes() {\n    await this._createIndex(constants.INDEX_ENTITIES);\n    await this._createIndex(constants.INDEX_CHANNELS);\n    await this._createIndex(constants.INDEX_FACILITYSTATUS, []);\n  }\n\n  /**\n   * Get the internal index object for the given index type\n   * @param {object} name Index name (see constants.INDEX_*)\n   * @return {*}\n   * @private\n   */\n  getIndex(name) {\n    return this._index[name].index;\n  }\n\n  /**\n   * Create an index object to be used by this database\n   * @param {string} name Index name\n   * @param {*} defaultIndex Index initial object state\n   * @private\n   */\n  async _createIndex(name, defaultIndex = []) {\n    this._index[name] = {\n      index: defaultIndex,\n    };\n  }\n\n  /**\n   * Given a WDW document, extract key identifiable data\n   * This is used to build a look-up index of unique document types\n   * See ancestorIndexes for some of the keys we use\n   * This is important so we can tell the difference between entities with the same ID, but different purposes\n   * eg. an entity ID can have multiple documents, one for the attraction itself, one for it's wait times, etc.\n   * These need to both be in the index under the same entity ID, but with different properties to make them distinct\n   * @param {object} doc WDW Database Document\n   * @return {object} Index object containing important identifying data\n   * @private\n   */\n  _extractEntityKeys(doc) {\n    if (!doc || !doc.id) return undefined;\n\n    // some IDs are stacked using :\n    const stack = doc.id.split(':');\n    const lowestLevelEntity = stack[stack.length - 1];\n\n    const parts = lowestLevelEntity.split(';');\n    if (parts <= 1) return undefined;\n\n    // some documents can have different parents, they're the same, but different path to get there\n    const parentStackEl = stack.length > 1 ? stack[stack.length - 2] : undefined;\n    const parent = parentStackEl ? this._extractEntityKeys({id: parentStackEl}).id : undefined;\n\n    const ret = {\n      parent,\n    };\n\n    parts.forEach((p) => {\n      const keyval = p.split('=');\n      if (keyval.length === 1) {\n        ret.id = keyval[0];\n      } else {\n        ret[keyval[0]] = keyval[1];\n      }\n    });\n\n    // if this document is in a \"facilitystatus\" channel, add an extra tag\n    //  this is so we don't collide with the actaul document for this attraction\n    //  but also so we can filter it easier later\n    const channel = doc.channels?.length ? doc.channels[0] : undefined;\n    if (channel && channel.indexOf('facilitystatus') >= 0) {\n      ret.facilityStatus = true;\n    }\n\n    // include channel in our index\n    ret.channel = channel;\n\n    // add any ancestor data to our index (that we a) care about and b) can find) - see ancestorIndexes\n    ancestorIndexes.forEach((ancestorIndex) => {\n      if (doc[ancestorIndex.key]) {\n        const ancestorID = getEntityID(doc[ancestorIndex.key]);\n        if (ancestorID) {\n          ret[ancestorIndex.index] = ancestorID;\n        }\n      }\n    });\n\n    return ret;\n  }\n\n  /**\n   * Given a WDW database document, try to return its language\n   * @param {object} doc\n   * @return {string} Language of this document. Eg. en_intl, en_us\n   * @private\n   */\n  _extractChannelLanguage(doc) {\n    // pull channel from doc\n    const channel = doc.channels?.length ? doc.channels[0] : undefined;\n    if (!channel) return undefined;\n\n    // extract language from the end of the channel name\n    let lang = channel.slice(channel.lastIndexOf('.') + 1);\n\n    // channels missing any locale are assumed English International (they are using \"1_0\" or similar)\n    if (lang.indexOf('1') === 0) {\n      lang = 'en_intl';\n    }\n\n    return lang;\n  }\n\n  /**\n   * Add a document to the database index\n   * Used for fast lookups of entities etc. to the correct documents\n   * @param {object} doc CouchDB document to index\n   * @private\n   */\n  async _indexWDWDocument(doc) {\n    const entity = this._extractEntityKeys(doc);\n    if (entity && entity.id && entity.entityType) {\n      const id = entity.id;\n\n      const newIndexEntry = {\n        ...entity,\n        language: this._extractChannelLanguage(doc),\n        _id: doc._id,\n      };\n\n      // special-case, index all facility status documents in another index\n      if (newIndexEntry.facilityStatus) {\n        const facilityIndex = this.getIndex(constants.INDEX_FACILITYSTATUS);\n\n        const docExists = facilityIndex.findIndex((x) => {\n          return x.id === newIndexEntry.id;\n        });\n        if (docExists >= 0) {\n          facilityIndex[docExists] = newIndexEntry;\n        } else {\n          facilityIndex.push(newIndexEntry);\n        }\n      }\n\n      // index all documents based on channel\n      const channel = doc.channels?.length ? doc.channels[0] : undefined;\n      if (channel) {\n        const channelIndex = this.getIndex(constants.INDEX_CHANNELS);\n        if (!channelIndex[channel]) {\n          channelIndex[channel] = [];\n        }\n        channelIndex[channel].push(newIndexEntry);\n      }\n\n      const newIndexKeys = Object.keys(newIndexEntry);\n\n      const entityIndex = this.getIndex(constants.INDEX_ENTITIES);\n      if (!entityIndex[id]) {\n        entityIndex[id] = [];\n      }\n      const findExisting = entityIndex[id].findIndex((x) => {\n        // if # keys are different, not a match\n        if (Object.keys(x).length !== newIndexKeys.length) return false;\n\n        // look for any mismatches between the keys\n        const findMismatch = newIndexKeys.find((key) => {\n          // _id is supposed to be different, so ignore it regardless of if it matches or not\n          if (key === '_id') return false;\n          return (newIndexEntry[key] !== x[key]);\n        });\n        return !findMismatch;\n      });\n\n      if (findExisting < 0) {\n        // entry doesn't exist, add to our list\n        entityIndex[id].push(newIndexEntry);\n      } else {\n        // replace existing entry that matches all the same properties\n        if (entityIndex[id][findExisting]._id !== newIndexEntry._id) {\n          entityIndex[id][findExisting] = newIndexEntry;\n        }\n      }\n    }\n  }\n\n  /**\n   * Get an array of documents from an array of _id\n   * @param {array<string>} ids\n   */\n  async getDocsById(ids) {\n    await this.init();\n\n    return (await Promise.all(ids.map((id) => {\n      // fetch each document using our local DB\n      return this.get(id);\n    }))).filter((doc) => {\n      // filter our any docs that failed to be fetched (they have been deleted etc.)\n      return doc !== undefined;\n    });\n  }\n\n  /**\n   * Find search index entries by ID\n   * If you want the actual document and not just the meta-index data, use getEntity() instead\n   * @param {string} id\n   * @param {object} [filter]\n   * @return {array<object>} Returns the index data for this entity ID\n   */\n  async getEntityIndex(id, filter = {}) {\n    await this.init();\n\n    const entityIndex = this.getIndex(constants.INDEX_ENTITIES);\n    const indexEntry = entityIndex[id];\n    if (!indexEntry) return [];\n\n    // filter entries by supplied filter options before resolving\n    return indexEntry.filter(sift(filter));\n  }\n\n  /**\n   * Search for an entity in the WDW database\n   * @param {string} id Entity ID\n   * @param {object} [filter] Filter index by field\n   * @return {array<object>} Returns all documents for this entity ID\n   */\n  async getEntity(id, filter = {}) {\n    const entities = await this.getEntityIndex(id, filter);\n\n    // resolve each index entry to our full documents\n    return this.getDocsById(entities.map((entry) => {\n      return entry._id;\n    }));\n  }\n\n\n  /**\n   * Search for an entity in the WDW database\n   * Attempts to return the \"best candidate\" single document that matches the incoming ID\n   * @param {string} id Entity ID\n   * @param {object} [filter] Optional index filter\n   * @return {object} Returns the best candidate single document, or undefined\n   */\n  async getEntityOne(id, filter = {}) {\n    const entities = await this.getEntityIndex(id, filter);\n    if (entities.length === 0) return undefined;\n\n    // filter to find the best document of the ones available\n    //  prioritise language en_intl\n    const enIntl = entities.find((doc) => {\n      return doc.language === 'en_intl' && !doc.facilityStatus; // don't include facilityStatus docs by-default\n    });\n    if (enIntl) {\n      return await this.get(enIntl._id);\n    }\n\n    //  2nd priority: en_US\n    const enUS = entities.find((doc) => {\n      return doc.language === 'en_us' && !doc.facilityStatus; // don't include facilityStatus docs by-default\n    });\n    if (enUS) {\n      return await this.get(enUS._id);\n    }\n\n    // otherwise just return the first entry in out list\n    return await this.get(entities[0]._id);\n  }\n\n  /**\n   * Get the live facility status for a given entity ID\n   * @param {string} id Entity ID\n   * @return {object} Facility status document, or undefined\n   */\n  async getFacilityStatus(id) {\n    await this.init();\n\n    const statusIndex = this.getIndex(constants.INDEX_FACILITYSTATUS);\n\n    // look up entity ID in our facility status index\n    const indexEntity = statusIndex.find((x) => {\n      return x.id === id;\n    });\n    if (!indexEntity) return undefined;\n\n    return await this.get(indexEntity._id);\n  }\n\n  /**\n   * Find all documents by channel\n   * eg. 'wdw.facilitystatus.1_0' to get all WDW facility status documents\n   * @param {string} channel Channel ID\n   * @param {object} [filter] Optional document index filter\n   * @return {array<object>} All documents in this channel (or empty array)\n   */\n  async getByChannel(channel, filter = {}) {\n    await this.init();\n\n    const channelIndex = this.getIndex(constants.INDEX_CHANNELS);\n\n    const channelData = channelIndex[channel];\n    if (!channelData) {\n      return [];\n    }\n\n    // return resolved documents for the channel\n    return this.getDocsById(channelData.filter(sift(filter)).map((entry) => {\n      return entry._id;\n    }));\n  }\n\n  /**\n   * Return all documents in the database that match the given filter\n   * This is a slow operation! Use sparingly!\n   * @param {object} [filter]\n   * @return {array<object>}\n   */\n  async find(filter = {}) {\n    await this.init();\n\n    const docs = await this.allDocs({\n      include_docs: true,\n    });\n\n    return docs.rows.map((row) => row.doc).filter(sift(filter));\n  }\n\n  /**\n   * Subscribe to all database changes with an optional mongo-style filter\n   * @param {object} [filter]\n   * @param {function} callback\n   */\n  subscribeToChanges(filter, callback) {\n    if (typeof filter === 'function') {\n      // if no filter passed in, call ourselves with an empty set\n      this.subscribeToChanges({}, callback);\n    } else {\n      // listen to changes from now onwards, passing in our filter function\n      this.changes({\n        since: 'now',\n        live: true,\n        include_docs: true,\n        filter: sift(filter),\n      }).on('change', (change) => {\n        callback(change.doc);\n      });\n    }\n  }\n\n  /**\n   * Subscribe to all changes to a channel\n   * @param {string} channel\n   * @param {function} callback\n   */\n  subscribeToChannel(channel, callback) {\n    // only return documents that contain the supplied channel\n    this.subscribeToChanges({\n      channels: {\n        $elemMatch: channel,\n      },\n    }, callback);\n  }\n\n  /**\n   * Plugin function to intercept bulkDocs function\n   * We index any WDW documents we find for easier lookup later\n   * @param  {...any} args bulkDocs in\n   * @private\n   */\n  static async _pluginBulkDocs(...args) {\n    await this._initIndexes();\n\n    const body = args[0];\n    const docs = Array.isArray(body) ? body : body.docs;\n\n    // index each document being added to the database\n    // TODO - do we need to handle deletion events here?\n    await Promise.allSettled(docs.map((doc) => {\n      return this._indexWDWDocument(doc);\n    }));\n\n    // All documents check out. Pass them to PouchDB.\n    return pouchBulkDocs.call(this, ...args);\n  }\n}\n\n// add our plugin function\nIndexedWDWDB.plugin({\n  bulkDocs: IndexedWDWDB._pluginBulkDocs,\n});\n\n// pouchdb-replication-stream allows us to \"seed\" the database with an initial database dump\n//  incredibly useful for the wdw db, which is pretty huge\nIndexedWDWDB.plugin(ReplicationStream.plugin);\nPouchDB.adapter('writableStream', ReplicationStream.adapters.writableStream);\n\nexport default IndexedWDWDB;\n",
    "static": true,
    "longname": "/home/runner/work/parksapi/parksapi/lib/parks/wdw/wdwdb.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 177,
    "kind": "function",
    "name": "getEntityID",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~getEntityID",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": "{getEntityID}",
    "description": "Given a document, return it's entity ID for the WDW database",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "object",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "CouchDB document or a document ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 178,
    "kind": "variable",
    "name": "constants",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~constants",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "{\"INDEX_FACILITYSTATUS\": string, \"INDEX_CHANNELS\": string, \"INDEX_ENTITIES\": string}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 179,
    "kind": "variable",
    "name": "ancestorIndexes",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~ancestorIndexes",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 180,
    "kind": "variable",
    "name": "pouchBulkDocs",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~pouchBulkDocs",
    "access": "public",
    "export": false,
    "importPath": "parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 181,
    "kind": "class",
    "name": "IndexedWDWDB",
    "memberof": "lib/parks/wdw/wdwdb.js",
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "access": "public",
    "export": true,
    "importPath": "parksapi/lib/parks/wdw/wdwdb.js",
    "importStyle": "{IndexedWDWDB}",
    "description": "An indexed live WDW database<br />Replicated WDW database to local disk for fast access<br />While replicating, will build an in-memory index of entities for fast lookup<br />Options to dump database to a single file or load a snapshot for quicker database boot ups",
    "lineNumber": 69,
    "interface": false,
    "extends": [
      "pouchdb~PouchDB"
    ]
  },
  {
    "__docId__": 182,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#constructor",
    "access": "public",
    "description": "Construct a new IndexedWDWDB object",
    "lineNumber": 81,
    "unknown": [
      {
        "tagName": "@extends",
        "tagValue": "PouchDB"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "opts",
        "description": "PouchDB options object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.remoteHost",
        "description": "Remote database to replicate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.remoteUsername",
        "description": "Remote database username to authenticate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.remotePassword",
        "description": "Remote database password to authenticate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wdw'",
        "defaultRaw": "'wdw'",
        "name": "opts.dbName",
        "description": "Local database name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.snapshot",
        "description": "File location of a snapshot to 'seed' the database during startup"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "opts.skipSync",
        "description": "Skip network replication, only use data already on disk"
      }
    ]
  },
  {
    "__docId__": 183,
    "kind": "member",
    "name": "config",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#config",
    "access": "public",
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "member",
    "name": "remoteDB",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#remoteDB",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "member",
    "name": "synced",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#synced",
    "access": "public",
    "description": null,
    "lineNumber": 116,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "member",
    "name": "replicating",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#replicating",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "member",
    "name": "_index",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_index",
    "access": "private",
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "member",
    "name": "_setupPromise",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_setupPromise",
    "access": "private",
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "member",
    "name": "_indexSetup",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_indexSetup",
    "access": "private",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "getDatabaseFilePath",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB.getDatabaseFilePath",
    "access": "public",
    "description": "Get the LevelDOWN database location to use",
    "lineNumber": 129,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Database name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "init",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#init",
    "access": "public",
    "description": "Initialise the live database, returns once finished an initial sync",
    "lineNumber": 136,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "member",
    "name": "initPromiseSync",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#initPromiseSync",
    "access": "public",
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "method",
    "name": "_loadAndInit",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_loadAndInit",
    "access": "private",
    "description": "Internal function<br />Loads and performs an initial sync on the database",
    "lineNumber": 168,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "getDumpFilename",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getDumpFilename",
    "access": "public",
    "description": "Get the filename we use for saving backups of the database to disk<br />Used for creating simple \"snapshots\" to reduce initial sync times",
    "lineNumber": 206,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "postfix",
        "description": "Optional postfix for the filename\neg. Use postfix to generate a temporary version of a file to write to before replacing the \"real\" database"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "loadSnapshot",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#loadSnapshot",
    "access": "public",
    "description": "Restore a database backup from disk<br />Perform this after running \"dump()\" on a previous synced database<br />This will help to reduce the initial sync time for large databases",
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "snapshotFile",
        "description": "File path of the snapshot to restore into the database\nsnapshotFile will use default saveSnapshot result location if not supplied"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "method",
    "name": "saveSnapshot",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#saveSnapshot",
    "access": "public",
    "description": "Save a snapshot of this live database to disk<br />This will be used to \"seed\" the database to speed up syncs for future runs",
    "lineNumber": 247,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Path to resulting database snapshot"
    },
    "params": []
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "databaseDumpPendingPromise",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#databaseDumpPendingPromise",
    "access": "public",
    "description": null,
    "lineNumber": 259,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "_initIndexes",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_initIndexes",
    "access": "private",
    "description": "Index initialisation<br />This function wraps taking care of creating our indexes once only",
    "lineNumber": 278,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "_createIndexes",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_createIndexes",
    "access": "private",
    "description": "Setup our WDW indexes",
    "lineNumber": 297,
    "params": [],
    "return": null
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "getIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getIndex",
    "access": "private",
    "description": "Get the internal index object for the given index type",
    "lineNumber": 309,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Index name (see constants.INDEX_*)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "_createIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_createIndex",
    "access": "private",
    "description": "Create an index object to be used by this database",
    "lineNumber": 319,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Index name"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "defaultIndex",
        "description": "Index initial object state"
      }
    ],
    "return": null
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "_extractEntityKeys",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_extractEntityKeys",
    "access": "private",
    "description": "Given a WDW document, extract key identifiable data<br />This is used to build a look-up index of unique document types<br />See ancestorIndexes for some of the keys we use<br />This is important so we can tell the difference between entities with the same ID, but different purposes<br />eg. an entity ID can have multiple documents, one for the attraction itself, one for it's wait times, etc.<br />These need to both be in the index under the same entity ID, but with different properties to make them distinct",
    "lineNumber": 336,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "WDW Database Document"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Index object containing important identifying data"
    }
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "_extractChannelLanguage",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_extractChannelLanguage",
    "access": "private",
    "description": "Given a WDW database document, try to return its language",
    "lineNumber": 393,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Language of this document. Eg. en_intl, en_us"
    }
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "_indexWDWDocument",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#_indexWDWDocument",
    "access": "private",
    "description": "Add a document to the database index<br />Used for fast lookups of entities etc. to the correct documents",
    "lineNumber": 415,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": "CouchDB document to index"
      }
    ],
    "return": null
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "getDocsById",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getDocsById",
    "access": "public",
    "description": "Get an array of documents from an array of _id",
    "lineNumber": 485,
    "params": [
      {
        "nullable": null,
        "types": [
          "array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "getEntityIndex",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getEntityIndex",
    "access": "public",
    "description": "Find search index entries by ID<br />If you want the actual document and not just the meta-index data, use getEntity() instead",
    "lineNumber": 504,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": "Returns the index data for this entity ID"
    }
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "getEntity",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getEntity",
    "access": "public",
    "description": "Search for an entity in the WDW database",
    "lineNumber": 521,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Entity ID"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": "Filter index by field"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": "Returns all documents for this entity ID"
    }
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "getEntityOne",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getEntityOne",
    "access": "public",
    "description": "Search for an entity in the WDW database<br />Attempts to return the \"best candidate\" single document that matches the incoming ID",
    "lineNumber": 538,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Entity ID"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": "Optional index filter"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Returns the best candidate single document, or undefined"
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "getFacilityStatus",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getFacilityStatus",
    "access": "public",
    "description": "Get the live facility status for a given entity ID",
    "lineNumber": 568,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Entity ID"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "Facility status document, or undefined"
    }
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "getByChannel",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#getByChannel",
    "access": "public",
    "description": "Find all documents by channel<br />eg. 'wdw.facilitystatus.1_0' to get all WDW facility status documents",
    "lineNumber": 589,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "channel",
        "description": "Channel ID"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": "Optional document index filter"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": "All documents in this channel (or empty array)"
    }
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "find",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#find",
    "access": "public",
    "description": "Return all documents in the database that match the given filter<br />This is a slow operation! Use sparingly!",
    "lineNumber": 611,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array<object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 218,
    "kind": "method",
    "name": "subscribeToChanges",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#subscribeToChanges",
    "access": "public",
    "description": "Subscribe to all database changes with an optional mongo-style filter",
    "lineNumber": 626,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "name": "filter",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "subscribeToChannel",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB#subscribeToChannel",
    "access": "public",
    "description": "Subscribe to all changes to a channel",
    "lineNumber": 648,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "channel",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 220,
    "kind": "method",
    "name": "_pluginBulkDocs",
    "memberof": "lib/parks/wdw/wdwdb.js~IndexedWDWDB",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "lib/parks/wdw/wdwdb.js~IndexedWDWDB._pluginBulkDocs",
    "access": "private",
    "description": "Plugin function to intercept bulkDocs function<br />We index any WDW documents we find for easier lookup later",
    "lineNumber": 663,
    "params": [
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "bulkDocs in"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "kind": "index",
    "content": "# Parks API\n\n![Unit Test](https://github.com/ThemeParks/parksapi/workflows/Unit%20Test/badge.svg) ![Documentation Build](https://github.com/ThemeParks/parksapi/workflows/ESDoc/badge.svg)\n\n[API Documentation](https://themeparks.github.io/parksapi/)\n\nThis is a backend module to fetch and query live data for themeparks.\n\nTemplate support is provided in this module. Most parks require some form of credentials, which are not supplied in this repo.\n",
    "longname": "/home/runner/work/parksapi/parksapi/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"parksapi\",\n  \"type\": \"module\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"engines\": {\n    \"npm\": \">=6\",\n    \"node\": \">=14\"\n  },\n  \"main\": \"lib/index.js\",\n  \"scripts\": {\n    \"test\": \"eslint ./lib/**\",\n    \"docs\": \"esdoc\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/ThemeParks/parksapi.git\"\n  },\n  \"author\": \"@cube\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ThemeParks/parksapi/issues\"\n  },\n  \"homepage\": \"https://github.com/ThemeParks/parksapi#readme\",\n  \"dependencies\": {\n    \"domain-match\": \"^1.0.0\",\n    \"dotenv\": \"^8.2.0\",\n    \"moment-timezone\": \"^0.5.31\",\n    \"needle\": \"^2.5.0\",\n    \"pouchdb\": \"^7.2.1\",\n    \"pouchdb-replication-stream\": \"github:pouchdb-community/pouchdb-replication-stream#56f0511\",\n    \"promise-retry\": \"^2.0.1\",\n    \"random-useragent\": \"^0.4.0\",\n    \"sift\": \"^13.1.10\",\n    \"sqlite3\": \"^5.0.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/traverse\": \"^7.11.0\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^7.4.0\",\n    \"eslint-config-google\": \"^0.14.0\"\n  }\n}\n",
    "longname": "/home/runner/work/parksapi/parksapi/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]